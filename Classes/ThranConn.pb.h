// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ThranConn.proto

#ifndef PROTOBUF_ThranConn_2eproto__INCLUDED
#define PROTOBUF_ThranConn_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ThranConn_2eproto();
void protobuf_AssignDesc_ThranConn_2eproto();
void protobuf_ShutdownFile_ThranConn_2eproto();

class REQThranReg;
class ACKThranReg;
class REQThranConn;
class ACKThranConn;
class REQThranShortCert;
class ACKThranShortCert;
class REQThranOpenId;
class ACKThranOpenId;
class REQSinaGame;
class ACKSinaGame;
class REQWeiBo;
class ACKWeiBo;
class REQThranExit;
class REQThranGameVersion;
class ACKThranGameVersion;
class REQThranNewVerify;
class ACKThranNewVerify;
class REQThranFindPwd;
class ACKThranFindPwd;
class ACKThranHeart;
class SinaApiInfo;
class SinaApiRet;
class OGRoomInfo;
class OGThranMatchInfo;
class ThranRoomInfo;
class ThranJSSInfo;
class OGBulletinInfo;
class REQQuickConn;
class ACKQuickConn;

// ===================================================================

class REQThranReg : public ::google::protobuf::MessageLite {
 public:
  REQThranReg();
  virtual ~REQThranReg();
  
  REQThranReg(const REQThranReg& from);
  
  inline REQThranReg& operator=(const REQThranReg& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const REQThranReg& default_instance();
  
  void Swap(REQThranReg* other);
  
  // implements Message ----------------------------------------------
  
  REQThranReg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const REQThranReg& from);
  void MergeFrom(const REQThranReg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string UserName = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required string Pwd = 2;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 2;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  
  // optional int32 VerifyId = 3;
  inline bool has_verifyid() const;
  inline void clear_verifyid();
  static const int kVerifyIdFieldNumber = 3;
  inline ::google::protobuf::int32 verifyid() const;
  inline void set_verifyid(::google::protobuf::int32 value);
  
  // optional string VerifyStr = 4;
  inline bool has_verifystr() const;
  inline void clear_verifystr();
  static const int kVerifyStrFieldNumber = 4;
  inline const ::std::string& verifystr() const;
  inline void set_verifystr(const ::std::string& value);
  inline void set_verifystr(const char* value);
  inline void set_verifystr(const char* value, size_t size);
  inline ::std::string* mutable_verifystr();
  inline ::std::string* release_verifystr();
  
  // required string SecureID = 5;
  inline bool has_secureid() const;
  inline void clear_secureid();
  static const int kSecureIDFieldNumber = 5;
  inline const ::std::string& secureid() const;
  inline void set_secureid(const ::std::string& value);
  inline void set_secureid(const char* value);
  inline void set_secureid(const char* value, size_t size);
  inline ::std::string* mutable_secureid();
  inline ::std::string* release_secureid();
  
  // required int32 ComeFromID = 6;
  inline bool has_comefromid() const;
  inline void clear_comefromid();
  static const int kComeFromIDFieldNumber = 6;
  inline ::google::protobuf::int32 comefromid() const;
  inline void set_comefromid(::google::protobuf::int32 value);
  
  // required string ChannelID = 7;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIDFieldNumber = 7;
  inline const ::std::string& channelid() const;
  inline void set_channelid(const ::std::string& value);
  inline void set_channelid(const char* value);
  inline void set_channelid(const char* value, size_t size);
  inline ::std::string* mutable_channelid();
  inline ::std::string* release_channelid();
  
  // required int32 GameId = 8;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 8;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required string token = 9;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 9;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // optional bytes UserNameApl = 10;
  inline bool has_usernameapl() const;
  inline void clear_usernameapl();
  static const int kUserNameAplFieldNumber = 10;
  inline const ::std::string& usernameapl() const;
  inline void set_usernameapl(const ::std::string& value);
  inline void set_usernameapl(const char* value);
  inline void set_usernameapl(const void* value, size_t size);
  inline ::std::string* mutable_usernameapl();
  inline ::std::string* release_usernameapl();
  
  // optional int32 RoomAdapte = 11 [default = 0];
  inline bool has_roomadapte() const;
  inline void clear_roomadapte();
  static const int kRoomAdapteFieldNumber = 11;
  inline ::google::protobuf::int32 roomadapte() const;
  inline void set_roomadapte(::google::protobuf::int32 value);
  
  // optional int32 Sex = 12 [default = 0];
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 12;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:REQThranReg)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_pwd();
  inline void clear_has_pwd();
  inline void set_has_verifyid();
  inline void clear_has_verifyid();
  inline void set_has_verifystr();
  inline void clear_has_verifystr();
  inline void set_has_secureid();
  inline void clear_has_secureid();
  inline void set_has_comefromid();
  inline void clear_has_comefromid();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_usernameapl();
  inline void clear_has_usernameapl();
  inline void set_has_roomadapte();
  inline void clear_has_roomadapte();
  inline void set_has_sex();
  inline void clear_has_sex();
  
  ::std::string* username_;
  ::std::string* pwd_;
  ::std::string* verifystr_;
  ::google::protobuf::int32 verifyid_;
  ::google::protobuf::int32 comefromid_;
  ::std::string* secureid_;
  ::std::string* channelid_;
  ::std::string* token_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 roomadapte_;
  ::std::string* usernameapl_;
  ::google::protobuf::int32 sex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static REQThranReg* default_instance_;
};
// -------------------------------------------------------------------

class ACKThranReg : public ::google::protobuf::MessageLite {
 public:
  ACKThranReg();
  virtual ~ACKThranReg();
  
  ACKThranReg(const ACKThranReg& from);
  
  inline ACKThranReg& operator=(const ACKThranReg& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ACKThranReg& default_instance();
  
  void Swap(ACKThranReg* other);
  
  // implements Message ----------------------------------------------
  
  ACKThranReg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ACKThranReg& from);
  void MergeFrom(const ACKThranReg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 AckResult = 1;
  inline bool has_ackresult() const;
  inline void clear_ackresult();
  static const int kAckResultFieldNumber = 1;
  inline ::google::protobuf::int32 ackresult() const;
  inline void set_ackresult(::google::protobuf::int32 value);
  
  // optional string ErrorStr = 2;
  inline bool has_errorstr() const;
  inline void clear_errorstr();
  static const int kErrorStrFieldNumber = 2;
  inline const ::std::string& errorstr() const;
  inline void set_errorstr(const ::std::string& value);
  inline void set_errorstr(const char* value);
  inline void set_errorstr(const char* value, size_t size);
  inline ::std::string* mutable_errorstr();
  inline ::std::string* release_errorstr();
  
  // required bytes cert = 3;
  inline bool has_cert() const;
  inline void clear_cert();
  static const int kCertFieldNumber = 3;
  inline const ::std::string& cert() const;
  inline void set_cert(const ::std::string& value);
  inline void set_cert(const char* value);
  inline void set_cert(const void* value, size_t size);
  inline ::std::string* mutable_cert();
  inline ::std::string* release_cert();
  
  // required string RoleName = 4;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRoleNameFieldNumber = 4;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  
  // repeated .OGRoomInfo RoomList = 5;
  inline int roomlist_size() const;
  inline void clear_roomlist();
  static const int kRoomListFieldNumber = 5;
  inline const ::OGRoomInfo& roomlist(int index) const;
  inline ::OGRoomInfo* mutable_roomlist(int index);
  inline ::OGRoomInfo* add_roomlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
      roomlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
      mutable_roomlist();
  
  // required int32 LoginId = 6;
  inline bool has_loginid() const;
  inline void clear_loginid();
  static const int kLoginIdFieldNumber = 6;
  inline ::google::protobuf::int32 loginid() const;
  inline void set_loginid(::google::protobuf::int32 value);
  
  // repeated .OGRoomInfo MatchRoomList = 7;
  inline int matchroomlist_size() const;
  inline void clear_matchroomlist();
  static const int kMatchRoomListFieldNumber = 7;
  inline const ::OGRoomInfo& matchroomlist(int index) const;
  inline ::OGRoomInfo* mutable_matchroomlist(int index);
  inline ::OGRoomInfo* add_matchroomlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
      matchroomlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
      mutable_matchroomlist();
  
  // optional bytes CertNoRole = 8;
  inline bool has_certnorole() const;
  inline void clear_certnorole();
  static const int kCertNoRoleFieldNumber = 8;
  inline const ::std::string& certnorole() const;
  inline void set_certnorole(const ::std::string& value);
  inline void set_certnorole(const char* value);
  inline void set_certnorole(const void* value, size_t size);
  inline ::std::string* mutable_certnorole();
  inline ::std::string* release_certnorole();
  
  // @@protoc_insertion_point(class_scope:ACKThranReg)
 private:
  inline void set_has_ackresult();
  inline void clear_has_ackresult();
  inline void set_has_errorstr();
  inline void clear_has_errorstr();
  inline void set_has_cert();
  inline void clear_has_cert();
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_loginid();
  inline void clear_has_loginid();
  inline void set_has_certnorole();
  inline void clear_has_certnorole();
  
  ::std::string* errorstr_;
  ::std::string* cert_;
  ::google::protobuf::int32 ackresult_;
  ::google::protobuf::int32 loginid_;
  ::std::string* rolename_;
  ::google::protobuf::RepeatedPtrField< ::OGRoomInfo > roomlist_;
  ::google::protobuf::RepeatedPtrField< ::OGRoomInfo > matchroomlist_;
  ::std::string* certnorole_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static ACKThranReg* default_instance_;
};
// -------------------------------------------------------------------

class REQThranConn : public ::google::protobuf::MessageLite {
 public:
  REQThranConn();
  virtual ~REQThranConn();
  
  REQThranConn(const REQThranConn& from);
  
  inline REQThranConn& operator=(const REQThranConn& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const REQThranConn& default_instance();
  
  void Swap(REQThranConn* other);
  
  // implements Message ----------------------------------------------
  
  REQThranConn* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const REQThranConn& from);
  void MergeFrom(const REQThranConn& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string UserName = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required string NickName = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  
  // required string Pwd = 3;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 3;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  
  // optional int32 Sex = 4;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 4;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);
  
  // required string SecureID = 5;
  inline bool has_secureid() const;
  inline void clear_secureid();
  static const int kSecureIDFieldNumber = 5;
  inline const ::std::string& secureid() const;
  inline void set_secureid(const ::std::string& value);
  inline void set_secureid(const char* value);
  inline void set_secureid(const char* value, size_t size);
  inline ::std::string* mutable_secureid();
  inline ::std::string* release_secureid();
  
  // required int32 ComeFromID = 6;
  inline bool has_comefromid() const;
  inline void clear_comefromid();
  static const int kComeFromIDFieldNumber = 6;
  inline ::google::protobuf::int32 comefromid() const;
  inline void set_comefromid(::google::protobuf::int32 value);
  
  // required string ChannelID = 7;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIDFieldNumber = 7;
  inline const ::std::string& channelid() const;
  inline void set_channelid(const ::std::string& value);
  inline void set_channelid(const char* value);
  inline void set_channelid(const char* value, size_t size);
  inline ::std::string* mutable_channelid();
  inline ::std::string* release_channelid();
  
  // required int32 GameId = 8;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 8;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required string token = 9;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 9;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // optional bytes UserNameApl = 10;
  inline bool has_usernameapl() const;
  inline void clear_usernameapl();
  static const int kUserNameAplFieldNumber = 10;
  inline const ::std::string& usernameapl() const;
  inline void set_usernameapl(const ::std::string& value);
  inline void set_usernameapl(const char* value);
  inline void set_usernameapl(const void* value, size_t size);
  inline ::std::string* mutable_usernameapl();
  inline ::std::string* release_usernameapl();
  
  // optional int32 VerifyId = 11;
  inline bool has_verifyid() const;
  inline void clear_verifyid();
  static const int kVerifyIdFieldNumber = 11;
  inline ::google::protobuf::int32 verifyid() const;
  inline void set_verifyid(::google::protobuf::int32 value);
  
  // optional string Ticket = 12;
  inline bool has_ticket() const;
  inline void clear_ticket();
  static const int kTicketFieldNumber = 12;
  inline const ::std::string& ticket() const;
  inline void set_ticket(const ::std::string& value);
  inline void set_ticket(const char* value);
  inline void set_ticket(const char* value, size_t size);
  inline ::std::string* mutable_ticket();
  inline ::std::string* release_ticket();
  
  // optional int32 RoomAdapte = 13 [default = 0];
  inline bool has_roomadapte() const;
  inline void clear_roomadapte();
  static const int kRoomAdapteFieldNumber = 13;
  inline ::google::protobuf::int32 roomadapte() const;
  inline void set_roomadapte(::google::protobuf::int32 value);
  
  // optional int32 LoginType = 14 [default = 0];
  inline bool has_logintype() const;
  inline void clear_logintype();
  static const int kLoginTypeFieldNumber = 14;
  inline ::google::protobuf::int32 logintype() const;
  inline void set_logintype(::google::protobuf::int32 value);
  
  // optional int32 GroupID = 15;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIDFieldNumber = 15;
  inline ::google::protobuf::int32 groupid() const;
  inline void set_groupid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:REQThranConn)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_pwd();
  inline void clear_has_pwd();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_secureid();
  inline void clear_has_secureid();
  inline void set_has_comefromid();
  inline void clear_has_comefromid();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_usernameapl();
  inline void clear_has_usernameapl();
  inline void set_has_verifyid();
  inline void clear_has_verifyid();
  inline void set_has_ticket();
  inline void clear_has_ticket();
  inline void set_has_roomadapte();
  inline void clear_has_roomadapte();
  inline void set_has_logintype();
  inline void clear_has_logintype();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  
  ::std::string* username_;
  ::std::string* nickname_;
  ::std::string* pwd_;
  ::std::string* secureid_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 comefromid_;
  ::std::string* channelid_;
  ::std::string* token_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 verifyid_;
  ::std::string* usernameapl_;
  ::std::string* ticket_;
  ::google::protobuf::int32 roomadapte_;
  ::google::protobuf::int32 logintype_;
  ::google::protobuf::int32 groupid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static REQThranConn* default_instance_;
};
// -------------------------------------------------------------------

class ACKThranConn : public ::google::protobuf::MessageLite {
 public:
  ACKThranConn();
  virtual ~ACKThranConn();
  
  ACKThranConn(const ACKThranConn& from);
  
  inline ACKThranConn& operator=(const ACKThranConn& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ACKThranConn& default_instance();
  
  void Swap(ACKThranConn* other);
  
  // implements Message ----------------------------------------------
  
  ACKThranConn* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ACKThranConn& from);
  void MergeFrom(const ACKThranConn& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 AckResult = 1;
  inline bool has_ackresult() const;
  inline void clear_ackresult();
  static const int kAckResultFieldNumber = 1;
  inline ::google::protobuf::int32 ackresult() const;
  inline void set_ackresult(::google::protobuf::int32 value);
  
  // required bytes cert = 2;
  inline bool has_cert() const;
  inline void clear_cert();
  static const int kCertFieldNumber = 2;
  inline const ::std::string& cert() const;
  inline void set_cert(const ::std::string& value);
  inline void set_cert(const char* value);
  inline void set_cert(const void* value, size_t size);
  inline ::std::string* mutable_cert();
  inline ::std::string* release_cert();
  
  // required string UserName = 3;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 3;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required string RoleName = 4;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRoleNameFieldNumber = 4;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  
  // required string PassWord = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPassWordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // required int32 YuanBaoCnt = 6;
  inline bool has_yuanbaocnt() const;
  inline void clear_yuanbaocnt();
  static const int kYuanBaoCntFieldNumber = 6;
  inline ::google::protobuf::int32 yuanbaocnt() const;
  inline void set_yuanbaocnt(::google::protobuf::int32 value);
  
  // required int64 CoinCnt = 7;
  inline bool has_coincnt() const;
  inline void clear_coincnt();
  static const int kCoinCntFieldNumber = 7;
  inline ::google::protobuf::int64 coincnt() const;
  inline void set_coincnt(::google::protobuf::int64 value);
  
  // repeated .OGRoomInfo RoomList = 8;
  inline int roomlist_size() const;
  inline void clear_roomlist();
  static const int kRoomListFieldNumber = 8;
  inline const ::OGRoomInfo& roomlist(int index) const;
  inline ::OGRoomInfo* mutable_roomlist(int index);
  inline ::OGRoomInfo* add_roomlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
      roomlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
      mutable_roomlist();
  
  // required int32 LoginId = 9;
  inline bool has_loginid() const;
  inline void clear_loginid();
  static const int kLoginIdFieldNumber = 9;
  inline ::google::protobuf::int32 loginid() const;
  inline void set_loginid(::google::protobuf::int32 value);
  
  // repeated .OGRoomInfo MatchRoomList = 10;
  inline int matchroomlist_size() const;
  inline void clear_matchroomlist();
  static const int kMatchRoomListFieldNumber = 10;
  inline const ::OGRoomInfo& matchroomlist(int index) const;
  inline ::OGRoomInfo* mutable_matchroomlist(int index);
  inline ::OGRoomInfo* add_matchroomlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
      matchroomlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
      mutable_matchroomlist();
  
  // optional bytes CertNoRole = 11;
  inline bool has_certnorole() const;
  inline void clear_certnorole();
  static const int kCertNoRoleFieldNumber = 11;
  inline const ::std::string& certnorole() const;
  inline void set_certnorole(const ::std::string& value);
  inline void set_certnorole(const char* value);
  inline void set_certnorole(const void* value, size_t size);
  inline ::std::string* mutable_certnorole();
  inline ::std::string* release_certnorole();
  
  // repeated .ThranRoomInfo ThranRoomItems = 12;
  inline int thranroomitems_size() const;
  inline void clear_thranroomitems();
  static const int kThranRoomItemsFieldNumber = 12;
  inline const ::ThranRoomInfo& thranroomitems(int index) const;
  inline ::ThranRoomInfo* mutable_thranroomitems(int index);
  inline ::ThranRoomInfo* add_thranroomitems();
  inline const ::google::protobuf::RepeatedPtrField< ::ThranRoomInfo >&
      thranroomitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::ThranRoomInfo >*
      mutable_thranroomitems();
  
  // @@protoc_insertion_point(class_scope:ACKThranConn)
 private:
  inline void set_has_ackresult();
  inline void clear_has_ackresult();
  inline void set_has_cert();
  inline void clear_has_cert();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_yuanbaocnt();
  inline void clear_has_yuanbaocnt();
  inline void set_has_coincnt();
  inline void clear_has_coincnt();
  inline void set_has_loginid();
  inline void clear_has_loginid();
  inline void set_has_certnorole();
  inline void clear_has_certnorole();
  
  ::std::string* cert_;
  ::std::string* username_;
  ::google::protobuf::int32 ackresult_;
  ::google::protobuf::int32 yuanbaocnt_;
  ::std::string* rolename_;
  ::std::string* password_;
  ::google::protobuf::int64 coincnt_;
  ::google::protobuf::RepeatedPtrField< ::OGRoomInfo > roomlist_;
  ::google::protobuf::RepeatedPtrField< ::OGRoomInfo > matchroomlist_;
  ::std::string* certnorole_;
  ::google::protobuf::RepeatedPtrField< ::ThranRoomInfo > thranroomitems_;
  ::google::protobuf::int32 loginid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static ACKThranConn* default_instance_;
};
// -------------------------------------------------------------------

class REQThranShortCert : public ::google::protobuf::MessageLite {
 public:
  REQThranShortCert();
  virtual ~REQThranShortCert();
  
  REQThranShortCert(const REQThranShortCert& from);
  
  inline REQThranShortCert& operator=(const REQThranShortCert& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const REQThranShortCert& default_instance();
  
  void Swap(REQThranShortCert* other);
  
  // implements Message ----------------------------------------------
  
  REQThranShortCert* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const REQThranShortCert& from);
  void MergeFrom(const REQThranShortCert& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string UserName = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional string NickName = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  
  // required string Pwd = 3;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 3;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  
  // optional int32 Sex = 4;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 4;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);
  
  // required string SecureID = 5;
  inline bool has_secureid() const;
  inline void clear_secureid();
  static const int kSecureIDFieldNumber = 5;
  inline const ::std::string& secureid() const;
  inline void set_secureid(const ::std::string& value);
  inline void set_secureid(const char* value);
  inline void set_secureid(const char* value, size_t size);
  inline ::std::string* mutable_secureid();
  inline ::std::string* release_secureid();
  
  // required int32 ComeFromID = 6;
  inline bool has_comefromid() const;
  inline void clear_comefromid();
  static const int kComeFromIDFieldNumber = 6;
  inline ::google::protobuf::int32 comefromid() const;
  inline void set_comefromid(::google::protobuf::int32 value);
  
  // required string ChannelID = 7;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIDFieldNumber = 7;
  inline const ::std::string& channelid() const;
  inline void set_channelid(const ::std::string& value);
  inline void set_channelid(const char* value);
  inline void set_channelid(const char* value, size_t size);
  inline ::std::string* mutable_channelid();
  inline ::std::string* release_channelid();
  
  // required int32 GameId = 8;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 8;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required string token = 9;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 9;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // optional bytes UserNameApl = 10;
  inline bool has_usernameapl() const;
  inline void clear_usernameapl();
  static const int kUserNameAplFieldNumber = 10;
  inline const ::std::string& usernameapl() const;
  inline void set_usernameapl(const ::std::string& value);
  inline void set_usernameapl(const char* value);
  inline void set_usernameapl(const void* value, size_t size);
  inline ::std::string* mutable_usernameapl();
  inline ::std::string* release_usernameapl();
  
  // optional int32 VerifyId = 11;
  inline bool has_verifyid() const;
  inline void clear_verifyid();
  static const int kVerifyIdFieldNumber = 11;
  inline ::google::protobuf::int32 verifyid() const;
  inline void set_verifyid(::google::protobuf::int32 value);
  
  // optional string Ticket = 12;
  inline bool has_ticket() const;
  inline void clear_ticket();
  static const int kTicketFieldNumber = 12;
  inline const ::std::string& ticket() const;
  inline void set_ticket(const ::std::string& value);
  inline void set_ticket(const char* value);
  inline void set_ticket(const char* value, size_t size);
  inline ::std::string* mutable_ticket();
  inline ::std::string* release_ticket();
  
  // optional int32 RoomAdapte = 13 [default = 0];
  inline bool has_roomadapte() const;
  inline void clear_roomadapte();
  static const int kRoomAdapteFieldNumber = 13;
  inline ::google::protobuf::int32 roomadapte() const;
  inline void set_roomadapte(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:REQThranShortCert)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_pwd();
  inline void clear_has_pwd();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_secureid();
  inline void clear_has_secureid();
  inline void set_has_comefromid();
  inline void clear_has_comefromid();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_usernameapl();
  inline void clear_has_usernameapl();
  inline void set_has_verifyid();
  inline void clear_has_verifyid();
  inline void set_has_ticket();
  inline void clear_has_ticket();
  inline void set_has_roomadapte();
  inline void clear_has_roomadapte();
  
  ::std::string* username_;
  ::std::string* nickname_;
  ::std::string* pwd_;
  ::std::string* secureid_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 comefromid_;
  ::std::string* channelid_;
  ::std::string* token_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 verifyid_;
  ::std::string* usernameapl_;
  ::std::string* ticket_;
  ::google::protobuf::int32 roomadapte_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static REQThranShortCert* default_instance_;
};
// -------------------------------------------------------------------

class ACKThranShortCert : public ::google::protobuf::MessageLite {
 public:
  ACKThranShortCert();
  virtual ~ACKThranShortCert();
  
  ACKThranShortCert(const ACKThranShortCert& from);
  
  inline ACKThranShortCert& operator=(const ACKThranShortCert& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ACKThranShortCert& default_instance();
  
  void Swap(ACKThranShortCert* other);
  
  // implements Message ----------------------------------------------
  
  ACKThranShortCert* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ACKThranShortCert& from);
  void MergeFrom(const ACKThranShortCert& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 AckResult = 1;
  inline bool has_ackresult() const;
  inline void clear_ackresult();
  static const int kAckResultFieldNumber = 1;
  inline ::google::protobuf::int32 ackresult() const;
  inline void set_ackresult(::google::protobuf::int32 value);
  
  // required bytes ShortCert = 2;
  inline bool has_shortcert() const;
  inline void clear_shortcert();
  static const int kShortCertFieldNumber = 2;
  inline const ::std::string& shortcert() const;
  inline void set_shortcert(const ::std::string& value);
  inline void set_shortcert(const char* value);
  inline void set_shortcert(const void* value, size_t size);
  inline ::std::string* mutable_shortcert();
  inline ::std::string* release_shortcert();
  
  // optional string UserName = 3;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 3;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // repeated .OGRoomInfo RoomList = 4;
  inline int roomlist_size() const;
  inline void clear_roomlist();
  static const int kRoomListFieldNumber = 4;
  inline const ::OGRoomInfo& roomlist(int index) const;
  inline ::OGRoomInfo* mutable_roomlist(int index);
  inline ::OGRoomInfo* add_roomlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
      roomlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
      mutable_roomlist();
  
  // repeated .OGRoomInfo MatchRoomList = 5;
  inline int matchroomlist_size() const;
  inline void clear_matchroomlist();
  static const int kMatchRoomListFieldNumber = 5;
  inline const ::OGRoomInfo& matchroomlist(int index) const;
  inline ::OGRoomInfo* mutable_matchroomlist(int index);
  inline ::OGRoomInfo* add_matchroomlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
      matchroomlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
      mutable_matchroomlist();
  
  // @@protoc_insertion_point(class_scope:ACKThranShortCert)
 private:
  inline void set_has_ackresult();
  inline void clear_has_ackresult();
  inline void set_has_shortcert();
  inline void clear_has_shortcert();
  inline void set_has_username();
  inline void clear_has_username();
  
  ::std::string* shortcert_;
  ::std::string* username_;
  ::google::protobuf::RepeatedPtrField< ::OGRoomInfo > roomlist_;
  ::google::protobuf::RepeatedPtrField< ::OGRoomInfo > matchroomlist_;
  ::google::protobuf::int32 ackresult_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static ACKThranShortCert* default_instance_;
};
// -------------------------------------------------------------------

class REQThranOpenId : public ::google::protobuf::MessageLite {
 public:
  REQThranOpenId();
  virtual ~REQThranOpenId();
  
  REQThranOpenId(const REQThranOpenId& from);
  
  inline REQThranOpenId& operator=(const REQThranOpenId& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const REQThranOpenId& default_instance();
  
  void Swap(REQThranOpenId* other);
  
  // implements Message ----------------------------------------------
  
  REQThranOpenId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const REQThranOpenId& from);
  void MergeFrom(const REQThranOpenId& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes UserName = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const void* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required string Pwd = 2;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 2;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  
  // required string type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  
  // required string SecureID = 4;
  inline bool has_secureid() const;
  inline void clear_secureid();
  static const int kSecureIDFieldNumber = 4;
  inline const ::std::string& secureid() const;
  inline void set_secureid(const ::std::string& value);
  inline void set_secureid(const char* value);
  inline void set_secureid(const char* value, size_t size);
  inline ::std::string* mutable_secureid();
  inline ::std::string* release_secureid();
  
  // required int32 ComeFromID = 5;
  inline bool has_comefromid() const;
  inline void clear_comefromid();
  static const int kComeFromIDFieldNumber = 5;
  inline ::google::protobuf::int32 comefromid() const;
  inline void set_comefromid(::google::protobuf::int32 value);
  
  // required string ChannelID = 6;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIDFieldNumber = 6;
  inline const ::std::string& channelid() const;
  inline void set_channelid(const ::std::string& value);
  inline void set_channelid(const char* value);
  inline void set_channelid(const char* value, size_t size);
  inline ::std::string* mutable_channelid();
  inline ::std::string* release_channelid();
  
  // required int32 GameId = 7;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 7;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // optional int32 VerifyId = 8;
  inline bool has_verifyid() const;
  inline void clear_verifyid();
  static const int kVerifyIdFieldNumber = 8;
  inline ::google::protobuf::int32 verifyid() const;
  inline void set_verifyid(::google::protobuf::int32 value);
  
  // optional string Ticket = 9;
  inline bool has_ticket() const;
  inline void clear_ticket();
  static const int kTicketFieldNumber = 9;
  inline const ::std::string& ticket() const;
  inline void set_ticket(const ::std::string& value);
  inline void set_ticket(const char* value);
  inline void set_ticket(const char* value, size_t size);
  inline ::std::string* mutable_ticket();
  inline ::std::string* release_ticket();
  
  // required string token = 10;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 10;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // optional string Thirdkey = 11;
  inline bool has_thirdkey() const;
  inline void clear_thirdkey();
  static const int kThirdkeyFieldNumber = 11;
  inline const ::std::string& thirdkey() const;
  inline void set_thirdkey(const ::std::string& value);
  inline void set_thirdkey(const char* value);
  inline void set_thirdkey(const char* value, size_t size);
  inline ::std::string* mutable_thirdkey();
  inline ::std::string* release_thirdkey();
  
  // optional int32 RoomAdapte = 12 [default = 0];
  inline bool has_roomadapte() const;
  inline void clear_roomadapte();
  static const int kRoomAdapteFieldNumber = 12;
  inline ::google::protobuf::int32 roomadapte() const;
  inline void set_roomadapte(::google::protobuf::int32 value);
  
  // optional string ThirdAppId = 13;
  inline bool has_thirdappid() const;
  inline void clear_thirdappid();
  static const int kThirdAppIdFieldNumber = 13;
  inline const ::std::string& thirdappid() const;
  inline void set_thirdappid(const ::std::string& value);
  inline void set_thirdappid(const char* value);
  inline void set_thirdappid(const char* value, size_t size);
  inline ::std::string* mutable_thirdappid();
  inline ::std::string* release_thirdappid();
  
  // @@protoc_insertion_point(class_scope:REQThranOpenId)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_pwd();
  inline void clear_has_pwd();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_secureid();
  inline void clear_has_secureid();
  inline void set_has_comefromid();
  inline void clear_has_comefromid();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_verifyid();
  inline void clear_has_verifyid();
  inline void set_has_ticket();
  inline void clear_has_ticket();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_thirdkey();
  inline void clear_has_thirdkey();
  inline void set_has_roomadapte();
  inline void clear_has_roomadapte();
  inline void set_has_thirdappid();
  inline void clear_has_thirdappid();
  
  ::std::string* username_;
  ::std::string* pwd_;
  ::std::string* type_;
  ::std::string* secureid_;
  ::std::string* channelid_;
  ::google::protobuf::int32 comefromid_;
  ::google::protobuf::int32 gameid_;
  ::std::string* ticket_;
  ::std::string* token_;
  ::google::protobuf::int32 verifyid_;
  ::google::protobuf::int32 roomadapte_;
  ::std::string* thirdkey_;
  ::std::string* thirdappid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static REQThranOpenId* default_instance_;
};
// -------------------------------------------------------------------

class ACKThranOpenId : public ::google::protobuf::MessageLite {
 public:
  ACKThranOpenId();
  virtual ~ACKThranOpenId();
  
  ACKThranOpenId(const ACKThranOpenId& from);
  
  inline ACKThranOpenId& operator=(const ACKThranOpenId& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ACKThranOpenId& default_instance();
  
  void Swap(ACKThranOpenId* other);
  
  // implements Message ----------------------------------------------
  
  ACKThranOpenId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ACKThranOpenId& from);
  void MergeFrom(const ACKThranOpenId& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 AckResult = 1;
  inline bool has_ackresult() const;
  inline void clear_ackresult();
  static const int kAckResultFieldNumber = 1;
  inline ::google::protobuf::int32 ackresult() const;
  inline void set_ackresult(::google::protobuf::int32 value);
  
  // required bytes cert = 2;
  inline bool has_cert() const;
  inline void clear_cert();
  static const int kCertFieldNumber = 2;
  inline const ::std::string& cert() const;
  inline void set_cert(const ::std::string& value);
  inline void set_cert(const char* value);
  inline void set_cert(const void* value, size_t size);
  inline ::std::string* mutable_cert();
  inline ::std::string* release_cert();
  
  // required bytes UserName = 3;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 3;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const void* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required bytes RoleName = 4;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRoleNameFieldNumber = 4;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const void* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  
  // required int32 YuanBaoCnt = 5;
  inline bool has_yuanbaocnt() const;
  inline void clear_yuanbaocnt();
  static const int kYuanBaoCntFieldNumber = 5;
  inline ::google::protobuf::int32 yuanbaocnt() const;
  inline void set_yuanbaocnt(::google::protobuf::int32 value);
  
  // required int64 CoinCnt = 6;
  inline bool has_coincnt() const;
  inline void clear_coincnt();
  static const int kCoinCntFieldNumber = 6;
  inline ::google::protobuf::int64 coincnt() const;
  inline void set_coincnt(::google::protobuf::int64 value);
  
  // repeated .OGRoomInfo RoomList = 7;
  inline int roomlist_size() const;
  inline void clear_roomlist();
  static const int kRoomListFieldNumber = 7;
  inline const ::OGRoomInfo& roomlist(int index) const;
  inline ::OGRoomInfo* mutable_roomlist(int index);
  inline ::OGRoomInfo* add_roomlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
      roomlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
      mutable_roomlist();
  
  // repeated .OGRoomInfo MatchRoomList = 8;
  inline int matchroomlist_size() const;
  inline void clear_matchroomlist();
  static const int kMatchRoomListFieldNumber = 8;
  inline const ::OGRoomInfo& matchroomlist(int index) const;
  inline ::OGRoomInfo* mutable_matchroomlist(int index);
  inline ::OGRoomInfo* add_matchroomlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
      matchroomlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
      mutable_matchroomlist();
  
  // required int32 LoginId = 9;
  inline bool has_loginid() const;
  inline void clear_loginid();
  static const int kLoginIdFieldNumber = 9;
  inline ::google::protobuf::int32 loginid() const;
  inline void set_loginid(::google::protobuf::int32 value);
  
  // optional bytes CertNoRole = 10;
  inline bool has_certnorole() const;
  inline void clear_certnorole();
  static const int kCertNoRoleFieldNumber = 10;
  inline const ::std::string& certnorole() const;
  inline void set_certnorole(const ::std::string& value);
  inline void set_certnorole(const char* value);
  inline void set_certnorole(const void* value, size_t size);
  inline ::std::string* mutable_certnorole();
  inline ::std::string* release_certnorole();
  
  // repeated int32 AchvId = 11;
  inline int achvid_size() const;
  inline void clear_achvid();
  static const int kAchvIdFieldNumber = 11;
  inline ::google::protobuf::int32 achvid(int index) const;
  inline void set_achvid(int index, ::google::protobuf::int32 value);
  inline void add_achvid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      achvid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_achvid();
  
  // @@protoc_insertion_point(class_scope:ACKThranOpenId)
 private:
  inline void set_has_ackresult();
  inline void clear_has_ackresult();
  inline void set_has_cert();
  inline void clear_has_cert();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_yuanbaocnt();
  inline void clear_has_yuanbaocnt();
  inline void set_has_coincnt();
  inline void clear_has_coincnt();
  inline void set_has_loginid();
  inline void clear_has_loginid();
  inline void set_has_certnorole();
  inline void clear_has_certnorole();
  
  ::std::string* cert_;
  ::std::string* username_;
  ::google::protobuf::int32 ackresult_;
  ::google::protobuf::int32 yuanbaocnt_;
  ::std::string* rolename_;
  ::google::protobuf::int64 coincnt_;
  ::google::protobuf::RepeatedPtrField< ::OGRoomInfo > roomlist_;
  ::google::protobuf::RepeatedPtrField< ::OGRoomInfo > matchroomlist_;
  ::std::string* certnorole_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > achvid_;
  ::google::protobuf::int32 loginid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static ACKThranOpenId* default_instance_;
};
// -------------------------------------------------------------------

class REQSinaGame : public ::google::protobuf::MessageLite {
 public:
  REQSinaGame();
  virtual ~REQSinaGame();
  
  REQSinaGame(const REQSinaGame& from);
  
  inline REQSinaGame& operator=(const REQSinaGame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const REQSinaGame& default_instance();
  
  void Swap(REQSinaGame* other);
  
  // implements Message ----------------------------------------------
  
  REQSinaGame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const REQSinaGame& from);
  void MergeFrom(const REQSinaGame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Thirdkey = 1;
  inline bool has_thirdkey() const;
  inline void clear_thirdkey();
  static const int kThirdkeyFieldNumber = 1;
  inline const ::std::string& thirdkey() const;
  inline void set_thirdkey(const ::std::string& value);
  inline void set_thirdkey(const char* value);
  inline void set_thirdkey(const char* value, size_t size);
  inline ::std::string* mutable_thirdkey();
  inline ::std::string* release_thirdkey();
  
  // repeated .SinaApiInfo InfoList = 2;
  inline int infolist_size() const;
  inline void clear_infolist();
  static const int kInfoListFieldNumber = 2;
  inline const ::SinaApiInfo& infolist(int index) const;
  inline ::SinaApiInfo* mutable_infolist(int index);
  inline ::SinaApiInfo* add_infolist();
  inline const ::google::protobuf::RepeatedPtrField< ::SinaApiInfo >&
      infolist() const;
  inline ::google::protobuf::RepeatedPtrField< ::SinaApiInfo >*
      mutable_infolist();
  
  // required string SecureID = 4;
  inline bool has_secureid() const;
  inline void clear_secureid();
  static const int kSecureIDFieldNumber = 4;
  inline const ::std::string& secureid() const;
  inline void set_secureid(const ::std::string& value);
  inline void set_secureid(const char* value);
  inline void set_secureid(const char* value, size_t size);
  inline ::std::string* mutable_secureid();
  inline ::std::string* release_secureid();
  
  // required int32 ComeFromID = 5;
  inline bool has_comefromid() const;
  inline void clear_comefromid();
  static const int kComeFromIDFieldNumber = 5;
  inline ::google::protobuf::int32 comefromid() const;
  inline void set_comefromid(::google::protobuf::int32 value);
  
  // required string ChannelID = 6;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIDFieldNumber = 6;
  inline const ::std::string& channelid() const;
  inline void set_channelid(const ::std::string& value);
  inline void set_channelid(const char* value);
  inline void set_channelid(const char* value, size_t size);
  inline ::std::string* mutable_channelid();
  inline ::std::string* release_channelid();
  
  // required int32 GameId = 7;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 7;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:REQSinaGame)
 private:
  inline void set_has_thirdkey();
  inline void clear_has_thirdkey();
  inline void set_has_secureid();
  inline void clear_has_secureid();
  inline void set_has_comefromid();
  inline void clear_has_comefromid();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  
  ::std::string* thirdkey_;
  ::google::protobuf::RepeatedPtrField< ::SinaApiInfo > infolist_;
  ::std::string* secureid_;
  ::std::string* channelid_;
  ::google::protobuf::int32 comefromid_;
  ::google::protobuf::int32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static REQSinaGame* default_instance_;
};
// -------------------------------------------------------------------

class ACKSinaGame : public ::google::protobuf::MessageLite {
 public:
  ACKSinaGame();
  virtual ~ACKSinaGame();
  
  ACKSinaGame(const ACKSinaGame& from);
  
  inline ACKSinaGame& operator=(const ACKSinaGame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ACKSinaGame& default_instance();
  
  void Swap(ACKSinaGame* other);
  
  // implements Message ----------------------------------------------
  
  ACKSinaGame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ACKSinaGame& from);
  void MergeFrom(const ACKSinaGame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 AckResult = 1;
  inline bool has_ackresult() const;
  inline void clear_ackresult();
  static const int kAckResultFieldNumber = 1;
  inline ::google::protobuf::int32 ackresult() const;
  inline void set_ackresult(::google::protobuf::int32 value);
  
  // repeated .SinaApiRet RetList = 2;
  inline int retlist_size() const;
  inline void clear_retlist();
  static const int kRetListFieldNumber = 2;
  inline const ::SinaApiRet& retlist(int index) const;
  inline ::SinaApiRet* mutable_retlist(int index);
  inline ::SinaApiRet* add_retlist();
  inline const ::google::protobuf::RepeatedPtrField< ::SinaApiRet >&
      retlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::SinaApiRet >*
      mutable_retlist();
  
  // @@protoc_insertion_point(class_scope:ACKSinaGame)
 private:
  inline void set_has_ackresult();
  inline void clear_has_ackresult();
  
  ::google::protobuf::RepeatedPtrField< ::SinaApiRet > retlist_;
  ::google::protobuf::int32 ackresult_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static ACKSinaGame* default_instance_;
};
// -------------------------------------------------------------------

class REQWeiBo : public ::google::protobuf::MessageLite {
 public:
  REQWeiBo();
  virtual ~REQWeiBo();
  
  REQWeiBo(const REQWeiBo& from);
  
  inline REQWeiBo& operator=(const REQWeiBo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const REQWeiBo& default_instance();
  
  void Swap(REQWeiBo* other);
  
  // implements Message ----------------------------------------------
  
  REQWeiBo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const REQWeiBo& from);
  void MergeFrom(const REQWeiBo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes UserName = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const void* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required string Pwd = 2;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 2;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  
  // required string type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  
  // required string SecureID = 4;
  inline bool has_secureid() const;
  inline void clear_secureid();
  static const int kSecureIDFieldNumber = 4;
  inline const ::std::string& secureid() const;
  inline void set_secureid(const ::std::string& value);
  inline void set_secureid(const char* value);
  inline void set_secureid(const char* value, size_t size);
  inline ::std::string* mutable_secureid();
  inline ::std::string* release_secureid();
  
  // required int32 ComeFromID = 5;
  inline bool has_comefromid() const;
  inline void clear_comefromid();
  static const int kComeFromIDFieldNumber = 5;
  inline ::google::protobuf::int32 comefromid() const;
  inline void set_comefromid(::google::protobuf::int32 value);
  
  // required string ChannelID = 6;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIDFieldNumber = 6;
  inline const ::std::string& channelid() const;
  inline void set_channelid(const ::std::string& value);
  inline void set_channelid(const char* value);
  inline void set_channelid(const char* value, size_t size);
  inline ::std::string* mutable_channelid();
  inline ::std::string* release_channelid();
  
  // required int32 GameId = 7;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 7;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required string token = 8;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 8;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // optional bytes wbMsg = 9;
  inline bool has_wbmsg() const;
  inline void clear_wbmsg();
  static const int kWbMsgFieldNumber = 9;
  inline const ::std::string& wbmsg() const;
  inline void set_wbmsg(const ::std::string& value);
  inline void set_wbmsg(const char* value);
  inline void set_wbmsg(const void* value, size_t size);
  inline ::std::string* mutable_wbmsg();
  inline ::std::string* release_wbmsg();
  
  // optional bytes wbPic = 10;
  inline bool has_wbpic() const;
  inline void clear_wbpic();
  static const int kWbPicFieldNumber = 10;
  inline const ::std::string& wbpic() const;
  inline void set_wbpic(const ::std::string& value);
  inline void set_wbpic(const char* value);
  inline void set_wbpic(const void* value, size_t size);
  inline ::std::string* mutable_wbpic();
  inline ::std::string* release_wbpic();
  
  // @@protoc_insertion_point(class_scope:REQWeiBo)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_pwd();
  inline void clear_has_pwd();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_secureid();
  inline void clear_has_secureid();
  inline void set_has_comefromid();
  inline void clear_has_comefromid();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_wbmsg();
  inline void clear_has_wbmsg();
  inline void set_has_wbpic();
  inline void clear_has_wbpic();
  
  ::std::string* username_;
  ::std::string* pwd_;
  ::std::string* type_;
  ::std::string* secureid_;
  ::std::string* channelid_;
  ::google::protobuf::int32 comefromid_;
  ::google::protobuf::int32 gameid_;
  ::std::string* token_;
  ::std::string* wbmsg_;
  ::std::string* wbpic_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static REQWeiBo* default_instance_;
};
// -------------------------------------------------------------------

class ACKWeiBo : public ::google::protobuf::MessageLite {
 public:
  ACKWeiBo();
  virtual ~ACKWeiBo();
  
  ACKWeiBo(const ACKWeiBo& from);
  
  inline ACKWeiBo& operator=(const ACKWeiBo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ACKWeiBo& default_instance();
  
  void Swap(ACKWeiBo* other);
  
  // implements Message ----------------------------------------------
  
  ACKWeiBo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ACKWeiBo& from);
  void MergeFrom(const ACKWeiBo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 AckResult = 1;
  inline bool has_ackresult() const;
  inline void clear_ackresult();
  static const int kAckResultFieldNumber = 1;
  inline ::google::protobuf::int32 ackresult() const;
  inline void set_ackresult(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:ACKWeiBo)
 private:
  inline void set_has_ackresult();
  inline void clear_has_ackresult();
  
  ::google::protobuf::int32 ackresult_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static ACKWeiBo* default_instance_;
};
// -------------------------------------------------------------------

class REQThranExit : public ::google::protobuf::MessageLite {
 public:
  REQThranExit();
  virtual ~REQThranExit();
  
  REQThranExit(const REQThranExit& from);
  
  inline REQThranExit& operator=(const REQThranExit& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const REQThranExit& default_instance();
  
  void Swap(REQThranExit* other);
  
  // implements Message ----------------------------------------------
  
  REQThranExit* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const REQThranExit& from);
  void MergeFrom(const REQThranExit& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 LoginId = 1;
  inline bool has_loginid() const;
  inline void clear_loginid();
  static const int kLoginIdFieldNumber = 1;
  inline ::google::protobuf::int32 loginid() const;
  inline void set_loginid(::google::protobuf::int32 value);
  
  // optional int32 ExitType = 2;
  inline bool has_exittype() const;
  inline void clear_exittype();
  static const int kExitTypeFieldNumber = 2;
  inline ::google::protobuf::int32 exittype() const;
  inline void set_exittype(::google::protobuf::int32 value);
  
  // optional string ExitMsg = 3;
  inline bool has_exitmsg() const;
  inline void clear_exitmsg();
  static const int kExitMsgFieldNumber = 3;
  inline const ::std::string& exitmsg() const;
  inline void set_exitmsg(const ::std::string& value);
  inline void set_exitmsg(const char* value);
  inline void set_exitmsg(const char* value, size_t size);
  inline ::std::string* mutable_exitmsg();
  inline ::std::string* release_exitmsg();
  
  // @@protoc_insertion_point(class_scope:REQThranExit)
 private:
  inline void set_has_loginid();
  inline void clear_has_loginid();
  inline void set_has_exittype();
  inline void clear_has_exittype();
  inline void set_has_exitmsg();
  inline void clear_has_exitmsg();
  
  ::google::protobuf::int32 loginid_;
  ::google::protobuf::int32 exittype_;
  ::std::string* exitmsg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static REQThranExit* default_instance_;
};
// -------------------------------------------------------------------

class REQThranGameVersion : public ::google::protobuf::MessageLite {
 public:
  REQThranGameVersion();
  virtual ~REQThranGameVersion();
  
  REQThranGameVersion(const REQThranGameVersion& from);
  
  inline REQThranGameVersion& operator=(const REQThranGameVersion& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const REQThranGameVersion& default_instance();
  
  void Swap(REQThranGameVersion* other);
  
  // implements Message ----------------------------------------------
  
  REQThranGameVersion* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const REQThranGameVersion& from);
  void MergeFrom(const REQThranGameVersion& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 CurVersion = 1;
  inline bool has_curversion() const;
  inline void clear_curversion();
  static const int kCurVersionFieldNumber = 1;
  inline ::google::protobuf::int32 curversion() const;
  inline void set_curversion(::google::protobuf::int32 value);
  
  // required int32 GameId = 2;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 2;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 ComeFromID = 3;
  inline bool has_comefromid() const;
  inline void clear_comefromid();
  static const int kComeFromIDFieldNumber = 3;
  inline ::google::protobuf::int32 comefromid() const;
  inline void set_comefromid(::google::protobuf::int32 value);
  
  // required string ResolutionID = 4;
  inline bool has_resolutionid() const;
  inline void clear_resolutionid();
  static const int kResolutionIDFieldNumber = 4;
  inline const ::std::string& resolutionid() const;
  inline void set_resolutionid(const ::std::string& value);
  inline void set_resolutionid(const char* value);
  inline void set_resolutionid(const char* value, size_t size);
  inline ::std::string* mutable_resolutionid();
  inline ::std::string* release_resolutionid();
  
  // required string ChannelID = 5;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIDFieldNumber = 5;
  inline const ::std::string& channelid() const;
  inline void set_channelid(const ::std::string& value);
  inline void set_channelid(const char* value);
  inline void set_channelid(const char* value, size_t size);
  inline ::std::string* mutable_channelid();
  inline ::std::string* release_channelid();
  
  // required string LanguageID = 6;
  inline bool has_languageid() const;
  inline void clear_languageid();
  static const int kLanguageIDFieldNumber = 6;
  inline const ::std::string& languageid() const;
  inline void set_languageid(const ::std::string& value);
  inline void set_languageid(const char* value);
  inline void set_languageid(const char* value, size_t size);
  inline ::std::string* mutable_languageid();
  inline ::std::string* release_languageid();
  
  // optional int32 smallVersion = 7;
  inline bool has_smallversion() const;
  inline void clear_smallversion();
  static const int kSmallVersionFieldNumber = 7;
  inline ::google::protobuf::int32 smallversion() const;
  inline void set_smallversion(::google::protobuf::int32 value);
  
  // optional string ClientType = 8;
  inline bool has_clienttype() const;
  inline void clear_clienttype();
  static const int kClientTypeFieldNumber = 8;
  inline const ::std::string& clienttype() const;
  inline void set_clienttype(const ::std::string& value);
  inline void set_clienttype(const char* value);
  inline void set_clienttype(const char* value, size_t size);
  inline ::std::string* mutable_clienttype();
  inline ::std::string* release_clienttype();
  
  // optional string ScreenSize = 9;
  inline bool has_screensize() const;
  inline void clear_screensize();
  static const int kScreenSizeFieldNumber = 9;
  inline const ::std::string& screensize() const;
  inline void set_screensize(const ::std::string& value);
  inline void set_screensize(const char* value);
  inline void set_screensize(const char* value, size_t size);
  inline ::std::string* mutable_screensize();
  inline ::std::string* release_screensize();
  
  // optional int32 RoomAdapte = 10 [default = 0];
  inline bool has_roomadapte() const;
  inline void clear_roomadapte();
  static const int kRoomAdapteFieldNumber = 10;
  inline ::google::protobuf::int32 roomadapte() const;
  inline void set_roomadapte(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:REQThranGameVersion)
 private:
  inline void set_has_curversion();
  inline void clear_has_curversion();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_comefromid();
  inline void clear_has_comefromid();
  inline void set_has_resolutionid();
  inline void clear_has_resolutionid();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_languageid();
  inline void clear_has_languageid();
  inline void set_has_smallversion();
  inline void clear_has_smallversion();
  inline void set_has_clienttype();
  inline void clear_has_clienttype();
  inline void set_has_screensize();
  inline void clear_has_screensize();
  inline void set_has_roomadapte();
  inline void clear_has_roomadapte();
  
  ::google::protobuf::int32 curversion_;
  ::google::protobuf::int32 gameid_;
  ::std::string* resolutionid_;
  ::std::string* channelid_;
  ::google::protobuf::int32 comefromid_;
  ::google::protobuf::int32 smallversion_;
  ::std::string* languageid_;
  ::std::string* clienttype_;
  ::std::string* screensize_;
  ::google::protobuf::int32 roomadapte_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static REQThranGameVersion* default_instance_;
};
// -------------------------------------------------------------------

class ACKThranGameVersion : public ::google::protobuf::MessageLite {
 public:
  ACKThranGameVersion();
  virtual ~ACKThranGameVersion();
  
  ACKThranGameVersion(const ACKThranGameVersion& from);
  
  inline ACKThranGameVersion& operator=(const ACKThranGameVersion& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ACKThranGameVersion& default_instance();
  
  void Swap(ACKThranGameVersion* other);
  
  // implements Message ----------------------------------------------
  
  ACKThranGameVersion* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ACKThranGameVersion& from);
  void MergeFrom(const ACKThranGameVersion& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 AckResult = 1;
  inline bool has_ackresult() const;
  inline void clear_ackresult();
  static const int kAckResultFieldNumber = 1;
  inline ::google::protobuf::int32 ackresult() const;
  inline void set_ackresult(::google::protobuf::int32 value);
  
  // required string PlayEnable = 2;
  inline bool has_playenable() const;
  inline void clear_playenable();
  static const int kPlayEnableFieldNumber = 2;
  inline const ::std::string& playenable() const;
  inline void set_playenable(const ::std::string& value);
  inline void set_playenable(const char* value);
  inline void set_playenable(const char* value, size_t size);
  inline ::std::string* mutable_playenable();
  inline ::std::string* release_playenable();
  
  // required string DownloadUrl = 3;
  inline bool has_downloadurl() const;
  inline void clear_downloadurl();
  static const int kDownloadUrlFieldNumber = 3;
  inline const ::std::string& downloadurl() const;
  inline void set_downloadurl(const ::std::string& value);
  inline void set_downloadurl(const char* value);
  inline void set_downloadurl(const char* value, size_t size);
  inline ::std::string* mutable_downloadurl();
  inline ::std::string* release_downloadurl();
  
  // required string GameServerIp = 4;
  inline bool has_gameserverip() const;
  inline void clear_gameserverip();
  static const int kGameServerIpFieldNumber = 4;
  inline const ::std::string& gameserverip() const;
  inline void set_gameserverip(const ::std::string& value);
  inline void set_gameserverip(const char* value);
  inline void set_gameserverip(const char* value, size_t size);
  inline ::std::string* mutable_gameserverip();
  inline ::std::string* release_gameserverip();
  
  // required string GameServerPort = 5;
  inline bool has_gameserverport() const;
  inline void clear_gameserverport();
  static const int kGameServerPortFieldNumber = 5;
  inline const ::std::string& gameserverport() const;
  inline void set_gameserverport(const ::std::string& value);
  inline void set_gameserverport(const char* value);
  inline void set_gameserverport(const char* value, size_t size);
  inline ::std::string* mutable_gameserverport();
  inline ::std::string* release_gameserverport();
  
  // required string GameRankEnable = 6;
  inline bool has_gamerankenable() const;
  inline void clear_gamerankenable();
  static const int kGameRankEnableFieldNumber = 6;
  inline const ::std::string& gamerankenable() const;
  inline void set_gamerankenable(const ::std::string& value);
  inline void set_gamerankenable(const char* value);
  inline void set_gamerankenable(const char* value, size_t size);
  inline ::std::string* mutable_gamerankenable();
  inline ::std::string* release_gamerankenable();
  
  // required string GameRankDef = 7;
  inline bool has_gamerankdef() const;
  inline void clear_gamerankdef();
  static const int kGameRankDefFieldNumber = 7;
  inline const ::std::string& gamerankdef() const;
  inline void set_gamerankdef(const ::std::string& value);
  inline void set_gamerankdef(const char* value);
  inline void set_gamerankdef(const char* value, size_t size);
  inline ::std::string* mutable_gamerankdef();
  inline ::std::string* release_gamerankdef();
  
  // optional string IfPreserve = 8;
  inline bool has_ifpreserve() const;
  inline void clear_ifpreserve();
  static const int kIfPreserveFieldNumber = 8;
  inline const ::std::string& ifpreserve() const;
  inline void set_ifpreserve(const ::std::string& value);
  inline void set_ifpreserve(const char* value);
  inline void set_ifpreserve(const char* value, size_t size);
  inline ::std::string* mutable_ifpreserve();
  inline ::std::string* release_ifpreserve();
  
  // optional string PreserveMsg = 9;
  inline bool has_preservemsg() const;
  inline void clear_preservemsg();
  static const int kPreserveMsgFieldNumber = 9;
  inline const ::std::string& preservemsg() const;
  inline void set_preservemsg(const ::std::string& value);
  inline void set_preservemsg(const char* value);
  inline void set_preservemsg(const char* value, size_t size);
  inline ::std::string* mutable_preservemsg();
  inline ::std::string* release_preservemsg();
  
  // repeated .OGThranMatchInfo MatchInfoList = 10;
  inline int matchinfolist_size() const;
  inline void clear_matchinfolist();
  static const int kMatchInfoListFieldNumber = 10;
  inline const ::OGThranMatchInfo& matchinfolist(int index) const;
  inline ::OGThranMatchInfo* mutable_matchinfolist(int index);
  inline ::OGThranMatchInfo* add_matchinfolist();
  inline const ::google::protobuf::RepeatedPtrField< ::OGThranMatchInfo >&
      matchinfolist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OGThranMatchInfo >*
      mutable_matchinfolist();
  
  // optional int32 DownloadReasion = 11;
  inline bool has_downloadreasion() const;
  inline void clear_downloadreasion();
  static const int kDownloadReasionFieldNumber = 11;
  inline ::google::protobuf::int32 downloadreasion() const;
  inline void set_downloadreasion(::google::protobuf::int32 value);
  
  // optional int32 GameId = 12;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 12;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // optional int32 gameSort = 13;
  inline bool has_gamesort() const;
  inline void clear_gamesort();
  static const int kGameSortFieldNumber = 13;
  inline ::google::protobuf::int32 gamesort() const;
  inline void set_gamesort(::google::protobuf::int32 value);
  
  // repeated .OGRoomInfo MatchRoomList = 14;
  inline int matchroomlist_size() const;
  inline void clear_matchroomlist();
  static const int kMatchRoomListFieldNumber = 14;
  inline const ::OGRoomInfo& matchroomlist(int index) const;
  inline ::OGRoomInfo* mutable_matchroomlist(int index);
  inline ::OGRoomInfo* add_matchroomlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
      matchroomlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
      mutable_matchroomlist();
  
  // repeated .ThranJSSInfo JssList = 15;
  inline int jsslist_size() const;
  inline void clear_jsslist();
  static const int kJssListFieldNumber = 15;
  inline const ::ThranJSSInfo& jsslist(int index) const;
  inline ::ThranJSSInfo* mutable_jsslist(int index);
  inline ::ThranJSSInfo* add_jsslist();
  inline const ::google::protobuf::RepeatedPtrField< ::ThranJSSInfo >&
      jsslist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ThranJSSInfo >*
      mutable_jsslist();
  
  // optional string IfSearch = 16;
  inline bool has_ifsearch() const;
  inline void clear_ifsearch();
  static const int kIfSearchFieldNumber = 16;
  inline const ::std::string& ifsearch() const;
  inline void set_ifsearch(const ::std::string& value);
  inline void set_ifsearch(const char* value);
  inline void set_ifsearch(const char* value, size_t size);
  inline ::std::string* mutable_ifsearch();
  inline ::std::string* release_ifsearch();
  
  // repeated .OGBulletinInfo BulletinList = 17;
  inline int bulletinlist_size() const;
  inline void clear_bulletinlist();
  static const int kBulletinListFieldNumber = 17;
  inline const ::OGBulletinInfo& bulletinlist(int index) const;
  inline ::OGBulletinInfo* mutable_bulletinlist(int index);
  inline ::OGBulletinInfo* add_bulletinlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OGBulletinInfo >&
      bulletinlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OGBulletinInfo >*
      mutable_bulletinlist();
  
  // @@protoc_insertion_point(class_scope:ACKThranGameVersion)
 private:
  inline void set_has_ackresult();
  inline void clear_has_ackresult();
  inline void set_has_playenable();
  inline void clear_has_playenable();
  inline void set_has_downloadurl();
  inline void clear_has_downloadurl();
  inline void set_has_gameserverip();
  inline void clear_has_gameserverip();
  inline void set_has_gameserverport();
  inline void clear_has_gameserverport();
  inline void set_has_gamerankenable();
  inline void clear_has_gamerankenable();
  inline void set_has_gamerankdef();
  inline void clear_has_gamerankdef();
  inline void set_has_ifpreserve();
  inline void clear_has_ifpreserve();
  inline void set_has_preservemsg();
  inline void clear_has_preservemsg();
  inline void set_has_downloadreasion();
  inline void clear_has_downloadreasion();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gamesort();
  inline void clear_has_gamesort();
  inline void set_has_ifsearch();
  inline void clear_has_ifsearch();
  
  ::std::string* playenable_;
  ::std::string* downloadurl_;
  ::std::string* gameserverip_;
  ::std::string* gameserverport_;
  ::std::string* gamerankenable_;
  ::google::protobuf::int32 ackresult_;
  ::google::protobuf::int32 downloadreasion_;
  ::std::string* gamerankdef_;
  ::std::string* ifpreserve_;
  ::std::string* preservemsg_;
  ::google::protobuf::RepeatedPtrField< ::OGThranMatchInfo > matchinfolist_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gamesort_;
  ::google::protobuf::RepeatedPtrField< ::OGRoomInfo > matchroomlist_;
  ::google::protobuf::RepeatedPtrField< ::ThranJSSInfo > jsslist_;
  ::std::string* ifsearch_;
  ::google::protobuf::RepeatedPtrField< ::OGBulletinInfo > bulletinlist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static ACKThranGameVersion* default_instance_;
};
// -------------------------------------------------------------------

class REQThranNewVerify : public ::google::protobuf::MessageLite {
 public:
  REQThranNewVerify();
  virtual ~REQThranNewVerify();
  
  REQThranNewVerify(const REQThranNewVerify& from);
  
  inline REQThranNewVerify& operator=(const REQThranNewVerify& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const REQThranNewVerify& default_instance();
  
  void Swap(REQThranNewVerify* other);
  
  // implements Message ----------------------------------------------
  
  REQThranNewVerify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const REQThranNewVerify& from);
  void MergeFrom(const REQThranNewVerify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string SecureID = 1;
  inline bool has_secureid() const;
  inline void clear_secureid();
  static const int kSecureIDFieldNumber = 1;
  inline const ::std::string& secureid() const;
  inline void set_secureid(const ::std::string& value);
  inline void set_secureid(const char* value);
  inline void set_secureid(const char* value, size_t size);
  inline ::std::string* mutable_secureid();
  inline ::std::string* release_secureid();
  
  // required int32 ComeFromID = 2;
  inline bool has_comefromid() const;
  inline void clear_comefromid();
  static const int kComeFromIDFieldNumber = 2;
  inline ::google::protobuf::int32 comefromid() const;
  inline void set_comefromid(::google::protobuf::int32 value);
  
  // required string ChannelID = 3;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIDFieldNumber = 3;
  inline const ::std::string& channelid() const;
  inline void set_channelid(const ::std::string& value);
  inline void set_channelid(const char* value);
  inline void set_channelid(const char* value, size_t size);
  inline ::std::string* mutable_channelid();
  inline ::std::string* release_channelid();
  
  // required int32 GameId = 4;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 4;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:REQThranNewVerify)
 private:
  inline void set_has_secureid();
  inline void clear_has_secureid();
  inline void set_has_comefromid();
  inline void clear_has_comefromid();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  
  ::std::string* secureid_;
  ::std::string* channelid_;
  ::google::protobuf::int32 comefromid_;
  ::google::protobuf::int32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static REQThranNewVerify* default_instance_;
};
// -------------------------------------------------------------------

class ACKThranNewVerify : public ::google::protobuf::MessageLite {
 public:
  ACKThranNewVerify();
  virtual ~ACKThranNewVerify();
  
  ACKThranNewVerify(const ACKThranNewVerify& from);
  
  inline ACKThranNewVerify& operator=(const ACKThranNewVerify& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ACKThranNewVerify& default_instance();
  
  void Swap(ACKThranNewVerify* other);
  
  // implements Message ----------------------------------------------
  
  ACKThranNewVerify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ACKThranNewVerify& from);
  void MergeFrom(const ACKThranNewVerify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 AckResult = 1;
  inline bool has_ackresult() const;
  inline void clear_ackresult();
  static const int kAckResultFieldNumber = 1;
  inline ::google::protobuf::int32 ackresult() const;
  inline void set_ackresult(::google::protobuf::int32 value);
  
  // optional string ErrorStr = 2;
  inline bool has_errorstr() const;
  inline void clear_errorstr();
  static const int kErrorStrFieldNumber = 2;
  inline const ::std::string& errorstr() const;
  inline void set_errorstr(const ::std::string& value);
  inline void set_errorstr(const char* value);
  inline void set_errorstr(const char* value, size_t size);
  inline ::std::string* mutable_errorstr();
  inline ::std::string* release_errorstr();
  
  // optional bytes Verify = 3;
  inline bool has_verify() const;
  inline void clear_verify();
  static const int kVerifyFieldNumber = 3;
  inline const ::std::string& verify() const;
  inline void set_verify(const ::std::string& value);
  inline void set_verify(const char* value);
  inline void set_verify(const void* value, size_t size);
  inline ::std::string* mutable_verify();
  inline ::std::string* release_verify();
  
  // optional int32 VerifyId = 4;
  inline bool has_verifyid() const;
  inline void clear_verifyid();
  static const int kVerifyIdFieldNumber = 4;
  inline ::google::protobuf::int32 verifyid() const;
  inline void set_verifyid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:ACKThranNewVerify)
 private:
  inline void set_has_ackresult();
  inline void clear_has_ackresult();
  inline void set_has_errorstr();
  inline void clear_has_errorstr();
  inline void set_has_verify();
  inline void clear_has_verify();
  inline void set_has_verifyid();
  inline void clear_has_verifyid();
  
  ::std::string* errorstr_;
  ::google::protobuf::int32 ackresult_;
  ::google::protobuf::int32 verifyid_;
  ::std::string* verify_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static ACKThranNewVerify* default_instance_;
};
// -------------------------------------------------------------------

class REQThranFindPwd : public ::google::protobuf::MessageLite {
 public:
  REQThranFindPwd();
  virtual ~REQThranFindPwd();
  
  REQThranFindPwd(const REQThranFindPwd& from);
  
  inline REQThranFindPwd& operator=(const REQThranFindPwd& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const REQThranFindPwd& default_instance();
  
  void Swap(REQThranFindPwd* other);
  
  // implements Message ----------------------------------------------
  
  REQThranFindPwd* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const REQThranFindPwd& from);
  void MergeFrom(const REQThranFindPwd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Email = 1;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 1;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  
  // required string NewPwd = 2;
  inline bool has_newpwd() const;
  inline void clear_newpwd();
  static const int kNewPwdFieldNumber = 2;
  inline const ::std::string& newpwd() const;
  inline void set_newpwd(const ::std::string& value);
  inline void set_newpwd(const char* value);
  inline void set_newpwd(const char* value, size_t size);
  inline ::std::string* mutable_newpwd();
  inline ::std::string* release_newpwd();
  
  // @@protoc_insertion_point(class_scope:REQThranFindPwd)
 private:
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_newpwd();
  inline void clear_has_newpwd();
  
  ::std::string* email_;
  ::std::string* newpwd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static REQThranFindPwd* default_instance_;
};
// -------------------------------------------------------------------

class ACKThranFindPwd : public ::google::protobuf::MessageLite {
 public:
  ACKThranFindPwd();
  virtual ~ACKThranFindPwd();
  
  ACKThranFindPwd(const ACKThranFindPwd& from);
  
  inline ACKThranFindPwd& operator=(const ACKThranFindPwd& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ACKThranFindPwd& default_instance();
  
  void Swap(ACKThranFindPwd* other);
  
  // implements Message ----------------------------------------------
  
  ACKThranFindPwd* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ACKThranFindPwd& from);
  void MergeFrom(const ACKThranFindPwd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 AckResult = 1;
  inline bool has_ackresult() const;
  inline void clear_ackresult();
  static const int kAckResultFieldNumber = 1;
  inline ::google::protobuf::int32 ackresult() const;
  inline void set_ackresult(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:ACKThranFindPwd)
 private:
  inline void set_has_ackresult();
  inline void clear_has_ackresult();
  
  ::google::protobuf::int32 ackresult_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static ACKThranFindPwd* default_instance_;
};
// -------------------------------------------------------------------

class ACKThranHeart : public ::google::protobuf::MessageLite {
 public:
  ACKThranHeart();
  virtual ~ACKThranHeart();
  
  ACKThranHeart(const ACKThranHeart& from);
  
  inline ACKThranHeart& operator=(const ACKThranHeart& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ACKThranHeart& default_instance();
  
  void Swap(ACKThranHeart* other);
  
  // implements Message ----------------------------------------------
  
  ACKThranHeart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ACKThranHeart& from);
  void MergeFrom(const ACKThranHeart& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ServTime = 1;
  inline bool has_servtime() const;
  inline void clear_servtime();
  static const int kServTimeFieldNumber = 1;
  inline const ::std::string& servtime() const;
  inline void set_servtime(const ::std::string& value);
  inline void set_servtime(const char* value);
  inline void set_servtime(const char* value, size_t size);
  inline ::std::string* mutable_servtime();
  inline ::std::string* release_servtime();
  
  // @@protoc_insertion_point(class_scope:ACKThranHeart)
 private:
  inline void set_has_servtime();
  inline void clear_has_servtime();
  
  ::std::string* servtime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static ACKThranHeart* default_instance_;
};
// -------------------------------------------------------------------

class SinaApiInfo : public ::google::protobuf::MessageLite {
 public:
  SinaApiInfo();
  virtual ~SinaApiInfo();
  
  SinaApiInfo(const SinaApiInfo& from);
  
  inline SinaApiInfo& operator=(const SinaApiInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SinaApiInfo& default_instance();
  
  void Swap(SinaApiInfo* other);
  
  // implements Message ----------------------------------------------
  
  SinaApiInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SinaApiInfo& from);
  void MergeFrom(const SinaApiInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 ApiType = 1;
  inline bool has_apitype() const;
  inline void clear_apitype();
  static const int kApiTypeFieldNumber = 1;
  inline ::google::protobuf::int32 apitype() const;
  inline void set_apitype(::google::protobuf::int32 value);
  
  // required string RetValue = 2;
  inline bool has_retvalue() const;
  inline void clear_retvalue();
  static const int kRetValueFieldNumber = 2;
  inline const ::std::string& retvalue() const;
  inline void set_retvalue(const ::std::string& value);
  inline void set_retvalue(const char* value);
  inline void set_retvalue(const char* value, size_t size);
  inline ::std::string* mutable_retvalue();
  inline ::std::string* release_retvalue();
  
  // optional string UserId = 3;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 3;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  
  // @@protoc_insertion_point(class_scope:SinaApiInfo)
 private:
  inline void set_has_apitype();
  inline void clear_has_apitype();
  inline void set_has_retvalue();
  inline void clear_has_retvalue();
  inline void set_has_userid();
  inline void clear_has_userid();
  
  ::std::string* retvalue_;
  ::std::string* userid_;
  ::google::protobuf::int32 apitype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static SinaApiInfo* default_instance_;
};
// -------------------------------------------------------------------

class SinaApiRet : public ::google::protobuf::MessageLite {
 public:
  SinaApiRet();
  virtual ~SinaApiRet();
  
  SinaApiRet(const SinaApiRet& from);
  
  inline SinaApiRet& operator=(const SinaApiRet& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SinaApiRet& default_instance();
  
  void Swap(SinaApiRet* other);
  
  // implements Message ----------------------------------------------
  
  SinaApiRet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SinaApiRet& from);
  void MergeFrom(const SinaApiRet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 RetResult = 1;
  inline bool has_retresult() const;
  inline void clear_retresult();
  static const int kRetResultFieldNumber = 1;
  inline ::google::protobuf::int32 retresult() const;
  inline void set_retresult(::google::protobuf::int32 value);
  
  // required int32 ApiType = 2;
  inline bool has_apitype() const;
  inline void clear_apitype();
  static const int kApiTypeFieldNumber = 2;
  inline ::google::protobuf::int32 apitype() const;
  inline void set_apitype(::google::protobuf::int32 value);
  
  // optional string RetValue = 3;
  inline bool has_retvalue() const;
  inline void clear_retvalue();
  static const int kRetValueFieldNumber = 3;
  inline const ::std::string& retvalue() const;
  inline void set_retvalue(const ::std::string& value);
  inline void set_retvalue(const char* value);
  inline void set_retvalue(const char* value, size_t size);
  inline ::std::string* mutable_retvalue();
  inline ::std::string* release_retvalue();
  
  // @@protoc_insertion_point(class_scope:SinaApiRet)
 private:
  inline void set_has_retresult();
  inline void clear_has_retresult();
  inline void set_has_apitype();
  inline void clear_has_apitype();
  inline void set_has_retvalue();
  inline void clear_has_retvalue();
  
  ::google::protobuf::int32 retresult_;
  ::google::protobuf::int32 apitype_;
  ::std::string* retvalue_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static SinaApiRet* default_instance_;
};
// -------------------------------------------------------------------

class OGRoomInfo : public ::google::protobuf::MessageLite {
 public:
  OGRoomInfo();
  virtual ~OGRoomInfo();
  
  OGRoomInfo(const OGRoomInfo& from);
  
  inline OGRoomInfo& operator=(const OGRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const OGRoomInfo& default_instance();
  
  void Swap(OGRoomInfo* other);
  
  // implements Message ----------------------------------------------
  
  OGRoomInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OGRoomInfo& from);
  void MergeFrom(const OGRoomInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string RoomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  
  // required string RoomRank = 2;
  inline bool has_roomrank() const;
  inline void clear_roomrank();
  static const int kRoomRankFieldNumber = 2;
  inline const ::std::string& roomrank() const;
  inline void set_roomrank(const ::std::string& value);
  inline void set_roomrank(const char* value);
  inline void set_roomrank(const char* value, size_t size);
  inline ::std::string* mutable_roomrank();
  inline ::std::string* release_roomrank();
  
  // required string RoomIp = 3;
  inline bool has_roomip() const;
  inline void clear_roomip();
  static const int kRoomIpFieldNumber = 3;
  inline const ::std::string& roomip() const;
  inline void set_roomip(const ::std::string& value);
  inline void set_roomip(const char* value);
  inline void set_roomip(const char* value, size_t size);
  inline ::std::string* mutable_roomip();
  inline ::std::string* release_roomip();
  
  // required string RoomPort = 4;
  inline bool has_roomport() const;
  inline void clear_roomport();
  static const int kRoomPortFieldNumber = 4;
  inline const ::std::string& roomport() const;
  inline void set_roomport(const ::std::string& value);
  inline void set_roomport(const char* value);
  inline void set_roomport(const char* value, size_t size);
  inline ::std::string* mutable_roomport();
  inline ::std::string* release_roomport();
  
  // required string RoomStatus = 5;
  inline bool has_roomstatus() const;
  inline void clear_roomstatus();
  static const int kRoomStatusFieldNumber = 5;
  inline const ::std::string& roomstatus() const;
  inline void set_roomstatus(const ::std::string& value);
  inline void set_roomstatus(const char* value);
  inline void set_roomstatus(const char* value, size_t size);
  inline ::std::string* mutable_roomstatus();
  inline ::std::string* release_roomstatus();
  
  // required string RoomMinGold = 6;
  inline bool has_roommingold() const;
  inline void clear_roommingold();
  static const int kRoomMinGoldFieldNumber = 6;
  inline const ::std::string& roommingold() const;
  inline void set_roommingold(const ::std::string& value);
  inline void set_roommingold(const char* value);
  inline void set_roommingold(const char* value, size_t size);
  inline ::std::string* mutable_roommingold();
  inline ::std::string* release_roommingold();
  
  // required string RoomMaxGold = 7;
  inline bool has_roommaxgold() const;
  inline void clear_roommaxgold();
  static const int kRoomMaxGoldFieldNumber = 7;
  inline const ::std::string& roommaxgold() const;
  inline void set_roommaxgold(const ::std::string& value);
  inline void set_roommaxgold(const char* value);
  inline void set_roommaxgold(const char* value, size_t size);
  inline ::std::string* mutable_roommaxgold();
  inline ::std::string* release_roommaxgold();
  
  // required string RoomMinPlay = 8;
  inline bool has_roomminplay() const;
  inline void clear_roomminplay();
  static const int kRoomMinPlayFieldNumber = 8;
  inline const ::std::string& roomminplay() const;
  inline void set_roomminplay(const ::std::string& value);
  inline void set_roomminplay(const char* value);
  inline void set_roomminplay(const char* value, size_t size);
  inline ::std::string* mutable_roomminplay();
  inline ::std::string* release_roomminplay();
  
  // optional string RoomType = 9;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 9;
  inline const ::std::string& roomtype() const;
  inline void set_roomtype(const ::std::string& value);
  inline void set_roomtype(const char* value);
  inline void set_roomtype(const char* value, size_t size);
  inline ::std::string* mutable_roomtype();
  inline ::std::string* release_roomtype();
  
  // optional string ServerType = 10;
  inline bool has_servertype() const;
  inline void clear_servertype();
  static const int kServerTypeFieldNumber = 10;
  inline const ::std::string& servertype() const;
  inline void set_servertype(const ::std::string& value);
  inline void set_servertype(const char* value);
  inline void set_servertype(const char* value, size_t size);
  inline ::std::string* mutable_servertype();
  inline ::std::string* release_servertype();
  
  // optional string Description = 11;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 11;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // optional string RoomName = 12;
  inline bool has_roomname() const;
  inline void clear_roomname();
  static const int kRoomNameFieldNumber = 12;
  inline const ::std::string& roomname() const;
  inline void set_roomname(const ::std::string& value);
  inline void set_roomname(const char* value);
  inline void set_roomname(const char* value, size_t size);
  inline ::std::string* mutable_roomname();
  inline ::std::string* release_roomname();
  
  // @@protoc_insertion_point(class_scope:OGRoomInfo)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_roomrank();
  inline void clear_has_roomrank();
  inline void set_has_roomip();
  inline void clear_has_roomip();
  inline void set_has_roomport();
  inline void clear_has_roomport();
  inline void set_has_roomstatus();
  inline void clear_has_roomstatus();
  inline void set_has_roommingold();
  inline void clear_has_roommingold();
  inline void set_has_roommaxgold();
  inline void clear_has_roommaxgold();
  inline void set_has_roomminplay();
  inline void clear_has_roomminplay();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_servertype();
  inline void clear_has_servertype();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_roomname();
  inline void clear_has_roomname();
  
  ::std::string* roomid_;
  ::std::string* roomrank_;
  ::std::string* roomip_;
  ::std::string* roomport_;
  ::std::string* roomstatus_;
  ::std::string* roommingold_;
  ::std::string* roommaxgold_;
  ::std::string* roomminplay_;
  ::std::string* roomtype_;
  ::std::string* servertype_;
  ::std::string* description_;
  ::std::string* roomname_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static OGRoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class OGThranMatchInfo : public ::google::protobuf::MessageLite {
 public:
  OGThranMatchInfo();
  virtual ~OGThranMatchInfo();
  
  OGThranMatchInfo(const OGThranMatchInfo& from);
  
  inline OGThranMatchInfo& operator=(const OGThranMatchInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const OGThranMatchInfo& default_instance();
  
  void Swap(OGThranMatchInfo* other);
  
  // implements Message ----------------------------------------------
  
  OGThranMatchInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OGThranMatchInfo& from);
  void MergeFrom(const OGThranMatchInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 MatchID = 1;
  inline bool has_matchid() const;
  inline void clear_matchid();
  static const int kMatchIDFieldNumber = 1;
  inline ::google::protobuf::int32 matchid() const;
  inline void set_matchid(::google::protobuf::int32 value);
  
  // required string MatchName = 2;
  inline bool has_matchname() const;
  inline void clear_matchname();
  static const int kMatchNameFieldNumber = 2;
  inline const ::std::string& matchname() const;
  inline void set_matchname(const ::std::string& value);
  inline void set_matchname(const char* value);
  inline void set_matchname(const char* value, size_t size);
  inline ::std::string* mutable_matchname();
  inline ::std::string* release_matchname();
  
  // optional string AwardName = 3;
  inline bool has_awardname() const;
  inline void clear_awardname();
  static const int kAwardNameFieldNumber = 3;
  inline const ::std::string& awardname() const;
  inline void set_awardname(const ::std::string& value);
  inline void set_awardname(const char* value);
  inline void set_awardname(const char* value, size_t size);
  inline ::std::string* mutable_awardname();
  inline ::std::string* release_awardname();
  
  // optional int32 AwardSum = 4;
  inline bool has_awardsum() const;
  inline void clear_awardsum();
  static const int kAwardSumFieldNumber = 4;
  inline ::google::protobuf::int32 awardsum() const;
  inline void set_awardsum(::google::protobuf::int32 value);
  
  // optional string MatchTerm = 5;
  inline bool has_matchterm() const;
  inline void clear_matchterm();
  static const int kMatchTermFieldNumber = 5;
  inline const ::std::string& matchterm() const;
  inline void set_matchterm(const ::std::string& value);
  inline void set_matchterm(const char* value);
  inline void set_matchterm(const char* value, size_t size);
  inline ::std::string* mutable_matchterm();
  inline ::std::string* release_matchterm();
  
  // optional int32 HumanLimit = 6;
  inline bool has_humanlimit() const;
  inline void clear_humanlimit();
  static const int kHumanLimitFieldNumber = 6;
  inline ::google::protobuf::int32 humanlimit() const;
  inline void set_humanlimit(::google::protobuf::int32 value);
  
  // optional int32 MatchHumanSum = 7;
  inline bool has_matchhumansum() const;
  inline void clear_matchhumansum();
  static const int kMatchHumanSumFieldNumber = 7;
  inline ::google::protobuf::int32 matchhumansum() const;
  inline void set_matchhumansum(::google::protobuf::int32 value);
  
  // optional int32 MatchType = 8;
  inline bool has_matchtype() const;
  inline void clear_matchtype();
  static const int kMatchTypeFieldNumber = 8;
  inline ::google::protobuf::int32 matchtype() const;
  inline void set_matchtype(::google::protobuf::int32 value);
  
  // optional int32 MatchInterval = 9;
  inline bool has_matchinterval() const;
  inline void clear_matchinterval();
  static const int kMatchIntervalFieldNumber = 9;
  inline ::google::protobuf::int32 matchinterval() const;
  inline void set_matchinterval(::google::protobuf::int32 value);
  
  // optional string MatchPrize = 10;
  inline bool has_matchprize() const;
  inline void clear_matchprize();
  static const int kMatchPrizeFieldNumber = 10;
  inline const ::std::string& matchprize() const;
  inline void set_matchprize(const ::std::string& value);
  inline void set_matchprize(const char* value);
  inline void set_matchprize(const char* value, size_t size);
  inline ::std::string* mutable_matchprize();
  inline ::std::string* release_matchprize();
  
  // optional string MatchProcess = 11;
  inline bool has_matchprocess() const;
  inline void clear_matchprocess();
  static const int kMatchProcessFieldNumber = 11;
  inline const ::std::string& matchprocess() const;
  inline void set_matchprocess(const ::std::string& value);
  inline void set_matchprocess(const char* value);
  inline void set_matchprocess(const char* value, size_t size);
  inline ::std::string* mutable_matchprocess();
  inline ::std::string* release_matchprocess();
  
  // optional string MatchDate = 12;
  inline bool has_matchdate() const;
  inline void clear_matchdate();
  static const int kMatchDateFieldNumber = 12;
  inline const ::std::string& matchdate() const;
  inline void set_matchdate(const ::std::string& value);
  inline void set_matchdate(const char* value);
  inline void set_matchdate(const char* value, size_t size);
  inline ::std::string* mutable_matchdate();
  inline ::std::string* release_matchdate();
  
  // optional string MatchFee = 13;
  inline bool has_matchfee() const;
  inline void clear_matchfee();
  static const int kMatchFeeFieldNumber = 13;
  inline const ::std::string& matchfee() const;
  inline void set_matchfee(const ::std::string& value);
  inline void set_matchfee(const char* value);
  inline void set_matchfee(const char* value, size_t size);
  inline ::std::string* mutable_matchfee();
  inline ::std::string* release_matchfee();
  
  // optional int32 MatchArea = 14;
  inline bool has_matcharea() const;
  inline void clear_matcharea();
  static const int kMatchAreaFieldNumber = 14;
  inline ::google::protobuf::int32 matcharea() const;
  inline void set_matcharea(::google::protobuf::int32 value);
  
  // optional string Description = 15;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 15;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // @@protoc_insertion_point(class_scope:OGThranMatchInfo)
 private:
  inline void set_has_matchid();
  inline void clear_has_matchid();
  inline void set_has_matchname();
  inline void clear_has_matchname();
  inline void set_has_awardname();
  inline void clear_has_awardname();
  inline void set_has_awardsum();
  inline void clear_has_awardsum();
  inline void set_has_matchterm();
  inline void clear_has_matchterm();
  inline void set_has_humanlimit();
  inline void clear_has_humanlimit();
  inline void set_has_matchhumansum();
  inline void clear_has_matchhumansum();
  inline void set_has_matchtype();
  inline void clear_has_matchtype();
  inline void set_has_matchinterval();
  inline void clear_has_matchinterval();
  inline void set_has_matchprize();
  inline void clear_has_matchprize();
  inline void set_has_matchprocess();
  inline void clear_has_matchprocess();
  inline void set_has_matchdate();
  inline void clear_has_matchdate();
  inline void set_has_matchfee();
  inline void clear_has_matchfee();
  inline void set_has_matcharea();
  inline void clear_has_matcharea();
  inline void set_has_description();
  inline void clear_has_description();
  
  ::std::string* matchname_;
  ::google::protobuf::int32 matchid_;
  ::google::protobuf::int32 awardsum_;
  ::std::string* awardname_;
  ::std::string* matchterm_;
  ::google::protobuf::int32 humanlimit_;
  ::google::protobuf::int32 matchhumansum_;
  ::google::protobuf::int32 matchtype_;
  ::google::protobuf::int32 matchinterval_;
  ::std::string* matchprize_;
  ::std::string* matchprocess_;
  ::std::string* matchdate_;
  ::std::string* matchfee_;
  ::std::string* description_;
  ::google::protobuf::int32 matcharea_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static OGThranMatchInfo* default_instance_;
};
// -------------------------------------------------------------------

class ThranRoomInfo : public ::google::protobuf::MessageLite {
 public:
  ThranRoomInfo();
  virtual ~ThranRoomInfo();
  
  ThranRoomInfo(const ThranRoomInfo& from);
  
  inline ThranRoomInfo& operator=(const ThranRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ThranRoomInfo& default_instance();
  
  void Swap(ThranRoomInfo* other);
  
  // implements Message ----------------------------------------------
  
  ThranRoomInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ThranRoomInfo& from);
  void MergeFrom(const ThranRoomInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 GameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // optional int32 GroupID = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIDFieldNumber = 2;
  inline ::google::protobuf::int32 groupid() const;
  inline void set_groupid(::google::protobuf::int32 value);
  
  // optional bytes RoomID = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 3;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const void* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  
  // optional int32 MaxPlayer = 4;
  inline bool has_maxplayer() const;
  inline void clear_maxplayer();
  static const int kMaxPlayerFieldNumber = 4;
  inline ::google::protobuf::int32 maxplayer() const;
  inline void set_maxplayer(::google::protobuf::int32 value);
  
  // optional string RoomIP = 5;
  inline bool has_roomip() const;
  inline void clear_roomip();
  static const int kRoomIPFieldNumber = 5;
  inline const ::std::string& roomip() const;
  inline void set_roomip(const ::std::string& value);
  inline void set_roomip(const char* value);
  inline void set_roomip(const char* value, size_t size);
  inline ::std::string* mutable_roomip();
  inline ::std::string* release_roomip();
  
  // optional int32 RoomPort = 6;
  inline bool has_roomport() const;
  inline void clear_roomport();
  static const int kRoomPortFieldNumber = 6;
  inline ::google::protobuf::int32 roomport() const;
  inline void set_roomport(::google::protobuf::int32 value);
  
  // optional bytes Context = 7;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 7;
  inline const ::std::string& context() const;
  inline void set_context(const ::std::string& value);
  inline void set_context(const char* value);
  inline void set_context(const void* value, size_t size);
  inline ::std::string* mutable_context();
  inline ::std::string* release_context();
  
  // optional int32 CurPlayer = 8;
  inline bool has_curplayer() const;
  inline void clear_curplayer();
  static const int kCurPlayerFieldNumber = 8;
  inline ::google::protobuf::int32 curplayer() const;
  inline void set_curplayer(::google::protobuf::int32 value);
  
  // optional int32 RoomState = 9;
  inline bool has_roomstate() const;
  inline void clear_roomstate();
  static const int kRoomStateFieldNumber = 9;
  inline ::google::protobuf::int32 roomstate() const;
  inline void set_roomstate(::google::protobuf::int32 value);
  
  // optional int32 IsLock = 10 [default = 0];
  inline bool has_islock() const;
  inline void clear_islock();
  static const int kIsLockFieldNumber = 10;
  inline ::google::protobuf::int32 islock() const;
  inline void set_islock(::google::protobuf::int32 value);
  
  // repeated .ThranRoomInfo ThranRoomItems = 11;
  inline int thranroomitems_size() const;
  inline void clear_thranroomitems();
  static const int kThranRoomItemsFieldNumber = 11;
  inline const ::ThranRoomInfo& thranroomitems(int index) const;
  inline ::ThranRoomInfo* mutable_thranroomitems(int index);
  inline ::ThranRoomInfo* add_thranroomitems();
  inline const ::google::protobuf::RepeatedPtrField< ::ThranRoomInfo >&
      thranroomitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::ThranRoomInfo >*
      mutable_thranroomitems();
  
  // @@protoc_insertion_point(class_scope:ThranRoomInfo)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_maxplayer();
  inline void clear_has_maxplayer();
  inline void set_has_roomip();
  inline void clear_has_roomip();
  inline void set_has_roomport();
  inline void clear_has_roomport();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_curplayer();
  inline void clear_has_curplayer();
  inline void set_has_roomstate();
  inline void clear_has_roomstate();
  inline void set_has_islock();
  inline void clear_has_islock();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 groupid_;
  ::std::string* roomid_;
  ::std::string* roomip_;
  ::google::protobuf::int32 maxplayer_;
  ::google::protobuf::int32 roomport_;
  ::std::string* context_;
  ::google::protobuf::int32 curplayer_;
  ::google::protobuf::int32 roomstate_;
  ::google::protobuf::RepeatedPtrField< ::ThranRoomInfo > thranroomitems_;
  ::google::protobuf::int32 islock_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static ThranRoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class ThranJSSInfo : public ::google::protobuf::MessageLite {
 public:
  ThranJSSInfo();
  virtual ~ThranJSSInfo();
  
  ThranJSSInfo(const ThranJSSInfo& from);
  
  inline ThranJSSInfo& operator=(const ThranJSSInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ThranJSSInfo& default_instance();
  
  void Swap(ThranJSSInfo* other);
  
  // implements Message ----------------------------------------------
  
  ThranJSSInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ThranJSSInfo& from);
  void MergeFrom(const ThranJSSInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string RoomIP = 1;
  inline bool has_roomip() const;
  inline void clear_roomip();
  static const int kRoomIPFieldNumber = 1;
  inline const ::std::string& roomip() const;
  inline void set_roomip(const ::std::string& value);
  inline void set_roomip(const char* value);
  inline void set_roomip(const char* value, size_t size);
  inline ::std::string* mutable_roomip();
  inline ::std::string* release_roomip();
  
  // optional string RoomPort = 2;
  inline bool has_roomport() const;
  inline void clear_roomport();
  static const int kRoomPortFieldNumber = 2;
  inline const ::std::string& roomport() const;
  inline void set_roomport(const ::std::string& value);
  inline void set_roomport(const char* value);
  inline void set_roomport(const char* value, size_t size);
  inline ::std::string* mutable_roomport();
  inline ::std::string* release_roomport();
  
  // optional string Remark = 3;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 3;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  
  // @@protoc_insertion_point(class_scope:ThranJSSInfo)
 private:
  inline void set_has_roomip();
  inline void clear_has_roomip();
  inline void set_has_roomport();
  inline void clear_has_roomport();
  inline void set_has_remark();
  inline void clear_has_remark();
  
  ::std::string* roomip_;
  ::std::string* roomport_;
  ::std::string* remark_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static ThranJSSInfo* default_instance_;
};
// -------------------------------------------------------------------

class OGBulletinInfo : public ::google::protobuf::MessageLite {
 public:
  OGBulletinInfo();
  virtual ~OGBulletinInfo();
  
  OGBulletinInfo(const OGBulletinInfo& from);
  
  inline OGBulletinInfo& operator=(const OGBulletinInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const OGBulletinInfo& default_instance();
  
  void Swap(OGBulletinInfo* other);
  
  // implements Message ----------------------------------------------
  
  OGBulletinInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OGBulletinInfo& from);
  void MergeFrom(const OGBulletinInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes Title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const void* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  
  // optional bytes Content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  
  // @@protoc_insertion_point(class_scope:OGBulletinInfo)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_content();
  inline void clear_has_content();
  
  ::std::string* title_;
  ::std::string* content_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static OGBulletinInfo* default_instance_;
};
// -------------------------------------------------------------------

class REQQuickConn : public ::google::protobuf::MessageLite {
 public:
  REQQuickConn();
  virtual ~REQQuickConn();
  
  REQQuickConn(const REQQuickConn& from);
  
  inline REQQuickConn& operator=(const REQQuickConn& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const REQQuickConn& default_instance();
  
  void Swap(REQQuickConn* other);
  
  // implements Message ----------------------------------------------
  
  REQQuickConn* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const REQQuickConn& from);
  void MergeFrom(const REQQuickConn& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes UserName = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const void* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional string Pwd = 2;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 2;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  
  // optional string SecureID = 3;
  inline bool has_secureid() const;
  inline void clear_secureid();
  static const int kSecureIDFieldNumber = 3;
  inline const ::std::string& secureid() const;
  inline void set_secureid(const ::std::string& value);
  inline void set_secureid(const char* value);
  inline void set_secureid(const char* value, size_t size);
  inline ::std::string* mutable_secureid();
  inline ::std::string* release_secureid();
  
  // required int32 ComeFromID = 4;
  inline bool has_comefromid() const;
  inline void clear_comefromid();
  static const int kComeFromIDFieldNumber = 4;
  inline ::google::protobuf::int32 comefromid() const;
  inline void set_comefromid(::google::protobuf::int32 value);
  
  // required string ChannelID = 5;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIDFieldNumber = 5;
  inline const ::std::string& channelid() const;
  inline void set_channelid(const ::std::string& value);
  inline void set_channelid(const char* value);
  inline void set_channelid(const char* value, size_t size);
  inline ::std::string* mutable_channelid();
  inline ::std::string* release_channelid();
  
  // required int32 GameId = 6;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 6;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required string token = 7;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 7;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // optional int32 RoomAdapte = 8 [default = 0];
  inline bool has_roomadapte() const;
  inline void clear_roomadapte();
  static const int kRoomAdapteFieldNumber = 8;
  inline ::google::protobuf::int32 roomadapte() const;
  inline void set_roomadapte(::google::protobuf::int32 value);
  
  // optional int32 LoginType = 9 [default = 0];
  inline bool has_logintype() const;
  inline void clear_logintype();
  static const int kLoginTypeFieldNumber = 9;
  inline ::google::protobuf::int32 logintype() const;
  inline void set_logintype(::google::protobuf::int32 value);
  
  // required int32 CurVersion = 10;
  inline bool has_curversion() const;
  inline void clear_curversion();
  static const int kCurVersionFieldNumber = 10;
  inline ::google::protobuf::int32 curversion() const;
  inline void set_curversion(::google::protobuf::int32 value);
  
  // optional int32 smallVersion = 11;
  inline bool has_smallversion() const;
  inline void clear_smallversion();
  static const int kSmallVersionFieldNumber = 11;
  inline ::google::protobuf::int32 smallversion() const;
  inline void set_smallversion(::google::protobuf::int32 value);
  
  // required string ResolutionID = 12;
  inline bool has_resolutionid() const;
  inline void clear_resolutionid();
  static const int kResolutionIDFieldNumber = 12;
  inline const ::std::string& resolutionid() const;
  inline void set_resolutionid(const ::std::string& value);
  inline void set_resolutionid(const char* value);
  inline void set_resolutionid(const char* value, size_t size);
  inline ::std::string* mutable_resolutionid();
  inline ::std::string* release_resolutionid();
  
  // optional string LanguageID = 13;
  inline bool has_languageid() const;
  inline void clear_languageid();
  static const int kLanguageIDFieldNumber = 13;
  inline const ::std::string& languageid() const;
  inline void set_languageid(const ::std::string& value);
  inline void set_languageid(const char* value);
  inline void set_languageid(const char* value, size_t size);
  inline ::std::string* mutable_languageid();
  inline ::std::string* release_languageid();
  
  // optional string ScreenSize = 14;
  inline bool has_screensize() const;
  inline void clear_screensize();
  static const int kScreenSizeFieldNumber = 14;
  inline const ::std::string& screensize() const;
  inline void set_screensize(const ::std::string& value);
  inline void set_screensize(const char* value);
  inline void set_screensize(const char* value, size_t size);
  inline ::std::string* mutable_screensize();
  inline ::std::string* release_screensize();
  
  // optional string ThirdDigitalName = 15;
  inline bool has_thirddigitalname() const;
  inline void clear_thirddigitalname();
  static const int kThirdDigitalNameFieldNumber = 15;
  inline const ::std::string& thirddigitalname() const;
  inline void set_thirddigitalname(const ::std::string& value);
  inline void set_thirddigitalname(const char* value);
  inline void set_thirddigitalname(const char* value, size_t size);
  inline ::std::string* mutable_thirddigitalname();
  inline ::std::string* release_thirddigitalname();
  
  // optional string Thirdkey = 16;
  inline bool has_thirdkey() const;
  inline void clear_thirdkey();
  static const int kThirdkeyFieldNumber = 16;
  inline const ::std::string& thirdkey() const;
  inline void set_thirdkey(const ::std::string& value);
  inline void set_thirdkey(const char* value);
  inline void set_thirdkey(const char* value, size_t size);
  inline ::std::string* mutable_thirdkey();
  inline ::std::string* release_thirdkey();
  
  // optional string ThirdAppId = 17;
  inline bool has_thirdappid() const;
  inline void clear_thirdappid();
  static const int kThirdAppIdFieldNumber = 17;
  inline const ::std::string& thirdappid() const;
  inline void set_thirdappid(const ::std::string& value);
  inline void set_thirdappid(const char* value);
  inline void set_thirdappid(const char* value, size_t size);
  inline ::std::string* mutable_thirdappid();
  inline ::std::string* release_thirdappid();
  
  // optional string Package = 18;
  inline bool has_package() const;
  inline void clear_package();
  static const int kPackageFieldNumber = 18;
  inline const ::std::string& package() const;
  inline void set_package(const ::std::string& value);
  inline void set_package(const char* value);
  inline void set_package(const char* value, size_t size);
  inline ::std::string* mutable_package();
  inline ::std::string* release_package();
  
  // @@protoc_insertion_point(class_scope:REQQuickConn)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_pwd();
  inline void clear_has_pwd();
  inline void set_has_secureid();
  inline void clear_has_secureid();
  inline void set_has_comefromid();
  inline void clear_has_comefromid();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_roomadapte();
  inline void clear_has_roomadapte();
  inline void set_has_logintype();
  inline void clear_has_logintype();
  inline void set_has_curversion();
  inline void clear_has_curversion();
  inline void set_has_smallversion();
  inline void clear_has_smallversion();
  inline void set_has_resolutionid();
  inline void clear_has_resolutionid();
  inline void set_has_languageid();
  inline void clear_has_languageid();
  inline void set_has_screensize();
  inline void clear_has_screensize();
  inline void set_has_thirddigitalname();
  inline void clear_has_thirddigitalname();
  inline void set_has_thirdkey();
  inline void clear_has_thirdkey();
  inline void set_has_thirdappid();
  inline void clear_has_thirdappid();
  inline void set_has_package();
  inline void clear_has_package();
  
  ::std::string* username_;
  ::std::string* pwd_;
  ::std::string* secureid_;
  ::std::string* channelid_;
  ::google::protobuf::int32 comefromid_;
  ::google::protobuf::int32 gameid_;
  ::std::string* token_;
  ::google::protobuf::int32 roomadapte_;
  ::google::protobuf::int32 logintype_;
  ::google::protobuf::int32 curversion_;
  ::google::protobuf::int32 smallversion_;
  ::std::string* resolutionid_;
  ::std::string* languageid_;
  ::std::string* screensize_;
  ::std::string* thirddigitalname_;
  ::std::string* thirdkey_;
  ::std::string* thirdappid_;
  ::std::string* package_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static REQQuickConn* default_instance_;
};
// -------------------------------------------------------------------

class ACKQuickConn : public ::google::protobuf::MessageLite {
 public:
  ACKQuickConn();
  virtual ~ACKQuickConn();
  
  ACKQuickConn(const ACKQuickConn& from);
  
  inline ACKQuickConn& operator=(const ACKQuickConn& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ACKQuickConn& default_instance();
  
  void Swap(ACKQuickConn* other);
  
  // implements Message ----------------------------------------------
  
  ACKQuickConn* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ACKQuickConn& from);
  void MergeFrom(const ACKQuickConn& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 AckResult = 1;
  inline bool has_ackresult() const;
  inline void clear_ackresult();
  static const int kAckResultFieldNumber = 1;
  inline ::google::protobuf::int32 ackresult() const;
  inline void set_ackresult(::google::protobuf::int32 value);
  
  // optional string UserName = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required string RoleName = 3;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRoleNameFieldNumber = 3;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  
  // required int32 YuanBaoCnt = 4;
  inline bool has_yuanbaocnt() const;
  inline void clear_yuanbaocnt();
  static const int kYuanBaoCntFieldNumber = 4;
  inline ::google::protobuf::int32 yuanbaocnt() const;
  inline void set_yuanbaocnt(::google::protobuf::int32 value);
  
  // required int64 CoinCnt = 5;
  inline bool has_coincnt() const;
  inline void clear_coincnt();
  static const int kCoinCntFieldNumber = 5;
  inline ::google::protobuf::int64 coincnt() const;
  inline void set_coincnt(::google::protobuf::int64 value);
  
  // repeated .OGRoomInfo RoomList = 6;
  inline int roomlist_size() const;
  inline void clear_roomlist();
  static const int kRoomListFieldNumber = 6;
  inline const ::OGRoomInfo& roomlist(int index) const;
  inline ::OGRoomInfo* mutable_roomlist(int index);
  inline ::OGRoomInfo* add_roomlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
      roomlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
      mutable_roomlist();
  
  // repeated .OGThranMatchInfo MatchRoomList = 7;
  inline int matchroomlist_size() const;
  inline void clear_matchroomlist();
  static const int kMatchRoomListFieldNumber = 7;
  inline const ::OGThranMatchInfo& matchroomlist(int index) const;
  inline ::OGThranMatchInfo* mutable_matchroomlist(int index);
  inline ::OGThranMatchInfo* add_matchroomlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OGThranMatchInfo >&
      matchroomlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OGThranMatchInfo >*
      mutable_matchroomlist();
  
  // optional bytes Cert = 8;
  inline bool has_cert() const;
  inline void clear_cert();
  static const int kCertFieldNumber = 8;
  inline const ::std::string& cert() const;
  inline void set_cert(const ::std::string& value);
  inline void set_cert(const char* value);
  inline void set_cert(const void* value, size_t size);
  inline ::std::string* mutable_cert();
  inline ::std::string* release_cert();
  
  // optional bytes CertNoCert = 9;
  inline bool has_certnocert() const;
  inline void clear_certnocert();
  static const int kCertNoCertFieldNumber = 9;
  inline const ::std::string& certnocert() const;
  inline void set_certnocert(const ::std::string& value);
  inline void set_certnocert(const char* value);
  inline void set_certnocert(const void* value, size_t size);
  inline ::std::string* mutable_certnocert();
  inline ::std::string* release_certnocert();
  
  // required int32 CurVersion = 10;
  inline bool has_curversion() const;
  inline void clear_curversion();
  static const int kCurVersionFieldNumber = 10;
  inline ::google::protobuf::int32 curversion() const;
  inline void set_curversion(::google::protobuf::int32 value);
  
  // required string PlayEnable = 11;
  inline bool has_playenable() const;
  inline void clear_playenable();
  static const int kPlayEnableFieldNumber = 11;
  inline const ::std::string& playenable() const;
  inline void set_playenable(const ::std::string& value);
  inline void set_playenable(const char* value);
  inline void set_playenable(const char* value, size_t size);
  inline ::std::string* mutable_playenable();
  inline ::std::string* release_playenable();
  
  // required string DownloadUrl = 12;
  inline bool has_downloadurl() const;
  inline void clear_downloadurl();
  static const int kDownloadUrlFieldNumber = 12;
  inline const ::std::string& downloadurl() const;
  inline void set_downloadurl(const ::std::string& value);
  inline void set_downloadurl(const char* value);
  inline void set_downloadurl(const char* value, size_t size);
  inline ::std::string* mutable_downloadurl();
  inline ::std::string* release_downloadurl();
  
  // optional string IfPreserve = 13;
  inline bool has_ifpreserve() const;
  inline void clear_ifpreserve();
  static const int kIfPreserveFieldNumber = 13;
  inline const ::std::string& ifpreserve() const;
  inline void set_ifpreserve(const ::std::string& value);
  inline void set_ifpreserve(const char* value);
  inline void set_ifpreserve(const char* value, size_t size);
  inline ::std::string* mutable_ifpreserve();
  inline ::std::string* release_ifpreserve();
  
  // optional string PreserveMsg = 14;
  inline bool has_preservemsg() const;
  inline void clear_preservemsg();
  static const int kPreserveMsgFieldNumber = 14;
  inline const ::std::string& preservemsg() const;
  inline void set_preservemsg(const ::std::string& value);
  inline void set_preservemsg(const char* value);
  inline void set_preservemsg(const char* value, size_t size);
  inline ::std::string* mutable_preservemsg();
  inline ::std::string* release_preservemsg();
  
  // optional int32 DownloadReasion = 15;
  inline bool has_downloadreasion() const;
  inline void clear_downloadreasion();
  static const int kDownloadReasionFieldNumber = 15;
  inline ::google::protobuf::int32 downloadreasion() const;
  inline void set_downloadreasion(::google::protobuf::int32 value);
  
  // optional int32 GameId = 16;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 16;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // repeated .ThranJSSInfo JssList = 17;
  inline int jsslist_size() const;
  inline void clear_jsslist();
  static const int kJssListFieldNumber = 17;
  inline const ::ThranJSSInfo& jsslist(int index) const;
  inline ::ThranJSSInfo* mutable_jsslist(int index);
  inline ::ThranJSSInfo* add_jsslist();
  inline const ::google::protobuf::RepeatedPtrField< ::ThranJSSInfo >&
      jsslist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ThranJSSInfo >*
      mutable_jsslist();
  
  // optional string IfSearch = 18;
  inline bool has_ifsearch() const;
  inline void clear_ifsearch();
  static const int kIfSearchFieldNumber = 18;
  inline const ::std::string& ifsearch() const;
  inline void set_ifsearch(const ::std::string& value);
  inline void set_ifsearch(const char* value);
  inline void set_ifsearch(const char* value, size_t size);
  inline ::std::string* mutable_ifsearch();
  inline ::std::string* release_ifsearch();
  
  // repeated .OGBulletinInfo BulletinList = 19;
  inline int bulletinlist_size() const;
  inline void clear_bulletinlist();
  static const int kBulletinListFieldNumber = 19;
  inline const ::OGBulletinInfo& bulletinlist(int index) const;
  inline ::OGBulletinInfo* mutable_bulletinlist(int index);
  inline ::OGBulletinInfo* add_bulletinlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OGBulletinInfo >&
      bulletinlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OGBulletinInfo >*
      mutable_bulletinlist();
  
  // optional string VersionInfo = 20;
  inline bool has_versioninfo() const;
  inline void clear_versioninfo();
  static const int kVersionInfoFieldNumber = 20;
  inline const ::std::string& versioninfo() const;
  inline void set_versioninfo(const ::std::string& value);
  inline void set_versioninfo(const char* value);
  inline void set_versioninfo(const char* value, size_t size);
  inline ::std::string* mutable_versioninfo();
  inline ::std::string* release_versioninfo();
  
  // repeated .OGRoomInfo MatchSvrList = 21;
  inline int matchsvrlist_size() const;
  inline void clear_matchsvrlist();
  static const int kMatchSvrListFieldNumber = 21;
  inline const ::OGRoomInfo& matchsvrlist(int index) const;
  inline ::OGRoomInfo* mutable_matchsvrlist(int index);
  inline ::OGRoomInfo* add_matchsvrlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
      matchsvrlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
      mutable_matchsvrlist();
  
  // optional int32 Sex = 22;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 22;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);
  
  // repeated .OGRoomInfo RoomSvrList = 23;
  inline int roomsvrlist_size() const;
  inline void clear_roomsvrlist();
  static const int kRoomSvrListFieldNumber = 23;
  inline const ::OGRoomInfo& roomsvrlist(int index) const;
  inline ::OGRoomInfo* mutable_roomsvrlist(int index);
  inline ::OGRoomInfo* add_roomsvrlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
      roomsvrlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
      mutable_roomsvrlist();
  
  // optional int32 DdzActive = 24 [default = 0];
  inline bool has_ddzactive() const;
  inline void clear_ddzactive();
  static const int kDdzActiveFieldNumber = 24;
  inline ::google::protobuf::int32 ddzactive() const;
  inline void set_ddzactive(::google::protobuf::int32 value);
  
  // optional string MsgUrl = 25;
  inline bool has_msgurl() const;
  inline void clear_msgurl();
  static const int kMsgUrlFieldNumber = 25;
  inline const ::std::string& msgurl() const;
  inline void set_msgurl(const ::std::string& value);
  inline void set_msgurl(const char* value);
  inline void set_msgurl(const char* value, size_t size);
  inline ::std::string* mutable_msgurl();
  inline ::std::string* release_msgurl();
  
  // optional int32 ErrorCode = 26 [default = 0];
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 26;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:ACKQuickConn)
 private:
  inline void set_has_ackresult();
  inline void clear_has_ackresult();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_yuanbaocnt();
  inline void clear_has_yuanbaocnt();
  inline void set_has_coincnt();
  inline void clear_has_coincnt();
  inline void set_has_cert();
  inline void clear_has_cert();
  inline void set_has_certnocert();
  inline void clear_has_certnocert();
  inline void set_has_curversion();
  inline void clear_has_curversion();
  inline void set_has_playenable();
  inline void clear_has_playenable();
  inline void set_has_downloadurl();
  inline void clear_has_downloadurl();
  inline void set_has_ifpreserve();
  inline void clear_has_ifpreserve();
  inline void set_has_preservemsg();
  inline void clear_has_preservemsg();
  inline void set_has_downloadreasion();
  inline void clear_has_downloadreasion();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_ifsearch();
  inline void clear_has_ifsearch();
  inline void set_has_versioninfo();
  inline void clear_has_versioninfo();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_ddzactive();
  inline void clear_has_ddzactive();
  inline void set_has_msgurl();
  inline void clear_has_msgurl();
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  
  ::std::string* username_;
  ::google::protobuf::int32 ackresult_;
  ::google::protobuf::int32 yuanbaocnt_;
  ::std::string* rolename_;
  ::google::protobuf::int64 coincnt_;
  ::google::protobuf::RepeatedPtrField< ::OGRoomInfo > roomlist_;
  ::google::protobuf::RepeatedPtrField< ::OGThranMatchInfo > matchroomlist_;
  ::std::string* cert_;
  ::std::string* certnocert_;
  ::std::string* playenable_;
  ::std::string* downloadurl_;
  ::google::protobuf::int32 curversion_;
  ::google::protobuf::int32 downloadreasion_;
  ::std::string* ifpreserve_;
  ::std::string* preservemsg_;
  ::google::protobuf::RepeatedPtrField< ::ThranJSSInfo > jsslist_;
  ::std::string* ifsearch_;
  ::google::protobuf::RepeatedPtrField< ::OGBulletinInfo > bulletinlist_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 sex_;
  ::std::string* versioninfo_;
  ::google::protobuf::RepeatedPtrField< ::OGRoomInfo > matchsvrlist_;
  ::google::protobuf::RepeatedPtrField< ::OGRoomInfo > roomsvrlist_;
  ::std::string* msgurl_;
  ::google::protobuf::int32 ddzactive_;
  ::google::protobuf::int32 errorcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];
  
  friend void  protobuf_AddDesc_ThranConn_2eproto();
  friend void protobuf_AssignDesc_ThranConn_2eproto();
  friend void protobuf_ShutdownFile_ThranConn_2eproto();
  
  void InitAsDefaultInstance();
  static ACKQuickConn* default_instance_;
};
// ===================================================================


// ===================================================================

// REQThranReg

// required string UserName = 1;
inline bool REQThranReg::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQThranReg::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQThranReg::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQThranReg::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& REQThranReg::username() const {
  return *username_;
}
inline void REQThranReg::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void REQThranReg::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void REQThranReg::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranReg::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* REQThranReg::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string Pwd = 2;
inline bool REQThranReg::has_pwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQThranReg::set_has_pwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQThranReg::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQThranReg::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& REQThranReg::pwd() const {
  return *pwd_;
}
inline void REQThranReg::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void REQThranReg::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void REQThranReg::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranReg::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  return pwd_;
}
inline ::std::string* REQThranReg::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 VerifyId = 3;
inline bool REQThranReg::has_verifyid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQThranReg::set_has_verifyid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQThranReg::clear_has_verifyid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQThranReg::clear_verifyid() {
  verifyid_ = 0;
  clear_has_verifyid();
}
inline ::google::protobuf::int32 REQThranReg::verifyid() const {
  return verifyid_;
}
inline void REQThranReg::set_verifyid(::google::protobuf::int32 value) {
  set_has_verifyid();
  verifyid_ = value;
}

// optional string VerifyStr = 4;
inline bool REQThranReg::has_verifystr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void REQThranReg::set_has_verifystr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void REQThranReg::clear_has_verifystr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void REQThranReg::clear_verifystr() {
  if (verifystr_ != &::google::protobuf::internal::kEmptyString) {
    verifystr_->clear();
  }
  clear_has_verifystr();
}
inline const ::std::string& REQThranReg::verifystr() const {
  return *verifystr_;
}
inline void REQThranReg::set_verifystr(const ::std::string& value) {
  set_has_verifystr();
  if (verifystr_ == &::google::protobuf::internal::kEmptyString) {
    verifystr_ = new ::std::string;
  }
  verifystr_->assign(value);
}
inline void REQThranReg::set_verifystr(const char* value) {
  set_has_verifystr();
  if (verifystr_ == &::google::protobuf::internal::kEmptyString) {
    verifystr_ = new ::std::string;
  }
  verifystr_->assign(value);
}
inline void REQThranReg::set_verifystr(const char* value, size_t size) {
  set_has_verifystr();
  if (verifystr_ == &::google::protobuf::internal::kEmptyString) {
    verifystr_ = new ::std::string;
  }
  verifystr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranReg::mutable_verifystr() {
  set_has_verifystr();
  if (verifystr_ == &::google::protobuf::internal::kEmptyString) {
    verifystr_ = new ::std::string;
  }
  return verifystr_;
}
inline ::std::string* REQThranReg::release_verifystr() {
  clear_has_verifystr();
  if (verifystr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verifystr_;
    verifystr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string SecureID = 5;
inline bool REQThranReg::has_secureid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void REQThranReg::set_has_secureid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void REQThranReg::clear_has_secureid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void REQThranReg::clear_secureid() {
  if (secureid_ != &::google::protobuf::internal::kEmptyString) {
    secureid_->clear();
  }
  clear_has_secureid();
}
inline const ::std::string& REQThranReg::secureid() const {
  return *secureid_;
}
inline void REQThranReg::set_secureid(const ::std::string& value) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(value);
}
inline void REQThranReg::set_secureid(const char* value) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(value);
}
inline void REQThranReg::set_secureid(const char* value, size_t size) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranReg::mutable_secureid() {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  return secureid_;
}
inline ::std::string* REQThranReg::release_secureid() {
  clear_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secureid_;
    secureid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 ComeFromID = 6;
inline bool REQThranReg::has_comefromid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void REQThranReg::set_has_comefromid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void REQThranReg::clear_has_comefromid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void REQThranReg::clear_comefromid() {
  comefromid_ = 0;
  clear_has_comefromid();
}
inline ::google::protobuf::int32 REQThranReg::comefromid() const {
  return comefromid_;
}
inline void REQThranReg::set_comefromid(::google::protobuf::int32 value) {
  set_has_comefromid();
  comefromid_ = value;
}

// required string ChannelID = 7;
inline bool REQThranReg::has_channelid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void REQThranReg::set_has_channelid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void REQThranReg::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void REQThranReg::clear_channelid() {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    channelid_->clear();
  }
  clear_has_channelid();
}
inline const ::std::string& REQThranReg::channelid() const {
  return *channelid_;
}
inline void REQThranReg::set_channelid(const ::std::string& value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQThranReg::set_channelid(const char* value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQThranReg::set_channelid(const char* value, size_t size) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranReg::mutable_channelid() {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  return channelid_;
}
inline ::std::string* REQThranReg::release_channelid() {
  clear_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channelid_;
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 GameId = 8;
inline bool REQThranReg::has_gameid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void REQThranReg::set_has_gameid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void REQThranReg::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void REQThranReg::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 REQThranReg::gameid() const {
  return gameid_;
}
inline void REQThranReg::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required string token = 9;
inline bool REQThranReg::has_token() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void REQThranReg::set_has_token() {
  _has_bits_[0] |= 0x00000100u;
}
inline void REQThranReg::clear_has_token() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void REQThranReg::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& REQThranReg::token() const {
  return *token_;
}
inline void REQThranReg::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void REQThranReg::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void REQThranReg::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranReg::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* REQThranReg::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes UserNameApl = 10;
inline bool REQThranReg::has_usernameapl() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void REQThranReg::set_has_usernameapl() {
  _has_bits_[0] |= 0x00000200u;
}
inline void REQThranReg::clear_has_usernameapl() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void REQThranReg::clear_usernameapl() {
  if (usernameapl_ != &::google::protobuf::internal::kEmptyString) {
    usernameapl_->clear();
  }
  clear_has_usernameapl();
}
inline const ::std::string& REQThranReg::usernameapl() const {
  return *usernameapl_;
}
inline void REQThranReg::set_usernameapl(const ::std::string& value) {
  set_has_usernameapl();
  if (usernameapl_ == &::google::protobuf::internal::kEmptyString) {
    usernameapl_ = new ::std::string;
  }
  usernameapl_->assign(value);
}
inline void REQThranReg::set_usernameapl(const char* value) {
  set_has_usernameapl();
  if (usernameapl_ == &::google::protobuf::internal::kEmptyString) {
    usernameapl_ = new ::std::string;
  }
  usernameapl_->assign(value);
}
inline void REQThranReg::set_usernameapl(const void* value, size_t size) {
  set_has_usernameapl();
  if (usernameapl_ == &::google::protobuf::internal::kEmptyString) {
    usernameapl_ = new ::std::string;
  }
  usernameapl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranReg::mutable_usernameapl() {
  set_has_usernameapl();
  if (usernameapl_ == &::google::protobuf::internal::kEmptyString) {
    usernameapl_ = new ::std::string;
  }
  return usernameapl_;
}
inline ::std::string* REQThranReg::release_usernameapl() {
  clear_has_usernameapl();
  if (usernameapl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usernameapl_;
    usernameapl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 RoomAdapte = 11 [default = 0];
inline bool REQThranReg::has_roomadapte() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void REQThranReg::set_has_roomadapte() {
  _has_bits_[0] |= 0x00000400u;
}
inline void REQThranReg::clear_has_roomadapte() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void REQThranReg::clear_roomadapte() {
  roomadapte_ = 0;
  clear_has_roomadapte();
}
inline ::google::protobuf::int32 REQThranReg::roomadapte() const {
  return roomadapte_;
}
inline void REQThranReg::set_roomadapte(::google::protobuf::int32 value) {
  set_has_roomadapte();
  roomadapte_ = value;
}

// optional int32 Sex = 12 [default = 0];
inline bool REQThranReg::has_sex() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void REQThranReg::set_has_sex() {
  _has_bits_[0] |= 0x00000800u;
}
inline void REQThranReg::clear_has_sex() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void REQThranReg::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 REQThranReg::sex() const {
  return sex_;
}
inline void REQThranReg::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// -------------------------------------------------------------------

// ACKThranReg

// required int32 AckResult = 1;
inline bool ACKThranReg::has_ackresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKThranReg::set_has_ackresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKThranReg::clear_has_ackresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKThranReg::clear_ackresult() {
  ackresult_ = 0;
  clear_has_ackresult();
}
inline ::google::protobuf::int32 ACKThranReg::ackresult() const {
  return ackresult_;
}
inline void ACKThranReg::set_ackresult(::google::protobuf::int32 value) {
  set_has_ackresult();
  ackresult_ = value;
}

// optional string ErrorStr = 2;
inline bool ACKThranReg::has_errorstr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKThranReg::set_has_errorstr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKThranReg::clear_has_errorstr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKThranReg::clear_errorstr() {
  if (errorstr_ != &::google::protobuf::internal::kEmptyString) {
    errorstr_->clear();
  }
  clear_has_errorstr();
}
inline const ::std::string& ACKThranReg::errorstr() const {
  return *errorstr_;
}
inline void ACKThranReg::set_errorstr(const ::std::string& value) {
  set_has_errorstr();
  if (errorstr_ == &::google::protobuf::internal::kEmptyString) {
    errorstr_ = new ::std::string;
  }
  errorstr_->assign(value);
}
inline void ACKThranReg::set_errorstr(const char* value) {
  set_has_errorstr();
  if (errorstr_ == &::google::protobuf::internal::kEmptyString) {
    errorstr_ = new ::std::string;
  }
  errorstr_->assign(value);
}
inline void ACKThranReg::set_errorstr(const char* value, size_t size) {
  set_has_errorstr();
  if (errorstr_ == &::google::protobuf::internal::kEmptyString) {
    errorstr_ = new ::std::string;
  }
  errorstr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranReg::mutable_errorstr() {
  set_has_errorstr();
  if (errorstr_ == &::google::protobuf::internal::kEmptyString) {
    errorstr_ = new ::std::string;
  }
  return errorstr_;
}
inline ::std::string* ACKThranReg::release_errorstr() {
  clear_has_errorstr();
  if (errorstr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errorstr_;
    errorstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes cert = 3;
inline bool ACKThranReg::has_cert() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKThranReg::set_has_cert() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKThranReg::clear_has_cert() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKThranReg::clear_cert() {
  if (cert_ != &::google::protobuf::internal::kEmptyString) {
    cert_->clear();
  }
  clear_has_cert();
}
inline const ::std::string& ACKThranReg::cert() const {
  return *cert_;
}
inline void ACKThranReg::set_cert(const ::std::string& value) {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    cert_ = new ::std::string;
  }
  cert_->assign(value);
}
inline void ACKThranReg::set_cert(const char* value) {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    cert_ = new ::std::string;
  }
  cert_->assign(value);
}
inline void ACKThranReg::set_cert(const void* value, size_t size) {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    cert_ = new ::std::string;
  }
  cert_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranReg::mutable_cert() {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    cert_ = new ::std::string;
  }
  return cert_;
}
inline ::std::string* ACKThranReg::release_cert() {
  clear_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cert_;
    cert_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoleName = 4;
inline bool ACKThranReg::has_rolename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACKThranReg::set_has_rolename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACKThranReg::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACKThranReg::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& ACKThranReg::rolename() const {
  return *rolename_;
}
inline void ACKThranReg::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void ACKThranReg::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void ACKThranReg::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranReg::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* ACKThranReg::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .OGRoomInfo RoomList = 5;
inline int ACKThranReg::roomlist_size() const {
  return roomlist_.size();
}
inline void ACKThranReg::clear_roomlist() {
  roomlist_.Clear();
}
inline const ::OGRoomInfo& ACKThranReg::roomlist(int index) const {
  return roomlist_.Get(index);
}
inline ::OGRoomInfo* ACKThranReg::mutable_roomlist(int index) {
  return roomlist_.Mutable(index);
}
inline ::OGRoomInfo* ACKThranReg::add_roomlist() {
  return roomlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
ACKThranReg::roomlist() const {
  return roomlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
ACKThranReg::mutable_roomlist() {
  return &roomlist_;
}

// required int32 LoginId = 6;
inline bool ACKThranReg::has_loginid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ACKThranReg::set_has_loginid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ACKThranReg::clear_has_loginid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ACKThranReg::clear_loginid() {
  loginid_ = 0;
  clear_has_loginid();
}
inline ::google::protobuf::int32 ACKThranReg::loginid() const {
  return loginid_;
}
inline void ACKThranReg::set_loginid(::google::protobuf::int32 value) {
  set_has_loginid();
  loginid_ = value;
}

// repeated .OGRoomInfo MatchRoomList = 7;
inline int ACKThranReg::matchroomlist_size() const {
  return matchroomlist_.size();
}
inline void ACKThranReg::clear_matchroomlist() {
  matchroomlist_.Clear();
}
inline const ::OGRoomInfo& ACKThranReg::matchroomlist(int index) const {
  return matchroomlist_.Get(index);
}
inline ::OGRoomInfo* ACKThranReg::mutable_matchroomlist(int index) {
  return matchroomlist_.Mutable(index);
}
inline ::OGRoomInfo* ACKThranReg::add_matchroomlist() {
  return matchroomlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
ACKThranReg::matchroomlist() const {
  return matchroomlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
ACKThranReg::mutable_matchroomlist() {
  return &matchroomlist_;
}

// optional bytes CertNoRole = 8;
inline bool ACKThranReg::has_certnorole() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ACKThranReg::set_has_certnorole() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ACKThranReg::clear_has_certnorole() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ACKThranReg::clear_certnorole() {
  if (certnorole_ != &::google::protobuf::internal::kEmptyString) {
    certnorole_->clear();
  }
  clear_has_certnorole();
}
inline const ::std::string& ACKThranReg::certnorole() const {
  return *certnorole_;
}
inline void ACKThranReg::set_certnorole(const ::std::string& value) {
  set_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    certnorole_ = new ::std::string;
  }
  certnorole_->assign(value);
}
inline void ACKThranReg::set_certnorole(const char* value) {
  set_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    certnorole_ = new ::std::string;
  }
  certnorole_->assign(value);
}
inline void ACKThranReg::set_certnorole(const void* value, size_t size) {
  set_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    certnorole_ = new ::std::string;
  }
  certnorole_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranReg::mutable_certnorole() {
  set_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    certnorole_ = new ::std::string;
  }
  return certnorole_;
}
inline ::std::string* ACKThranReg::release_certnorole() {
  clear_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = certnorole_;
    certnorole_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// REQThranConn

// required string UserName = 1;
inline bool REQThranConn::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQThranConn::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQThranConn::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQThranConn::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& REQThranConn::username() const {
  return *username_;
}
inline void REQThranConn::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void REQThranConn::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void REQThranConn::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranConn::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* REQThranConn::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string NickName = 2;
inline bool REQThranConn::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQThranConn::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQThranConn::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQThranConn::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& REQThranConn::nickname() const {
  return *nickname_;
}
inline void REQThranConn::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void REQThranConn::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void REQThranConn::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranConn::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* REQThranConn::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string Pwd = 3;
inline bool REQThranConn::has_pwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQThranConn::set_has_pwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQThranConn::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQThranConn::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& REQThranConn::pwd() const {
  return *pwd_;
}
inline void REQThranConn::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void REQThranConn::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void REQThranConn::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranConn::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  return pwd_;
}
inline ::std::string* REQThranConn::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 Sex = 4;
inline bool REQThranConn::has_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void REQThranConn::set_has_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void REQThranConn::clear_has_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void REQThranConn::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 REQThranConn::sex() const {
  return sex_;
}
inline void REQThranConn::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// required string SecureID = 5;
inline bool REQThranConn::has_secureid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void REQThranConn::set_has_secureid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void REQThranConn::clear_has_secureid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void REQThranConn::clear_secureid() {
  if (secureid_ != &::google::protobuf::internal::kEmptyString) {
    secureid_->clear();
  }
  clear_has_secureid();
}
inline const ::std::string& REQThranConn::secureid() const {
  return *secureid_;
}
inline void REQThranConn::set_secureid(const ::std::string& value) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(value);
}
inline void REQThranConn::set_secureid(const char* value) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(value);
}
inline void REQThranConn::set_secureid(const char* value, size_t size) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranConn::mutable_secureid() {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  return secureid_;
}
inline ::std::string* REQThranConn::release_secureid() {
  clear_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secureid_;
    secureid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 ComeFromID = 6;
inline bool REQThranConn::has_comefromid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void REQThranConn::set_has_comefromid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void REQThranConn::clear_has_comefromid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void REQThranConn::clear_comefromid() {
  comefromid_ = 0;
  clear_has_comefromid();
}
inline ::google::protobuf::int32 REQThranConn::comefromid() const {
  return comefromid_;
}
inline void REQThranConn::set_comefromid(::google::protobuf::int32 value) {
  set_has_comefromid();
  comefromid_ = value;
}

// required string ChannelID = 7;
inline bool REQThranConn::has_channelid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void REQThranConn::set_has_channelid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void REQThranConn::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void REQThranConn::clear_channelid() {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    channelid_->clear();
  }
  clear_has_channelid();
}
inline const ::std::string& REQThranConn::channelid() const {
  return *channelid_;
}
inline void REQThranConn::set_channelid(const ::std::string& value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQThranConn::set_channelid(const char* value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQThranConn::set_channelid(const char* value, size_t size) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranConn::mutable_channelid() {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  return channelid_;
}
inline ::std::string* REQThranConn::release_channelid() {
  clear_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channelid_;
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 GameId = 8;
inline bool REQThranConn::has_gameid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void REQThranConn::set_has_gameid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void REQThranConn::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void REQThranConn::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 REQThranConn::gameid() const {
  return gameid_;
}
inline void REQThranConn::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required string token = 9;
inline bool REQThranConn::has_token() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void REQThranConn::set_has_token() {
  _has_bits_[0] |= 0x00000100u;
}
inline void REQThranConn::clear_has_token() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void REQThranConn::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& REQThranConn::token() const {
  return *token_;
}
inline void REQThranConn::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void REQThranConn::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void REQThranConn::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranConn::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* REQThranConn::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes UserNameApl = 10;
inline bool REQThranConn::has_usernameapl() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void REQThranConn::set_has_usernameapl() {
  _has_bits_[0] |= 0x00000200u;
}
inline void REQThranConn::clear_has_usernameapl() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void REQThranConn::clear_usernameapl() {
  if (usernameapl_ != &::google::protobuf::internal::kEmptyString) {
    usernameapl_->clear();
  }
  clear_has_usernameapl();
}
inline const ::std::string& REQThranConn::usernameapl() const {
  return *usernameapl_;
}
inline void REQThranConn::set_usernameapl(const ::std::string& value) {
  set_has_usernameapl();
  if (usernameapl_ == &::google::protobuf::internal::kEmptyString) {
    usernameapl_ = new ::std::string;
  }
  usernameapl_->assign(value);
}
inline void REQThranConn::set_usernameapl(const char* value) {
  set_has_usernameapl();
  if (usernameapl_ == &::google::protobuf::internal::kEmptyString) {
    usernameapl_ = new ::std::string;
  }
  usernameapl_->assign(value);
}
inline void REQThranConn::set_usernameapl(const void* value, size_t size) {
  set_has_usernameapl();
  if (usernameapl_ == &::google::protobuf::internal::kEmptyString) {
    usernameapl_ = new ::std::string;
  }
  usernameapl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranConn::mutable_usernameapl() {
  set_has_usernameapl();
  if (usernameapl_ == &::google::protobuf::internal::kEmptyString) {
    usernameapl_ = new ::std::string;
  }
  return usernameapl_;
}
inline ::std::string* REQThranConn::release_usernameapl() {
  clear_has_usernameapl();
  if (usernameapl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usernameapl_;
    usernameapl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 VerifyId = 11;
inline bool REQThranConn::has_verifyid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void REQThranConn::set_has_verifyid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void REQThranConn::clear_has_verifyid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void REQThranConn::clear_verifyid() {
  verifyid_ = 0;
  clear_has_verifyid();
}
inline ::google::protobuf::int32 REQThranConn::verifyid() const {
  return verifyid_;
}
inline void REQThranConn::set_verifyid(::google::protobuf::int32 value) {
  set_has_verifyid();
  verifyid_ = value;
}

// optional string Ticket = 12;
inline bool REQThranConn::has_ticket() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void REQThranConn::set_has_ticket() {
  _has_bits_[0] |= 0x00000800u;
}
inline void REQThranConn::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void REQThranConn::clear_ticket() {
  if (ticket_ != &::google::protobuf::internal::kEmptyString) {
    ticket_->clear();
  }
  clear_has_ticket();
}
inline const ::std::string& REQThranConn::ticket() const {
  return *ticket_;
}
inline void REQThranConn::set_ticket(const ::std::string& value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void REQThranConn::set_ticket(const char* value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void REQThranConn::set_ticket(const char* value, size_t size) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranConn::mutable_ticket() {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  return ticket_;
}
inline ::std::string* REQThranConn::release_ticket() {
  clear_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ticket_;
    ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 RoomAdapte = 13 [default = 0];
inline bool REQThranConn::has_roomadapte() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void REQThranConn::set_has_roomadapte() {
  _has_bits_[0] |= 0x00001000u;
}
inline void REQThranConn::clear_has_roomadapte() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void REQThranConn::clear_roomadapte() {
  roomadapte_ = 0;
  clear_has_roomadapte();
}
inline ::google::protobuf::int32 REQThranConn::roomadapte() const {
  return roomadapte_;
}
inline void REQThranConn::set_roomadapte(::google::protobuf::int32 value) {
  set_has_roomadapte();
  roomadapte_ = value;
}

// optional int32 LoginType = 14 [default = 0];
inline bool REQThranConn::has_logintype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void REQThranConn::set_has_logintype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void REQThranConn::clear_has_logintype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void REQThranConn::clear_logintype() {
  logintype_ = 0;
  clear_has_logintype();
}
inline ::google::protobuf::int32 REQThranConn::logintype() const {
  return logintype_;
}
inline void REQThranConn::set_logintype(::google::protobuf::int32 value) {
  set_has_logintype();
  logintype_ = value;
}

// optional int32 GroupID = 15;
inline bool REQThranConn::has_groupid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void REQThranConn::set_has_groupid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void REQThranConn::clear_has_groupid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void REQThranConn::clear_groupid() {
  groupid_ = 0;
  clear_has_groupid();
}
inline ::google::protobuf::int32 REQThranConn::groupid() const {
  return groupid_;
}
inline void REQThranConn::set_groupid(::google::protobuf::int32 value) {
  set_has_groupid();
  groupid_ = value;
}

// -------------------------------------------------------------------

// ACKThranConn

// required int32 AckResult = 1;
inline bool ACKThranConn::has_ackresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKThranConn::set_has_ackresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKThranConn::clear_has_ackresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKThranConn::clear_ackresult() {
  ackresult_ = 0;
  clear_has_ackresult();
}
inline ::google::protobuf::int32 ACKThranConn::ackresult() const {
  return ackresult_;
}
inline void ACKThranConn::set_ackresult(::google::protobuf::int32 value) {
  set_has_ackresult();
  ackresult_ = value;
}

// required bytes cert = 2;
inline bool ACKThranConn::has_cert() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKThranConn::set_has_cert() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKThranConn::clear_has_cert() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKThranConn::clear_cert() {
  if (cert_ != &::google::protobuf::internal::kEmptyString) {
    cert_->clear();
  }
  clear_has_cert();
}
inline const ::std::string& ACKThranConn::cert() const {
  return *cert_;
}
inline void ACKThranConn::set_cert(const ::std::string& value) {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    cert_ = new ::std::string;
  }
  cert_->assign(value);
}
inline void ACKThranConn::set_cert(const char* value) {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    cert_ = new ::std::string;
  }
  cert_->assign(value);
}
inline void ACKThranConn::set_cert(const void* value, size_t size) {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    cert_ = new ::std::string;
  }
  cert_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranConn::mutable_cert() {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    cert_ = new ::std::string;
  }
  return cert_;
}
inline ::std::string* ACKThranConn::release_cert() {
  clear_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cert_;
    cert_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string UserName = 3;
inline bool ACKThranConn::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKThranConn::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKThranConn::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKThranConn::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ACKThranConn::username() const {
  return *username_;
}
inline void ACKThranConn::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ACKThranConn::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ACKThranConn::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranConn::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ACKThranConn::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoleName = 4;
inline bool ACKThranConn::has_rolename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACKThranConn::set_has_rolename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACKThranConn::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACKThranConn::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& ACKThranConn::rolename() const {
  return *rolename_;
}
inline void ACKThranConn::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void ACKThranConn::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void ACKThranConn::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranConn::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* ACKThranConn::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string PassWord = 5;
inline bool ACKThranConn::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ACKThranConn::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ACKThranConn::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ACKThranConn::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& ACKThranConn::password() const {
  return *password_;
}
inline void ACKThranConn::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ACKThranConn::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ACKThranConn::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranConn::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* ACKThranConn::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 YuanBaoCnt = 6;
inline bool ACKThranConn::has_yuanbaocnt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ACKThranConn::set_has_yuanbaocnt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ACKThranConn::clear_has_yuanbaocnt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ACKThranConn::clear_yuanbaocnt() {
  yuanbaocnt_ = 0;
  clear_has_yuanbaocnt();
}
inline ::google::protobuf::int32 ACKThranConn::yuanbaocnt() const {
  return yuanbaocnt_;
}
inline void ACKThranConn::set_yuanbaocnt(::google::protobuf::int32 value) {
  set_has_yuanbaocnt();
  yuanbaocnt_ = value;
}

// required int64 CoinCnt = 7;
inline bool ACKThranConn::has_coincnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ACKThranConn::set_has_coincnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ACKThranConn::clear_has_coincnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ACKThranConn::clear_coincnt() {
  coincnt_ = GOOGLE_LONGLONG(0);
  clear_has_coincnt();
}
inline ::google::protobuf::int64 ACKThranConn::coincnt() const {
  return coincnt_;
}
inline void ACKThranConn::set_coincnt(::google::protobuf::int64 value) {
  set_has_coincnt();
  coincnt_ = value;
}

// repeated .OGRoomInfo RoomList = 8;
inline int ACKThranConn::roomlist_size() const {
  return roomlist_.size();
}
inline void ACKThranConn::clear_roomlist() {
  roomlist_.Clear();
}
inline const ::OGRoomInfo& ACKThranConn::roomlist(int index) const {
  return roomlist_.Get(index);
}
inline ::OGRoomInfo* ACKThranConn::mutable_roomlist(int index) {
  return roomlist_.Mutable(index);
}
inline ::OGRoomInfo* ACKThranConn::add_roomlist() {
  return roomlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
ACKThranConn::roomlist() const {
  return roomlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
ACKThranConn::mutable_roomlist() {
  return &roomlist_;
}

// required int32 LoginId = 9;
inline bool ACKThranConn::has_loginid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ACKThranConn::set_has_loginid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ACKThranConn::clear_has_loginid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ACKThranConn::clear_loginid() {
  loginid_ = 0;
  clear_has_loginid();
}
inline ::google::protobuf::int32 ACKThranConn::loginid() const {
  return loginid_;
}
inline void ACKThranConn::set_loginid(::google::protobuf::int32 value) {
  set_has_loginid();
  loginid_ = value;
}

// repeated .OGRoomInfo MatchRoomList = 10;
inline int ACKThranConn::matchroomlist_size() const {
  return matchroomlist_.size();
}
inline void ACKThranConn::clear_matchroomlist() {
  matchroomlist_.Clear();
}
inline const ::OGRoomInfo& ACKThranConn::matchroomlist(int index) const {
  return matchroomlist_.Get(index);
}
inline ::OGRoomInfo* ACKThranConn::mutable_matchroomlist(int index) {
  return matchroomlist_.Mutable(index);
}
inline ::OGRoomInfo* ACKThranConn::add_matchroomlist() {
  return matchroomlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
ACKThranConn::matchroomlist() const {
  return matchroomlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
ACKThranConn::mutable_matchroomlist() {
  return &matchroomlist_;
}

// optional bytes CertNoRole = 11;
inline bool ACKThranConn::has_certnorole() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ACKThranConn::set_has_certnorole() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ACKThranConn::clear_has_certnorole() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ACKThranConn::clear_certnorole() {
  if (certnorole_ != &::google::protobuf::internal::kEmptyString) {
    certnorole_->clear();
  }
  clear_has_certnorole();
}
inline const ::std::string& ACKThranConn::certnorole() const {
  return *certnorole_;
}
inline void ACKThranConn::set_certnorole(const ::std::string& value) {
  set_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    certnorole_ = new ::std::string;
  }
  certnorole_->assign(value);
}
inline void ACKThranConn::set_certnorole(const char* value) {
  set_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    certnorole_ = new ::std::string;
  }
  certnorole_->assign(value);
}
inline void ACKThranConn::set_certnorole(const void* value, size_t size) {
  set_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    certnorole_ = new ::std::string;
  }
  certnorole_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranConn::mutable_certnorole() {
  set_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    certnorole_ = new ::std::string;
  }
  return certnorole_;
}
inline ::std::string* ACKThranConn::release_certnorole() {
  clear_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = certnorole_;
    certnorole_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .ThranRoomInfo ThranRoomItems = 12;
inline int ACKThranConn::thranroomitems_size() const {
  return thranroomitems_.size();
}
inline void ACKThranConn::clear_thranroomitems() {
  thranroomitems_.Clear();
}
inline const ::ThranRoomInfo& ACKThranConn::thranroomitems(int index) const {
  return thranroomitems_.Get(index);
}
inline ::ThranRoomInfo* ACKThranConn::mutable_thranroomitems(int index) {
  return thranroomitems_.Mutable(index);
}
inline ::ThranRoomInfo* ACKThranConn::add_thranroomitems() {
  return thranroomitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ThranRoomInfo >&
ACKThranConn::thranroomitems() const {
  return thranroomitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::ThranRoomInfo >*
ACKThranConn::mutable_thranroomitems() {
  return &thranroomitems_;
}

// -------------------------------------------------------------------

// REQThranShortCert

// required string UserName = 1;
inline bool REQThranShortCert::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQThranShortCert::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQThranShortCert::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQThranShortCert::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& REQThranShortCert::username() const {
  return *username_;
}
inline void REQThranShortCert::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void REQThranShortCert::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void REQThranShortCert::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranShortCert::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* REQThranShortCert::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string NickName = 2;
inline bool REQThranShortCert::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQThranShortCert::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQThranShortCert::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQThranShortCert::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& REQThranShortCert::nickname() const {
  return *nickname_;
}
inline void REQThranShortCert::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void REQThranShortCert::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void REQThranShortCert::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranShortCert::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* REQThranShortCert::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string Pwd = 3;
inline bool REQThranShortCert::has_pwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQThranShortCert::set_has_pwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQThranShortCert::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQThranShortCert::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& REQThranShortCert::pwd() const {
  return *pwd_;
}
inline void REQThranShortCert::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void REQThranShortCert::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void REQThranShortCert::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranShortCert::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  return pwd_;
}
inline ::std::string* REQThranShortCert::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 Sex = 4;
inline bool REQThranShortCert::has_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void REQThranShortCert::set_has_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void REQThranShortCert::clear_has_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void REQThranShortCert::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 REQThranShortCert::sex() const {
  return sex_;
}
inline void REQThranShortCert::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// required string SecureID = 5;
inline bool REQThranShortCert::has_secureid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void REQThranShortCert::set_has_secureid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void REQThranShortCert::clear_has_secureid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void REQThranShortCert::clear_secureid() {
  if (secureid_ != &::google::protobuf::internal::kEmptyString) {
    secureid_->clear();
  }
  clear_has_secureid();
}
inline const ::std::string& REQThranShortCert::secureid() const {
  return *secureid_;
}
inline void REQThranShortCert::set_secureid(const ::std::string& value) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(value);
}
inline void REQThranShortCert::set_secureid(const char* value) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(value);
}
inline void REQThranShortCert::set_secureid(const char* value, size_t size) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranShortCert::mutable_secureid() {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  return secureid_;
}
inline ::std::string* REQThranShortCert::release_secureid() {
  clear_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secureid_;
    secureid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 ComeFromID = 6;
inline bool REQThranShortCert::has_comefromid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void REQThranShortCert::set_has_comefromid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void REQThranShortCert::clear_has_comefromid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void REQThranShortCert::clear_comefromid() {
  comefromid_ = 0;
  clear_has_comefromid();
}
inline ::google::protobuf::int32 REQThranShortCert::comefromid() const {
  return comefromid_;
}
inline void REQThranShortCert::set_comefromid(::google::protobuf::int32 value) {
  set_has_comefromid();
  comefromid_ = value;
}

// required string ChannelID = 7;
inline bool REQThranShortCert::has_channelid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void REQThranShortCert::set_has_channelid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void REQThranShortCert::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void REQThranShortCert::clear_channelid() {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    channelid_->clear();
  }
  clear_has_channelid();
}
inline const ::std::string& REQThranShortCert::channelid() const {
  return *channelid_;
}
inline void REQThranShortCert::set_channelid(const ::std::string& value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQThranShortCert::set_channelid(const char* value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQThranShortCert::set_channelid(const char* value, size_t size) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranShortCert::mutable_channelid() {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  return channelid_;
}
inline ::std::string* REQThranShortCert::release_channelid() {
  clear_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channelid_;
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 GameId = 8;
inline bool REQThranShortCert::has_gameid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void REQThranShortCert::set_has_gameid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void REQThranShortCert::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void REQThranShortCert::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 REQThranShortCert::gameid() const {
  return gameid_;
}
inline void REQThranShortCert::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required string token = 9;
inline bool REQThranShortCert::has_token() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void REQThranShortCert::set_has_token() {
  _has_bits_[0] |= 0x00000100u;
}
inline void REQThranShortCert::clear_has_token() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void REQThranShortCert::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& REQThranShortCert::token() const {
  return *token_;
}
inline void REQThranShortCert::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void REQThranShortCert::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void REQThranShortCert::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranShortCert::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* REQThranShortCert::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes UserNameApl = 10;
inline bool REQThranShortCert::has_usernameapl() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void REQThranShortCert::set_has_usernameapl() {
  _has_bits_[0] |= 0x00000200u;
}
inline void REQThranShortCert::clear_has_usernameapl() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void REQThranShortCert::clear_usernameapl() {
  if (usernameapl_ != &::google::protobuf::internal::kEmptyString) {
    usernameapl_->clear();
  }
  clear_has_usernameapl();
}
inline const ::std::string& REQThranShortCert::usernameapl() const {
  return *usernameapl_;
}
inline void REQThranShortCert::set_usernameapl(const ::std::string& value) {
  set_has_usernameapl();
  if (usernameapl_ == &::google::protobuf::internal::kEmptyString) {
    usernameapl_ = new ::std::string;
  }
  usernameapl_->assign(value);
}
inline void REQThranShortCert::set_usernameapl(const char* value) {
  set_has_usernameapl();
  if (usernameapl_ == &::google::protobuf::internal::kEmptyString) {
    usernameapl_ = new ::std::string;
  }
  usernameapl_->assign(value);
}
inline void REQThranShortCert::set_usernameapl(const void* value, size_t size) {
  set_has_usernameapl();
  if (usernameapl_ == &::google::protobuf::internal::kEmptyString) {
    usernameapl_ = new ::std::string;
  }
  usernameapl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranShortCert::mutable_usernameapl() {
  set_has_usernameapl();
  if (usernameapl_ == &::google::protobuf::internal::kEmptyString) {
    usernameapl_ = new ::std::string;
  }
  return usernameapl_;
}
inline ::std::string* REQThranShortCert::release_usernameapl() {
  clear_has_usernameapl();
  if (usernameapl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usernameapl_;
    usernameapl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 VerifyId = 11;
inline bool REQThranShortCert::has_verifyid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void REQThranShortCert::set_has_verifyid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void REQThranShortCert::clear_has_verifyid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void REQThranShortCert::clear_verifyid() {
  verifyid_ = 0;
  clear_has_verifyid();
}
inline ::google::protobuf::int32 REQThranShortCert::verifyid() const {
  return verifyid_;
}
inline void REQThranShortCert::set_verifyid(::google::protobuf::int32 value) {
  set_has_verifyid();
  verifyid_ = value;
}

// optional string Ticket = 12;
inline bool REQThranShortCert::has_ticket() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void REQThranShortCert::set_has_ticket() {
  _has_bits_[0] |= 0x00000800u;
}
inline void REQThranShortCert::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void REQThranShortCert::clear_ticket() {
  if (ticket_ != &::google::protobuf::internal::kEmptyString) {
    ticket_->clear();
  }
  clear_has_ticket();
}
inline const ::std::string& REQThranShortCert::ticket() const {
  return *ticket_;
}
inline void REQThranShortCert::set_ticket(const ::std::string& value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void REQThranShortCert::set_ticket(const char* value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void REQThranShortCert::set_ticket(const char* value, size_t size) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranShortCert::mutable_ticket() {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  return ticket_;
}
inline ::std::string* REQThranShortCert::release_ticket() {
  clear_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ticket_;
    ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 RoomAdapte = 13 [default = 0];
inline bool REQThranShortCert::has_roomadapte() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void REQThranShortCert::set_has_roomadapte() {
  _has_bits_[0] |= 0x00001000u;
}
inline void REQThranShortCert::clear_has_roomadapte() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void REQThranShortCert::clear_roomadapte() {
  roomadapte_ = 0;
  clear_has_roomadapte();
}
inline ::google::protobuf::int32 REQThranShortCert::roomadapte() const {
  return roomadapte_;
}
inline void REQThranShortCert::set_roomadapte(::google::protobuf::int32 value) {
  set_has_roomadapte();
  roomadapte_ = value;
}

// -------------------------------------------------------------------

// ACKThranShortCert

// required int32 AckResult = 1;
inline bool ACKThranShortCert::has_ackresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKThranShortCert::set_has_ackresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKThranShortCert::clear_has_ackresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKThranShortCert::clear_ackresult() {
  ackresult_ = 0;
  clear_has_ackresult();
}
inline ::google::protobuf::int32 ACKThranShortCert::ackresult() const {
  return ackresult_;
}
inline void ACKThranShortCert::set_ackresult(::google::protobuf::int32 value) {
  set_has_ackresult();
  ackresult_ = value;
}

// required bytes ShortCert = 2;
inline bool ACKThranShortCert::has_shortcert() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKThranShortCert::set_has_shortcert() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKThranShortCert::clear_has_shortcert() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKThranShortCert::clear_shortcert() {
  if (shortcert_ != &::google::protobuf::internal::kEmptyString) {
    shortcert_->clear();
  }
  clear_has_shortcert();
}
inline const ::std::string& ACKThranShortCert::shortcert() const {
  return *shortcert_;
}
inline void ACKThranShortCert::set_shortcert(const ::std::string& value) {
  set_has_shortcert();
  if (shortcert_ == &::google::protobuf::internal::kEmptyString) {
    shortcert_ = new ::std::string;
  }
  shortcert_->assign(value);
}
inline void ACKThranShortCert::set_shortcert(const char* value) {
  set_has_shortcert();
  if (shortcert_ == &::google::protobuf::internal::kEmptyString) {
    shortcert_ = new ::std::string;
  }
  shortcert_->assign(value);
}
inline void ACKThranShortCert::set_shortcert(const void* value, size_t size) {
  set_has_shortcert();
  if (shortcert_ == &::google::protobuf::internal::kEmptyString) {
    shortcert_ = new ::std::string;
  }
  shortcert_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranShortCert::mutable_shortcert() {
  set_has_shortcert();
  if (shortcert_ == &::google::protobuf::internal::kEmptyString) {
    shortcert_ = new ::std::string;
  }
  return shortcert_;
}
inline ::std::string* ACKThranShortCert::release_shortcert() {
  clear_has_shortcert();
  if (shortcert_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = shortcert_;
    shortcert_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string UserName = 3;
inline bool ACKThranShortCert::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKThranShortCert::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKThranShortCert::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKThranShortCert::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ACKThranShortCert::username() const {
  return *username_;
}
inline void ACKThranShortCert::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ACKThranShortCert::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ACKThranShortCert::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranShortCert::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ACKThranShortCert::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .OGRoomInfo RoomList = 4;
inline int ACKThranShortCert::roomlist_size() const {
  return roomlist_.size();
}
inline void ACKThranShortCert::clear_roomlist() {
  roomlist_.Clear();
}
inline const ::OGRoomInfo& ACKThranShortCert::roomlist(int index) const {
  return roomlist_.Get(index);
}
inline ::OGRoomInfo* ACKThranShortCert::mutable_roomlist(int index) {
  return roomlist_.Mutable(index);
}
inline ::OGRoomInfo* ACKThranShortCert::add_roomlist() {
  return roomlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
ACKThranShortCert::roomlist() const {
  return roomlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
ACKThranShortCert::mutable_roomlist() {
  return &roomlist_;
}

// repeated .OGRoomInfo MatchRoomList = 5;
inline int ACKThranShortCert::matchroomlist_size() const {
  return matchroomlist_.size();
}
inline void ACKThranShortCert::clear_matchroomlist() {
  matchroomlist_.Clear();
}
inline const ::OGRoomInfo& ACKThranShortCert::matchroomlist(int index) const {
  return matchroomlist_.Get(index);
}
inline ::OGRoomInfo* ACKThranShortCert::mutable_matchroomlist(int index) {
  return matchroomlist_.Mutable(index);
}
inline ::OGRoomInfo* ACKThranShortCert::add_matchroomlist() {
  return matchroomlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
ACKThranShortCert::matchroomlist() const {
  return matchroomlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
ACKThranShortCert::mutable_matchroomlist() {
  return &matchroomlist_;
}

// -------------------------------------------------------------------

// REQThranOpenId

// required bytes UserName = 1;
inline bool REQThranOpenId::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQThranOpenId::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQThranOpenId::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQThranOpenId::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& REQThranOpenId::username() const {
  return *username_;
}
inline void REQThranOpenId::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void REQThranOpenId::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void REQThranOpenId::set_username(const void* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranOpenId::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* REQThranOpenId::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string Pwd = 2;
inline bool REQThranOpenId::has_pwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQThranOpenId::set_has_pwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQThranOpenId::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQThranOpenId::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& REQThranOpenId::pwd() const {
  return *pwd_;
}
inline void REQThranOpenId::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void REQThranOpenId::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void REQThranOpenId::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranOpenId::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  return pwd_;
}
inline ::std::string* REQThranOpenId::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string type = 3;
inline bool REQThranOpenId::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQThranOpenId::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQThranOpenId::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQThranOpenId::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& REQThranOpenId::type() const {
  return *type_;
}
inline void REQThranOpenId::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void REQThranOpenId::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void REQThranOpenId::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranOpenId::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* REQThranOpenId::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string SecureID = 4;
inline bool REQThranOpenId::has_secureid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void REQThranOpenId::set_has_secureid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void REQThranOpenId::clear_has_secureid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void REQThranOpenId::clear_secureid() {
  if (secureid_ != &::google::protobuf::internal::kEmptyString) {
    secureid_->clear();
  }
  clear_has_secureid();
}
inline const ::std::string& REQThranOpenId::secureid() const {
  return *secureid_;
}
inline void REQThranOpenId::set_secureid(const ::std::string& value) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(value);
}
inline void REQThranOpenId::set_secureid(const char* value) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(value);
}
inline void REQThranOpenId::set_secureid(const char* value, size_t size) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranOpenId::mutable_secureid() {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  return secureid_;
}
inline ::std::string* REQThranOpenId::release_secureid() {
  clear_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secureid_;
    secureid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 ComeFromID = 5;
inline bool REQThranOpenId::has_comefromid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void REQThranOpenId::set_has_comefromid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void REQThranOpenId::clear_has_comefromid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void REQThranOpenId::clear_comefromid() {
  comefromid_ = 0;
  clear_has_comefromid();
}
inline ::google::protobuf::int32 REQThranOpenId::comefromid() const {
  return comefromid_;
}
inline void REQThranOpenId::set_comefromid(::google::protobuf::int32 value) {
  set_has_comefromid();
  comefromid_ = value;
}

// required string ChannelID = 6;
inline bool REQThranOpenId::has_channelid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void REQThranOpenId::set_has_channelid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void REQThranOpenId::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void REQThranOpenId::clear_channelid() {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    channelid_->clear();
  }
  clear_has_channelid();
}
inline const ::std::string& REQThranOpenId::channelid() const {
  return *channelid_;
}
inline void REQThranOpenId::set_channelid(const ::std::string& value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQThranOpenId::set_channelid(const char* value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQThranOpenId::set_channelid(const char* value, size_t size) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranOpenId::mutable_channelid() {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  return channelid_;
}
inline ::std::string* REQThranOpenId::release_channelid() {
  clear_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channelid_;
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 GameId = 7;
inline bool REQThranOpenId::has_gameid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void REQThranOpenId::set_has_gameid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void REQThranOpenId::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void REQThranOpenId::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 REQThranOpenId::gameid() const {
  return gameid_;
}
inline void REQThranOpenId::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional int32 VerifyId = 8;
inline bool REQThranOpenId::has_verifyid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void REQThranOpenId::set_has_verifyid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void REQThranOpenId::clear_has_verifyid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void REQThranOpenId::clear_verifyid() {
  verifyid_ = 0;
  clear_has_verifyid();
}
inline ::google::protobuf::int32 REQThranOpenId::verifyid() const {
  return verifyid_;
}
inline void REQThranOpenId::set_verifyid(::google::protobuf::int32 value) {
  set_has_verifyid();
  verifyid_ = value;
}

// optional string Ticket = 9;
inline bool REQThranOpenId::has_ticket() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void REQThranOpenId::set_has_ticket() {
  _has_bits_[0] |= 0x00000100u;
}
inline void REQThranOpenId::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void REQThranOpenId::clear_ticket() {
  if (ticket_ != &::google::protobuf::internal::kEmptyString) {
    ticket_->clear();
  }
  clear_has_ticket();
}
inline const ::std::string& REQThranOpenId::ticket() const {
  return *ticket_;
}
inline void REQThranOpenId::set_ticket(const ::std::string& value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void REQThranOpenId::set_ticket(const char* value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void REQThranOpenId::set_ticket(const char* value, size_t size) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranOpenId::mutable_ticket() {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  return ticket_;
}
inline ::std::string* REQThranOpenId::release_ticket() {
  clear_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ticket_;
    ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string token = 10;
inline bool REQThranOpenId::has_token() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void REQThranOpenId::set_has_token() {
  _has_bits_[0] |= 0x00000200u;
}
inline void REQThranOpenId::clear_has_token() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void REQThranOpenId::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& REQThranOpenId::token() const {
  return *token_;
}
inline void REQThranOpenId::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void REQThranOpenId::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void REQThranOpenId::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranOpenId::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* REQThranOpenId::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Thirdkey = 11;
inline bool REQThranOpenId::has_thirdkey() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void REQThranOpenId::set_has_thirdkey() {
  _has_bits_[0] |= 0x00000400u;
}
inline void REQThranOpenId::clear_has_thirdkey() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void REQThranOpenId::clear_thirdkey() {
  if (thirdkey_ != &::google::protobuf::internal::kEmptyString) {
    thirdkey_->clear();
  }
  clear_has_thirdkey();
}
inline const ::std::string& REQThranOpenId::thirdkey() const {
  return *thirdkey_;
}
inline void REQThranOpenId::set_thirdkey(const ::std::string& value) {
  set_has_thirdkey();
  if (thirdkey_ == &::google::protobuf::internal::kEmptyString) {
    thirdkey_ = new ::std::string;
  }
  thirdkey_->assign(value);
}
inline void REQThranOpenId::set_thirdkey(const char* value) {
  set_has_thirdkey();
  if (thirdkey_ == &::google::protobuf::internal::kEmptyString) {
    thirdkey_ = new ::std::string;
  }
  thirdkey_->assign(value);
}
inline void REQThranOpenId::set_thirdkey(const char* value, size_t size) {
  set_has_thirdkey();
  if (thirdkey_ == &::google::protobuf::internal::kEmptyString) {
    thirdkey_ = new ::std::string;
  }
  thirdkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranOpenId::mutable_thirdkey() {
  set_has_thirdkey();
  if (thirdkey_ == &::google::protobuf::internal::kEmptyString) {
    thirdkey_ = new ::std::string;
  }
  return thirdkey_;
}
inline ::std::string* REQThranOpenId::release_thirdkey() {
  clear_has_thirdkey();
  if (thirdkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = thirdkey_;
    thirdkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 RoomAdapte = 12 [default = 0];
inline bool REQThranOpenId::has_roomadapte() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void REQThranOpenId::set_has_roomadapte() {
  _has_bits_[0] |= 0x00000800u;
}
inline void REQThranOpenId::clear_has_roomadapte() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void REQThranOpenId::clear_roomadapte() {
  roomadapte_ = 0;
  clear_has_roomadapte();
}
inline ::google::protobuf::int32 REQThranOpenId::roomadapte() const {
  return roomadapte_;
}
inline void REQThranOpenId::set_roomadapte(::google::protobuf::int32 value) {
  set_has_roomadapte();
  roomadapte_ = value;
}

// optional string ThirdAppId = 13;
inline bool REQThranOpenId::has_thirdappid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void REQThranOpenId::set_has_thirdappid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void REQThranOpenId::clear_has_thirdappid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void REQThranOpenId::clear_thirdappid() {
  if (thirdappid_ != &::google::protobuf::internal::kEmptyString) {
    thirdappid_->clear();
  }
  clear_has_thirdappid();
}
inline const ::std::string& REQThranOpenId::thirdappid() const {
  return *thirdappid_;
}
inline void REQThranOpenId::set_thirdappid(const ::std::string& value) {
  set_has_thirdappid();
  if (thirdappid_ == &::google::protobuf::internal::kEmptyString) {
    thirdappid_ = new ::std::string;
  }
  thirdappid_->assign(value);
}
inline void REQThranOpenId::set_thirdappid(const char* value) {
  set_has_thirdappid();
  if (thirdappid_ == &::google::protobuf::internal::kEmptyString) {
    thirdappid_ = new ::std::string;
  }
  thirdappid_->assign(value);
}
inline void REQThranOpenId::set_thirdappid(const char* value, size_t size) {
  set_has_thirdappid();
  if (thirdappid_ == &::google::protobuf::internal::kEmptyString) {
    thirdappid_ = new ::std::string;
  }
  thirdappid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranOpenId::mutable_thirdappid() {
  set_has_thirdappid();
  if (thirdappid_ == &::google::protobuf::internal::kEmptyString) {
    thirdappid_ = new ::std::string;
  }
  return thirdappid_;
}
inline ::std::string* REQThranOpenId::release_thirdappid() {
  clear_has_thirdappid();
  if (thirdappid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = thirdappid_;
    thirdappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ACKThranOpenId

// required int32 AckResult = 1;
inline bool ACKThranOpenId::has_ackresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKThranOpenId::set_has_ackresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKThranOpenId::clear_has_ackresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKThranOpenId::clear_ackresult() {
  ackresult_ = 0;
  clear_has_ackresult();
}
inline ::google::protobuf::int32 ACKThranOpenId::ackresult() const {
  return ackresult_;
}
inline void ACKThranOpenId::set_ackresult(::google::protobuf::int32 value) {
  set_has_ackresult();
  ackresult_ = value;
}

// required bytes cert = 2;
inline bool ACKThranOpenId::has_cert() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKThranOpenId::set_has_cert() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKThranOpenId::clear_has_cert() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKThranOpenId::clear_cert() {
  if (cert_ != &::google::protobuf::internal::kEmptyString) {
    cert_->clear();
  }
  clear_has_cert();
}
inline const ::std::string& ACKThranOpenId::cert() const {
  return *cert_;
}
inline void ACKThranOpenId::set_cert(const ::std::string& value) {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    cert_ = new ::std::string;
  }
  cert_->assign(value);
}
inline void ACKThranOpenId::set_cert(const char* value) {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    cert_ = new ::std::string;
  }
  cert_->assign(value);
}
inline void ACKThranOpenId::set_cert(const void* value, size_t size) {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    cert_ = new ::std::string;
  }
  cert_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranOpenId::mutable_cert() {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    cert_ = new ::std::string;
  }
  return cert_;
}
inline ::std::string* ACKThranOpenId::release_cert() {
  clear_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cert_;
    cert_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes UserName = 3;
inline bool ACKThranOpenId::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKThranOpenId::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKThranOpenId::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKThranOpenId::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ACKThranOpenId::username() const {
  return *username_;
}
inline void ACKThranOpenId::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ACKThranOpenId::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ACKThranOpenId::set_username(const void* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranOpenId::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ACKThranOpenId::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes RoleName = 4;
inline bool ACKThranOpenId::has_rolename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACKThranOpenId::set_has_rolename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACKThranOpenId::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACKThranOpenId::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& ACKThranOpenId::rolename() const {
  return *rolename_;
}
inline void ACKThranOpenId::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void ACKThranOpenId::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void ACKThranOpenId::set_rolename(const void* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranOpenId::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* ACKThranOpenId::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 YuanBaoCnt = 5;
inline bool ACKThranOpenId::has_yuanbaocnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ACKThranOpenId::set_has_yuanbaocnt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ACKThranOpenId::clear_has_yuanbaocnt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ACKThranOpenId::clear_yuanbaocnt() {
  yuanbaocnt_ = 0;
  clear_has_yuanbaocnt();
}
inline ::google::protobuf::int32 ACKThranOpenId::yuanbaocnt() const {
  return yuanbaocnt_;
}
inline void ACKThranOpenId::set_yuanbaocnt(::google::protobuf::int32 value) {
  set_has_yuanbaocnt();
  yuanbaocnt_ = value;
}

// required int64 CoinCnt = 6;
inline bool ACKThranOpenId::has_coincnt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ACKThranOpenId::set_has_coincnt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ACKThranOpenId::clear_has_coincnt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ACKThranOpenId::clear_coincnt() {
  coincnt_ = GOOGLE_LONGLONG(0);
  clear_has_coincnt();
}
inline ::google::protobuf::int64 ACKThranOpenId::coincnt() const {
  return coincnt_;
}
inline void ACKThranOpenId::set_coincnt(::google::protobuf::int64 value) {
  set_has_coincnt();
  coincnt_ = value;
}

// repeated .OGRoomInfo RoomList = 7;
inline int ACKThranOpenId::roomlist_size() const {
  return roomlist_.size();
}
inline void ACKThranOpenId::clear_roomlist() {
  roomlist_.Clear();
}
inline const ::OGRoomInfo& ACKThranOpenId::roomlist(int index) const {
  return roomlist_.Get(index);
}
inline ::OGRoomInfo* ACKThranOpenId::mutable_roomlist(int index) {
  return roomlist_.Mutable(index);
}
inline ::OGRoomInfo* ACKThranOpenId::add_roomlist() {
  return roomlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
ACKThranOpenId::roomlist() const {
  return roomlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
ACKThranOpenId::mutable_roomlist() {
  return &roomlist_;
}

// repeated .OGRoomInfo MatchRoomList = 8;
inline int ACKThranOpenId::matchroomlist_size() const {
  return matchroomlist_.size();
}
inline void ACKThranOpenId::clear_matchroomlist() {
  matchroomlist_.Clear();
}
inline const ::OGRoomInfo& ACKThranOpenId::matchroomlist(int index) const {
  return matchroomlist_.Get(index);
}
inline ::OGRoomInfo* ACKThranOpenId::mutable_matchroomlist(int index) {
  return matchroomlist_.Mutable(index);
}
inline ::OGRoomInfo* ACKThranOpenId::add_matchroomlist() {
  return matchroomlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
ACKThranOpenId::matchroomlist() const {
  return matchroomlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
ACKThranOpenId::mutable_matchroomlist() {
  return &matchroomlist_;
}

// required int32 LoginId = 9;
inline bool ACKThranOpenId::has_loginid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ACKThranOpenId::set_has_loginid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ACKThranOpenId::clear_has_loginid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ACKThranOpenId::clear_loginid() {
  loginid_ = 0;
  clear_has_loginid();
}
inline ::google::protobuf::int32 ACKThranOpenId::loginid() const {
  return loginid_;
}
inline void ACKThranOpenId::set_loginid(::google::protobuf::int32 value) {
  set_has_loginid();
  loginid_ = value;
}

// optional bytes CertNoRole = 10;
inline bool ACKThranOpenId::has_certnorole() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ACKThranOpenId::set_has_certnorole() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ACKThranOpenId::clear_has_certnorole() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ACKThranOpenId::clear_certnorole() {
  if (certnorole_ != &::google::protobuf::internal::kEmptyString) {
    certnorole_->clear();
  }
  clear_has_certnorole();
}
inline const ::std::string& ACKThranOpenId::certnorole() const {
  return *certnorole_;
}
inline void ACKThranOpenId::set_certnorole(const ::std::string& value) {
  set_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    certnorole_ = new ::std::string;
  }
  certnorole_->assign(value);
}
inline void ACKThranOpenId::set_certnorole(const char* value) {
  set_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    certnorole_ = new ::std::string;
  }
  certnorole_->assign(value);
}
inline void ACKThranOpenId::set_certnorole(const void* value, size_t size) {
  set_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    certnorole_ = new ::std::string;
  }
  certnorole_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranOpenId::mutable_certnorole() {
  set_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    certnorole_ = new ::std::string;
  }
  return certnorole_;
}
inline ::std::string* ACKThranOpenId::release_certnorole() {
  clear_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = certnorole_;
    certnorole_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated int32 AchvId = 11;
inline int ACKThranOpenId::achvid_size() const {
  return achvid_.size();
}
inline void ACKThranOpenId::clear_achvid() {
  achvid_.Clear();
}
inline ::google::protobuf::int32 ACKThranOpenId::achvid(int index) const {
  return achvid_.Get(index);
}
inline void ACKThranOpenId::set_achvid(int index, ::google::protobuf::int32 value) {
  achvid_.Set(index, value);
}
inline void ACKThranOpenId::add_achvid(::google::protobuf::int32 value) {
  achvid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ACKThranOpenId::achvid() const {
  return achvid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ACKThranOpenId::mutable_achvid() {
  return &achvid_;
}

// -------------------------------------------------------------------

// REQSinaGame

// required string Thirdkey = 1;
inline bool REQSinaGame::has_thirdkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQSinaGame::set_has_thirdkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQSinaGame::clear_has_thirdkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQSinaGame::clear_thirdkey() {
  if (thirdkey_ != &::google::protobuf::internal::kEmptyString) {
    thirdkey_->clear();
  }
  clear_has_thirdkey();
}
inline const ::std::string& REQSinaGame::thirdkey() const {
  return *thirdkey_;
}
inline void REQSinaGame::set_thirdkey(const ::std::string& value) {
  set_has_thirdkey();
  if (thirdkey_ == &::google::protobuf::internal::kEmptyString) {
    thirdkey_ = new ::std::string;
  }
  thirdkey_->assign(value);
}
inline void REQSinaGame::set_thirdkey(const char* value) {
  set_has_thirdkey();
  if (thirdkey_ == &::google::protobuf::internal::kEmptyString) {
    thirdkey_ = new ::std::string;
  }
  thirdkey_->assign(value);
}
inline void REQSinaGame::set_thirdkey(const char* value, size_t size) {
  set_has_thirdkey();
  if (thirdkey_ == &::google::protobuf::internal::kEmptyString) {
    thirdkey_ = new ::std::string;
  }
  thirdkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQSinaGame::mutable_thirdkey() {
  set_has_thirdkey();
  if (thirdkey_ == &::google::protobuf::internal::kEmptyString) {
    thirdkey_ = new ::std::string;
  }
  return thirdkey_;
}
inline ::std::string* REQSinaGame::release_thirdkey() {
  clear_has_thirdkey();
  if (thirdkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = thirdkey_;
    thirdkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .SinaApiInfo InfoList = 2;
inline int REQSinaGame::infolist_size() const {
  return infolist_.size();
}
inline void REQSinaGame::clear_infolist() {
  infolist_.Clear();
}
inline const ::SinaApiInfo& REQSinaGame::infolist(int index) const {
  return infolist_.Get(index);
}
inline ::SinaApiInfo* REQSinaGame::mutable_infolist(int index) {
  return infolist_.Mutable(index);
}
inline ::SinaApiInfo* REQSinaGame::add_infolist() {
  return infolist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SinaApiInfo >&
REQSinaGame::infolist() const {
  return infolist_;
}
inline ::google::protobuf::RepeatedPtrField< ::SinaApiInfo >*
REQSinaGame::mutable_infolist() {
  return &infolist_;
}

// required string SecureID = 4;
inline bool REQSinaGame::has_secureid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQSinaGame::set_has_secureid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQSinaGame::clear_has_secureid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQSinaGame::clear_secureid() {
  if (secureid_ != &::google::protobuf::internal::kEmptyString) {
    secureid_->clear();
  }
  clear_has_secureid();
}
inline const ::std::string& REQSinaGame::secureid() const {
  return *secureid_;
}
inline void REQSinaGame::set_secureid(const ::std::string& value) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(value);
}
inline void REQSinaGame::set_secureid(const char* value) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(value);
}
inline void REQSinaGame::set_secureid(const char* value, size_t size) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQSinaGame::mutable_secureid() {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  return secureid_;
}
inline ::std::string* REQSinaGame::release_secureid() {
  clear_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secureid_;
    secureid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 ComeFromID = 5;
inline bool REQSinaGame::has_comefromid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void REQSinaGame::set_has_comefromid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void REQSinaGame::clear_has_comefromid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void REQSinaGame::clear_comefromid() {
  comefromid_ = 0;
  clear_has_comefromid();
}
inline ::google::protobuf::int32 REQSinaGame::comefromid() const {
  return comefromid_;
}
inline void REQSinaGame::set_comefromid(::google::protobuf::int32 value) {
  set_has_comefromid();
  comefromid_ = value;
}

// required string ChannelID = 6;
inline bool REQSinaGame::has_channelid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void REQSinaGame::set_has_channelid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void REQSinaGame::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void REQSinaGame::clear_channelid() {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    channelid_->clear();
  }
  clear_has_channelid();
}
inline const ::std::string& REQSinaGame::channelid() const {
  return *channelid_;
}
inline void REQSinaGame::set_channelid(const ::std::string& value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQSinaGame::set_channelid(const char* value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQSinaGame::set_channelid(const char* value, size_t size) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQSinaGame::mutable_channelid() {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  return channelid_;
}
inline ::std::string* REQSinaGame::release_channelid() {
  clear_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channelid_;
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 GameId = 7;
inline bool REQSinaGame::has_gameid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void REQSinaGame::set_has_gameid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void REQSinaGame::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void REQSinaGame::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 REQSinaGame::gameid() const {
  return gameid_;
}
inline void REQSinaGame::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// ACKSinaGame

// required int32 AckResult = 1;
inline bool ACKSinaGame::has_ackresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKSinaGame::set_has_ackresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKSinaGame::clear_has_ackresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKSinaGame::clear_ackresult() {
  ackresult_ = 0;
  clear_has_ackresult();
}
inline ::google::protobuf::int32 ACKSinaGame::ackresult() const {
  return ackresult_;
}
inline void ACKSinaGame::set_ackresult(::google::protobuf::int32 value) {
  set_has_ackresult();
  ackresult_ = value;
}

// repeated .SinaApiRet RetList = 2;
inline int ACKSinaGame::retlist_size() const {
  return retlist_.size();
}
inline void ACKSinaGame::clear_retlist() {
  retlist_.Clear();
}
inline const ::SinaApiRet& ACKSinaGame::retlist(int index) const {
  return retlist_.Get(index);
}
inline ::SinaApiRet* ACKSinaGame::mutable_retlist(int index) {
  return retlist_.Mutable(index);
}
inline ::SinaApiRet* ACKSinaGame::add_retlist() {
  return retlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SinaApiRet >&
ACKSinaGame::retlist() const {
  return retlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::SinaApiRet >*
ACKSinaGame::mutable_retlist() {
  return &retlist_;
}

// -------------------------------------------------------------------

// REQWeiBo

// required bytes UserName = 1;
inline bool REQWeiBo::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQWeiBo::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQWeiBo::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQWeiBo::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& REQWeiBo::username() const {
  return *username_;
}
inline void REQWeiBo::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void REQWeiBo::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void REQWeiBo::set_username(const void* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQWeiBo::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* REQWeiBo::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string Pwd = 2;
inline bool REQWeiBo::has_pwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQWeiBo::set_has_pwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQWeiBo::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQWeiBo::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& REQWeiBo::pwd() const {
  return *pwd_;
}
inline void REQWeiBo::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void REQWeiBo::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void REQWeiBo::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQWeiBo::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  return pwd_;
}
inline ::std::string* REQWeiBo::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string type = 3;
inline bool REQWeiBo::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQWeiBo::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQWeiBo::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQWeiBo::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& REQWeiBo::type() const {
  return *type_;
}
inline void REQWeiBo::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void REQWeiBo::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void REQWeiBo::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQWeiBo::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* REQWeiBo::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string SecureID = 4;
inline bool REQWeiBo::has_secureid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void REQWeiBo::set_has_secureid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void REQWeiBo::clear_has_secureid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void REQWeiBo::clear_secureid() {
  if (secureid_ != &::google::protobuf::internal::kEmptyString) {
    secureid_->clear();
  }
  clear_has_secureid();
}
inline const ::std::string& REQWeiBo::secureid() const {
  return *secureid_;
}
inline void REQWeiBo::set_secureid(const ::std::string& value) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(value);
}
inline void REQWeiBo::set_secureid(const char* value) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(value);
}
inline void REQWeiBo::set_secureid(const char* value, size_t size) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQWeiBo::mutable_secureid() {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  return secureid_;
}
inline ::std::string* REQWeiBo::release_secureid() {
  clear_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secureid_;
    secureid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 ComeFromID = 5;
inline bool REQWeiBo::has_comefromid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void REQWeiBo::set_has_comefromid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void REQWeiBo::clear_has_comefromid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void REQWeiBo::clear_comefromid() {
  comefromid_ = 0;
  clear_has_comefromid();
}
inline ::google::protobuf::int32 REQWeiBo::comefromid() const {
  return comefromid_;
}
inline void REQWeiBo::set_comefromid(::google::protobuf::int32 value) {
  set_has_comefromid();
  comefromid_ = value;
}

// required string ChannelID = 6;
inline bool REQWeiBo::has_channelid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void REQWeiBo::set_has_channelid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void REQWeiBo::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void REQWeiBo::clear_channelid() {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    channelid_->clear();
  }
  clear_has_channelid();
}
inline const ::std::string& REQWeiBo::channelid() const {
  return *channelid_;
}
inline void REQWeiBo::set_channelid(const ::std::string& value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQWeiBo::set_channelid(const char* value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQWeiBo::set_channelid(const char* value, size_t size) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQWeiBo::mutable_channelid() {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  return channelid_;
}
inline ::std::string* REQWeiBo::release_channelid() {
  clear_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channelid_;
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 GameId = 7;
inline bool REQWeiBo::has_gameid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void REQWeiBo::set_has_gameid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void REQWeiBo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void REQWeiBo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 REQWeiBo::gameid() const {
  return gameid_;
}
inline void REQWeiBo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required string token = 8;
inline bool REQWeiBo::has_token() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void REQWeiBo::set_has_token() {
  _has_bits_[0] |= 0x00000080u;
}
inline void REQWeiBo::clear_has_token() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void REQWeiBo::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& REQWeiBo::token() const {
  return *token_;
}
inline void REQWeiBo::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void REQWeiBo::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void REQWeiBo::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQWeiBo::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* REQWeiBo::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes wbMsg = 9;
inline bool REQWeiBo::has_wbmsg() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void REQWeiBo::set_has_wbmsg() {
  _has_bits_[0] |= 0x00000100u;
}
inline void REQWeiBo::clear_has_wbmsg() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void REQWeiBo::clear_wbmsg() {
  if (wbmsg_ != &::google::protobuf::internal::kEmptyString) {
    wbmsg_->clear();
  }
  clear_has_wbmsg();
}
inline const ::std::string& REQWeiBo::wbmsg() const {
  return *wbmsg_;
}
inline void REQWeiBo::set_wbmsg(const ::std::string& value) {
  set_has_wbmsg();
  if (wbmsg_ == &::google::protobuf::internal::kEmptyString) {
    wbmsg_ = new ::std::string;
  }
  wbmsg_->assign(value);
}
inline void REQWeiBo::set_wbmsg(const char* value) {
  set_has_wbmsg();
  if (wbmsg_ == &::google::protobuf::internal::kEmptyString) {
    wbmsg_ = new ::std::string;
  }
  wbmsg_->assign(value);
}
inline void REQWeiBo::set_wbmsg(const void* value, size_t size) {
  set_has_wbmsg();
  if (wbmsg_ == &::google::protobuf::internal::kEmptyString) {
    wbmsg_ = new ::std::string;
  }
  wbmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQWeiBo::mutable_wbmsg() {
  set_has_wbmsg();
  if (wbmsg_ == &::google::protobuf::internal::kEmptyString) {
    wbmsg_ = new ::std::string;
  }
  return wbmsg_;
}
inline ::std::string* REQWeiBo::release_wbmsg() {
  clear_has_wbmsg();
  if (wbmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wbmsg_;
    wbmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes wbPic = 10;
inline bool REQWeiBo::has_wbpic() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void REQWeiBo::set_has_wbpic() {
  _has_bits_[0] |= 0x00000200u;
}
inline void REQWeiBo::clear_has_wbpic() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void REQWeiBo::clear_wbpic() {
  if (wbpic_ != &::google::protobuf::internal::kEmptyString) {
    wbpic_->clear();
  }
  clear_has_wbpic();
}
inline const ::std::string& REQWeiBo::wbpic() const {
  return *wbpic_;
}
inline void REQWeiBo::set_wbpic(const ::std::string& value) {
  set_has_wbpic();
  if (wbpic_ == &::google::protobuf::internal::kEmptyString) {
    wbpic_ = new ::std::string;
  }
  wbpic_->assign(value);
}
inline void REQWeiBo::set_wbpic(const char* value) {
  set_has_wbpic();
  if (wbpic_ == &::google::protobuf::internal::kEmptyString) {
    wbpic_ = new ::std::string;
  }
  wbpic_->assign(value);
}
inline void REQWeiBo::set_wbpic(const void* value, size_t size) {
  set_has_wbpic();
  if (wbpic_ == &::google::protobuf::internal::kEmptyString) {
    wbpic_ = new ::std::string;
  }
  wbpic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQWeiBo::mutable_wbpic() {
  set_has_wbpic();
  if (wbpic_ == &::google::protobuf::internal::kEmptyString) {
    wbpic_ = new ::std::string;
  }
  return wbpic_;
}
inline ::std::string* REQWeiBo::release_wbpic() {
  clear_has_wbpic();
  if (wbpic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wbpic_;
    wbpic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ACKWeiBo

// required int32 AckResult = 1;
inline bool ACKWeiBo::has_ackresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKWeiBo::set_has_ackresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKWeiBo::clear_has_ackresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKWeiBo::clear_ackresult() {
  ackresult_ = 0;
  clear_has_ackresult();
}
inline ::google::protobuf::int32 ACKWeiBo::ackresult() const {
  return ackresult_;
}
inline void ACKWeiBo::set_ackresult(::google::protobuf::int32 value) {
  set_has_ackresult();
  ackresult_ = value;
}

// -------------------------------------------------------------------

// REQThranExit

// required int32 LoginId = 1;
inline bool REQThranExit::has_loginid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQThranExit::set_has_loginid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQThranExit::clear_has_loginid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQThranExit::clear_loginid() {
  loginid_ = 0;
  clear_has_loginid();
}
inline ::google::protobuf::int32 REQThranExit::loginid() const {
  return loginid_;
}
inline void REQThranExit::set_loginid(::google::protobuf::int32 value) {
  set_has_loginid();
  loginid_ = value;
}

// optional int32 ExitType = 2;
inline bool REQThranExit::has_exittype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQThranExit::set_has_exittype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQThranExit::clear_has_exittype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQThranExit::clear_exittype() {
  exittype_ = 0;
  clear_has_exittype();
}
inline ::google::protobuf::int32 REQThranExit::exittype() const {
  return exittype_;
}
inline void REQThranExit::set_exittype(::google::protobuf::int32 value) {
  set_has_exittype();
  exittype_ = value;
}

// optional string ExitMsg = 3;
inline bool REQThranExit::has_exitmsg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQThranExit::set_has_exitmsg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQThranExit::clear_has_exitmsg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQThranExit::clear_exitmsg() {
  if (exitmsg_ != &::google::protobuf::internal::kEmptyString) {
    exitmsg_->clear();
  }
  clear_has_exitmsg();
}
inline const ::std::string& REQThranExit::exitmsg() const {
  return *exitmsg_;
}
inline void REQThranExit::set_exitmsg(const ::std::string& value) {
  set_has_exitmsg();
  if (exitmsg_ == &::google::protobuf::internal::kEmptyString) {
    exitmsg_ = new ::std::string;
  }
  exitmsg_->assign(value);
}
inline void REQThranExit::set_exitmsg(const char* value) {
  set_has_exitmsg();
  if (exitmsg_ == &::google::protobuf::internal::kEmptyString) {
    exitmsg_ = new ::std::string;
  }
  exitmsg_->assign(value);
}
inline void REQThranExit::set_exitmsg(const char* value, size_t size) {
  set_has_exitmsg();
  if (exitmsg_ == &::google::protobuf::internal::kEmptyString) {
    exitmsg_ = new ::std::string;
  }
  exitmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranExit::mutable_exitmsg() {
  set_has_exitmsg();
  if (exitmsg_ == &::google::protobuf::internal::kEmptyString) {
    exitmsg_ = new ::std::string;
  }
  return exitmsg_;
}
inline ::std::string* REQThranExit::release_exitmsg() {
  clear_has_exitmsg();
  if (exitmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exitmsg_;
    exitmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// REQThranGameVersion

// required int32 CurVersion = 1;
inline bool REQThranGameVersion::has_curversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQThranGameVersion::set_has_curversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQThranGameVersion::clear_has_curversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQThranGameVersion::clear_curversion() {
  curversion_ = 0;
  clear_has_curversion();
}
inline ::google::protobuf::int32 REQThranGameVersion::curversion() const {
  return curversion_;
}
inline void REQThranGameVersion::set_curversion(::google::protobuf::int32 value) {
  set_has_curversion();
  curversion_ = value;
}

// required int32 GameId = 2;
inline bool REQThranGameVersion::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQThranGameVersion::set_has_gameid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQThranGameVersion::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQThranGameVersion::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 REQThranGameVersion::gameid() const {
  return gameid_;
}
inline void REQThranGameVersion::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 ComeFromID = 3;
inline bool REQThranGameVersion::has_comefromid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQThranGameVersion::set_has_comefromid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQThranGameVersion::clear_has_comefromid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQThranGameVersion::clear_comefromid() {
  comefromid_ = 0;
  clear_has_comefromid();
}
inline ::google::protobuf::int32 REQThranGameVersion::comefromid() const {
  return comefromid_;
}
inline void REQThranGameVersion::set_comefromid(::google::protobuf::int32 value) {
  set_has_comefromid();
  comefromid_ = value;
}

// required string ResolutionID = 4;
inline bool REQThranGameVersion::has_resolutionid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void REQThranGameVersion::set_has_resolutionid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void REQThranGameVersion::clear_has_resolutionid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void REQThranGameVersion::clear_resolutionid() {
  if (resolutionid_ != &::google::protobuf::internal::kEmptyString) {
    resolutionid_->clear();
  }
  clear_has_resolutionid();
}
inline const ::std::string& REQThranGameVersion::resolutionid() const {
  return *resolutionid_;
}
inline void REQThranGameVersion::set_resolutionid(const ::std::string& value) {
  set_has_resolutionid();
  if (resolutionid_ == &::google::protobuf::internal::kEmptyString) {
    resolutionid_ = new ::std::string;
  }
  resolutionid_->assign(value);
}
inline void REQThranGameVersion::set_resolutionid(const char* value) {
  set_has_resolutionid();
  if (resolutionid_ == &::google::protobuf::internal::kEmptyString) {
    resolutionid_ = new ::std::string;
  }
  resolutionid_->assign(value);
}
inline void REQThranGameVersion::set_resolutionid(const char* value, size_t size) {
  set_has_resolutionid();
  if (resolutionid_ == &::google::protobuf::internal::kEmptyString) {
    resolutionid_ = new ::std::string;
  }
  resolutionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranGameVersion::mutable_resolutionid() {
  set_has_resolutionid();
  if (resolutionid_ == &::google::protobuf::internal::kEmptyString) {
    resolutionid_ = new ::std::string;
  }
  return resolutionid_;
}
inline ::std::string* REQThranGameVersion::release_resolutionid() {
  clear_has_resolutionid();
  if (resolutionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resolutionid_;
    resolutionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ChannelID = 5;
inline bool REQThranGameVersion::has_channelid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void REQThranGameVersion::set_has_channelid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void REQThranGameVersion::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void REQThranGameVersion::clear_channelid() {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    channelid_->clear();
  }
  clear_has_channelid();
}
inline const ::std::string& REQThranGameVersion::channelid() const {
  return *channelid_;
}
inline void REQThranGameVersion::set_channelid(const ::std::string& value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQThranGameVersion::set_channelid(const char* value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQThranGameVersion::set_channelid(const char* value, size_t size) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranGameVersion::mutable_channelid() {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  return channelid_;
}
inline ::std::string* REQThranGameVersion::release_channelid() {
  clear_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channelid_;
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string LanguageID = 6;
inline bool REQThranGameVersion::has_languageid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void REQThranGameVersion::set_has_languageid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void REQThranGameVersion::clear_has_languageid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void REQThranGameVersion::clear_languageid() {
  if (languageid_ != &::google::protobuf::internal::kEmptyString) {
    languageid_->clear();
  }
  clear_has_languageid();
}
inline const ::std::string& REQThranGameVersion::languageid() const {
  return *languageid_;
}
inline void REQThranGameVersion::set_languageid(const ::std::string& value) {
  set_has_languageid();
  if (languageid_ == &::google::protobuf::internal::kEmptyString) {
    languageid_ = new ::std::string;
  }
  languageid_->assign(value);
}
inline void REQThranGameVersion::set_languageid(const char* value) {
  set_has_languageid();
  if (languageid_ == &::google::protobuf::internal::kEmptyString) {
    languageid_ = new ::std::string;
  }
  languageid_->assign(value);
}
inline void REQThranGameVersion::set_languageid(const char* value, size_t size) {
  set_has_languageid();
  if (languageid_ == &::google::protobuf::internal::kEmptyString) {
    languageid_ = new ::std::string;
  }
  languageid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranGameVersion::mutable_languageid() {
  set_has_languageid();
  if (languageid_ == &::google::protobuf::internal::kEmptyString) {
    languageid_ = new ::std::string;
  }
  return languageid_;
}
inline ::std::string* REQThranGameVersion::release_languageid() {
  clear_has_languageid();
  if (languageid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = languageid_;
    languageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 smallVersion = 7;
inline bool REQThranGameVersion::has_smallversion() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void REQThranGameVersion::set_has_smallversion() {
  _has_bits_[0] |= 0x00000040u;
}
inline void REQThranGameVersion::clear_has_smallversion() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void REQThranGameVersion::clear_smallversion() {
  smallversion_ = 0;
  clear_has_smallversion();
}
inline ::google::protobuf::int32 REQThranGameVersion::smallversion() const {
  return smallversion_;
}
inline void REQThranGameVersion::set_smallversion(::google::protobuf::int32 value) {
  set_has_smallversion();
  smallversion_ = value;
}

// optional string ClientType = 8;
inline bool REQThranGameVersion::has_clienttype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void REQThranGameVersion::set_has_clienttype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void REQThranGameVersion::clear_has_clienttype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void REQThranGameVersion::clear_clienttype() {
  if (clienttype_ != &::google::protobuf::internal::kEmptyString) {
    clienttype_->clear();
  }
  clear_has_clienttype();
}
inline const ::std::string& REQThranGameVersion::clienttype() const {
  return *clienttype_;
}
inline void REQThranGameVersion::set_clienttype(const ::std::string& value) {
  set_has_clienttype();
  if (clienttype_ == &::google::protobuf::internal::kEmptyString) {
    clienttype_ = new ::std::string;
  }
  clienttype_->assign(value);
}
inline void REQThranGameVersion::set_clienttype(const char* value) {
  set_has_clienttype();
  if (clienttype_ == &::google::protobuf::internal::kEmptyString) {
    clienttype_ = new ::std::string;
  }
  clienttype_->assign(value);
}
inline void REQThranGameVersion::set_clienttype(const char* value, size_t size) {
  set_has_clienttype();
  if (clienttype_ == &::google::protobuf::internal::kEmptyString) {
    clienttype_ = new ::std::string;
  }
  clienttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranGameVersion::mutable_clienttype() {
  set_has_clienttype();
  if (clienttype_ == &::google::protobuf::internal::kEmptyString) {
    clienttype_ = new ::std::string;
  }
  return clienttype_;
}
inline ::std::string* REQThranGameVersion::release_clienttype() {
  clear_has_clienttype();
  if (clienttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clienttype_;
    clienttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ScreenSize = 9;
inline bool REQThranGameVersion::has_screensize() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void REQThranGameVersion::set_has_screensize() {
  _has_bits_[0] |= 0x00000100u;
}
inline void REQThranGameVersion::clear_has_screensize() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void REQThranGameVersion::clear_screensize() {
  if (screensize_ != &::google::protobuf::internal::kEmptyString) {
    screensize_->clear();
  }
  clear_has_screensize();
}
inline const ::std::string& REQThranGameVersion::screensize() const {
  return *screensize_;
}
inline void REQThranGameVersion::set_screensize(const ::std::string& value) {
  set_has_screensize();
  if (screensize_ == &::google::protobuf::internal::kEmptyString) {
    screensize_ = new ::std::string;
  }
  screensize_->assign(value);
}
inline void REQThranGameVersion::set_screensize(const char* value) {
  set_has_screensize();
  if (screensize_ == &::google::protobuf::internal::kEmptyString) {
    screensize_ = new ::std::string;
  }
  screensize_->assign(value);
}
inline void REQThranGameVersion::set_screensize(const char* value, size_t size) {
  set_has_screensize();
  if (screensize_ == &::google::protobuf::internal::kEmptyString) {
    screensize_ = new ::std::string;
  }
  screensize_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranGameVersion::mutable_screensize() {
  set_has_screensize();
  if (screensize_ == &::google::protobuf::internal::kEmptyString) {
    screensize_ = new ::std::string;
  }
  return screensize_;
}
inline ::std::string* REQThranGameVersion::release_screensize() {
  clear_has_screensize();
  if (screensize_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = screensize_;
    screensize_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 RoomAdapte = 10 [default = 0];
inline bool REQThranGameVersion::has_roomadapte() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void REQThranGameVersion::set_has_roomadapte() {
  _has_bits_[0] |= 0x00000200u;
}
inline void REQThranGameVersion::clear_has_roomadapte() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void REQThranGameVersion::clear_roomadapte() {
  roomadapte_ = 0;
  clear_has_roomadapte();
}
inline ::google::protobuf::int32 REQThranGameVersion::roomadapte() const {
  return roomadapte_;
}
inline void REQThranGameVersion::set_roomadapte(::google::protobuf::int32 value) {
  set_has_roomadapte();
  roomadapte_ = value;
}

// -------------------------------------------------------------------

// ACKThranGameVersion

// required int32 AckResult = 1;
inline bool ACKThranGameVersion::has_ackresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKThranGameVersion::set_has_ackresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKThranGameVersion::clear_has_ackresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKThranGameVersion::clear_ackresult() {
  ackresult_ = 0;
  clear_has_ackresult();
}
inline ::google::protobuf::int32 ACKThranGameVersion::ackresult() const {
  return ackresult_;
}
inline void ACKThranGameVersion::set_ackresult(::google::protobuf::int32 value) {
  set_has_ackresult();
  ackresult_ = value;
}

// required string PlayEnable = 2;
inline bool ACKThranGameVersion::has_playenable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKThranGameVersion::set_has_playenable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKThranGameVersion::clear_has_playenable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKThranGameVersion::clear_playenable() {
  if (playenable_ != &::google::protobuf::internal::kEmptyString) {
    playenable_->clear();
  }
  clear_has_playenable();
}
inline const ::std::string& ACKThranGameVersion::playenable() const {
  return *playenable_;
}
inline void ACKThranGameVersion::set_playenable(const ::std::string& value) {
  set_has_playenable();
  if (playenable_ == &::google::protobuf::internal::kEmptyString) {
    playenable_ = new ::std::string;
  }
  playenable_->assign(value);
}
inline void ACKThranGameVersion::set_playenable(const char* value) {
  set_has_playenable();
  if (playenable_ == &::google::protobuf::internal::kEmptyString) {
    playenable_ = new ::std::string;
  }
  playenable_->assign(value);
}
inline void ACKThranGameVersion::set_playenable(const char* value, size_t size) {
  set_has_playenable();
  if (playenable_ == &::google::protobuf::internal::kEmptyString) {
    playenable_ = new ::std::string;
  }
  playenable_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranGameVersion::mutable_playenable() {
  set_has_playenable();
  if (playenable_ == &::google::protobuf::internal::kEmptyString) {
    playenable_ = new ::std::string;
  }
  return playenable_;
}
inline ::std::string* ACKThranGameVersion::release_playenable() {
  clear_has_playenable();
  if (playenable_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playenable_;
    playenable_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string DownloadUrl = 3;
inline bool ACKThranGameVersion::has_downloadurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKThranGameVersion::set_has_downloadurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKThranGameVersion::clear_has_downloadurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKThranGameVersion::clear_downloadurl() {
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    downloadurl_->clear();
  }
  clear_has_downloadurl();
}
inline const ::std::string& ACKThranGameVersion::downloadurl() const {
  return *downloadurl_;
}
inline void ACKThranGameVersion::set_downloadurl(const ::std::string& value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void ACKThranGameVersion::set_downloadurl(const char* value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void ACKThranGameVersion::set_downloadurl(const char* value, size_t size) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranGameVersion::mutable_downloadurl() {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  return downloadurl_;
}
inline ::std::string* ACKThranGameVersion::release_downloadurl() {
  clear_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = downloadurl_;
    downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string GameServerIp = 4;
inline bool ACKThranGameVersion::has_gameserverip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACKThranGameVersion::set_has_gameserverip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACKThranGameVersion::clear_has_gameserverip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACKThranGameVersion::clear_gameserverip() {
  if (gameserverip_ != &::google::protobuf::internal::kEmptyString) {
    gameserverip_->clear();
  }
  clear_has_gameserverip();
}
inline const ::std::string& ACKThranGameVersion::gameserverip() const {
  return *gameserverip_;
}
inline void ACKThranGameVersion::set_gameserverip(const ::std::string& value) {
  set_has_gameserverip();
  if (gameserverip_ == &::google::protobuf::internal::kEmptyString) {
    gameserverip_ = new ::std::string;
  }
  gameserverip_->assign(value);
}
inline void ACKThranGameVersion::set_gameserverip(const char* value) {
  set_has_gameserverip();
  if (gameserverip_ == &::google::protobuf::internal::kEmptyString) {
    gameserverip_ = new ::std::string;
  }
  gameserverip_->assign(value);
}
inline void ACKThranGameVersion::set_gameserverip(const char* value, size_t size) {
  set_has_gameserverip();
  if (gameserverip_ == &::google::protobuf::internal::kEmptyString) {
    gameserverip_ = new ::std::string;
  }
  gameserverip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranGameVersion::mutable_gameserverip() {
  set_has_gameserverip();
  if (gameserverip_ == &::google::protobuf::internal::kEmptyString) {
    gameserverip_ = new ::std::string;
  }
  return gameserverip_;
}
inline ::std::string* ACKThranGameVersion::release_gameserverip() {
  clear_has_gameserverip();
  if (gameserverip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameserverip_;
    gameserverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string GameServerPort = 5;
inline bool ACKThranGameVersion::has_gameserverport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ACKThranGameVersion::set_has_gameserverport() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ACKThranGameVersion::clear_has_gameserverport() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ACKThranGameVersion::clear_gameserverport() {
  if (gameserverport_ != &::google::protobuf::internal::kEmptyString) {
    gameserverport_->clear();
  }
  clear_has_gameserverport();
}
inline const ::std::string& ACKThranGameVersion::gameserverport() const {
  return *gameserverport_;
}
inline void ACKThranGameVersion::set_gameserverport(const ::std::string& value) {
  set_has_gameserverport();
  if (gameserverport_ == &::google::protobuf::internal::kEmptyString) {
    gameserverport_ = new ::std::string;
  }
  gameserverport_->assign(value);
}
inline void ACKThranGameVersion::set_gameserverport(const char* value) {
  set_has_gameserverport();
  if (gameserverport_ == &::google::protobuf::internal::kEmptyString) {
    gameserverport_ = new ::std::string;
  }
  gameserverport_->assign(value);
}
inline void ACKThranGameVersion::set_gameserverport(const char* value, size_t size) {
  set_has_gameserverport();
  if (gameserverport_ == &::google::protobuf::internal::kEmptyString) {
    gameserverport_ = new ::std::string;
  }
  gameserverport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranGameVersion::mutable_gameserverport() {
  set_has_gameserverport();
  if (gameserverport_ == &::google::protobuf::internal::kEmptyString) {
    gameserverport_ = new ::std::string;
  }
  return gameserverport_;
}
inline ::std::string* ACKThranGameVersion::release_gameserverport() {
  clear_has_gameserverport();
  if (gameserverport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameserverport_;
    gameserverport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string GameRankEnable = 6;
inline bool ACKThranGameVersion::has_gamerankenable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ACKThranGameVersion::set_has_gamerankenable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ACKThranGameVersion::clear_has_gamerankenable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ACKThranGameVersion::clear_gamerankenable() {
  if (gamerankenable_ != &::google::protobuf::internal::kEmptyString) {
    gamerankenable_->clear();
  }
  clear_has_gamerankenable();
}
inline const ::std::string& ACKThranGameVersion::gamerankenable() const {
  return *gamerankenable_;
}
inline void ACKThranGameVersion::set_gamerankenable(const ::std::string& value) {
  set_has_gamerankenable();
  if (gamerankenable_ == &::google::protobuf::internal::kEmptyString) {
    gamerankenable_ = new ::std::string;
  }
  gamerankenable_->assign(value);
}
inline void ACKThranGameVersion::set_gamerankenable(const char* value) {
  set_has_gamerankenable();
  if (gamerankenable_ == &::google::protobuf::internal::kEmptyString) {
    gamerankenable_ = new ::std::string;
  }
  gamerankenable_->assign(value);
}
inline void ACKThranGameVersion::set_gamerankenable(const char* value, size_t size) {
  set_has_gamerankenable();
  if (gamerankenable_ == &::google::protobuf::internal::kEmptyString) {
    gamerankenable_ = new ::std::string;
  }
  gamerankenable_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranGameVersion::mutable_gamerankenable() {
  set_has_gamerankenable();
  if (gamerankenable_ == &::google::protobuf::internal::kEmptyString) {
    gamerankenable_ = new ::std::string;
  }
  return gamerankenable_;
}
inline ::std::string* ACKThranGameVersion::release_gamerankenable() {
  clear_has_gamerankenable();
  if (gamerankenable_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamerankenable_;
    gamerankenable_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string GameRankDef = 7;
inline bool ACKThranGameVersion::has_gamerankdef() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ACKThranGameVersion::set_has_gamerankdef() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ACKThranGameVersion::clear_has_gamerankdef() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ACKThranGameVersion::clear_gamerankdef() {
  if (gamerankdef_ != &::google::protobuf::internal::kEmptyString) {
    gamerankdef_->clear();
  }
  clear_has_gamerankdef();
}
inline const ::std::string& ACKThranGameVersion::gamerankdef() const {
  return *gamerankdef_;
}
inline void ACKThranGameVersion::set_gamerankdef(const ::std::string& value) {
  set_has_gamerankdef();
  if (gamerankdef_ == &::google::protobuf::internal::kEmptyString) {
    gamerankdef_ = new ::std::string;
  }
  gamerankdef_->assign(value);
}
inline void ACKThranGameVersion::set_gamerankdef(const char* value) {
  set_has_gamerankdef();
  if (gamerankdef_ == &::google::protobuf::internal::kEmptyString) {
    gamerankdef_ = new ::std::string;
  }
  gamerankdef_->assign(value);
}
inline void ACKThranGameVersion::set_gamerankdef(const char* value, size_t size) {
  set_has_gamerankdef();
  if (gamerankdef_ == &::google::protobuf::internal::kEmptyString) {
    gamerankdef_ = new ::std::string;
  }
  gamerankdef_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranGameVersion::mutable_gamerankdef() {
  set_has_gamerankdef();
  if (gamerankdef_ == &::google::protobuf::internal::kEmptyString) {
    gamerankdef_ = new ::std::string;
  }
  return gamerankdef_;
}
inline ::std::string* ACKThranGameVersion::release_gamerankdef() {
  clear_has_gamerankdef();
  if (gamerankdef_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamerankdef_;
    gamerankdef_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string IfPreserve = 8;
inline bool ACKThranGameVersion::has_ifpreserve() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ACKThranGameVersion::set_has_ifpreserve() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ACKThranGameVersion::clear_has_ifpreserve() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ACKThranGameVersion::clear_ifpreserve() {
  if (ifpreserve_ != &::google::protobuf::internal::kEmptyString) {
    ifpreserve_->clear();
  }
  clear_has_ifpreserve();
}
inline const ::std::string& ACKThranGameVersion::ifpreserve() const {
  return *ifpreserve_;
}
inline void ACKThranGameVersion::set_ifpreserve(const ::std::string& value) {
  set_has_ifpreserve();
  if (ifpreserve_ == &::google::protobuf::internal::kEmptyString) {
    ifpreserve_ = new ::std::string;
  }
  ifpreserve_->assign(value);
}
inline void ACKThranGameVersion::set_ifpreserve(const char* value) {
  set_has_ifpreserve();
  if (ifpreserve_ == &::google::protobuf::internal::kEmptyString) {
    ifpreserve_ = new ::std::string;
  }
  ifpreserve_->assign(value);
}
inline void ACKThranGameVersion::set_ifpreserve(const char* value, size_t size) {
  set_has_ifpreserve();
  if (ifpreserve_ == &::google::protobuf::internal::kEmptyString) {
    ifpreserve_ = new ::std::string;
  }
  ifpreserve_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranGameVersion::mutable_ifpreserve() {
  set_has_ifpreserve();
  if (ifpreserve_ == &::google::protobuf::internal::kEmptyString) {
    ifpreserve_ = new ::std::string;
  }
  return ifpreserve_;
}
inline ::std::string* ACKThranGameVersion::release_ifpreserve() {
  clear_has_ifpreserve();
  if (ifpreserve_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ifpreserve_;
    ifpreserve_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PreserveMsg = 9;
inline bool ACKThranGameVersion::has_preservemsg() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ACKThranGameVersion::set_has_preservemsg() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ACKThranGameVersion::clear_has_preservemsg() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ACKThranGameVersion::clear_preservemsg() {
  if (preservemsg_ != &::google::protobuf::internal::kEmptyString) {
    preservemsg_->clear();
  }
  clear_has_preservemsg();
}
inline const ::std::string& ACKThranGameVersion::preservemsg() const {
  return *preservemsg_;
}
inline void ACKThranGameVersion::set_preservemsg(const ::std::string& value) {
  set_has_preservemsg();
  if (preservemsg_ == &::google::protobuf::internal::kEmptyString) {
    preservemsg_ = new ::std::string;
  }
  preservemsg_->assign(value);
}
inline void ACKThranGameVersion::set_preservemsg(const char* value) {
  set_has_preservemsg();
  if (preservemsg_ == &::google::protobuf::internal::kEmptyString) {
    preservemsg_ = new ::std::string;
  }
  preservemsg_->assign(value);
}
inline void ACKThranGameVersion::set_preservemsg(const char* value, size_t size) {
  set_has_preservemsg();
  if (preservemsg_ == &::google::protobuf::internal::kEmptyString) {
    preservemsg_ = new ::std::string;
  }
  preservemsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranGameVersion::mutable_preservemsg() {
  set_has_preservemsg();
  if (preservemsg_ == &::google::protobuf::internal::kEmptyString) {
    preservemsg_ = new ::std::string;
  }
  return preservemsg_;
}
inline ::std::string* ACKThranGameVersion::release_preservemsg() {
  clear_has_preservemsg();
  if (preservemsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = preservemsg_;
    preservemsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .OGThranMatchInfo MatchInfoList = 10;
inline int ACKThranGameVersion::matchinfolist_size() const {
  return matchinfolist_.size();
}
inline void ACKThranGameVersion::clear_matchinfolist() {
  matchinfolist_.Clear();
}
inline const ::OGThranMatchInfo& ACKThranGameVersion::matchinfolist(int index) const {
  return matchinfolist_.Get(index);
}
inline ::OGThranMatchInfo* ACKThranGameVersion::mutable_matchinfolist(int index) {
  return matchinfolist_.Mutable(index);
}
inline ::OGThranMatchInfo* ACKThranGameVersion::add_matchinfolist() {
  return matchinfolist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OGThranMatchInfo >&
ACKThranGameVersion::matchinfolist() const {
  return matchinfolist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OGThranMatchInfo >*
ACKThranGameVersion::mutable_matchinfolist() {
  return &matchinfolist_;
}

// optional int32 DownloadReasion = 11;
inline bool ACKThranGameVersion::has_downloadreasion() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ACKThranGameVersion::set_has_downloadreasion() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ACKThranGameVersion::clear_has_downloadreasion() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ACKThranGameVersion::clear_downloadreasion() {
  downloadreasion_ = 0;
  clear_has_downloadreasion();
}
inline ::google::protobuf::int32 ACKThranGameVersion::downloadreasion() const {
  return downloadreasion_;
}
inline void ACKThranGameVersion::set_downloadreasion(::google::protobuf::int32 value) {
  set_has_downloadreasion();
  downloadreasion_ = value;
}

// optional int32 GameId = 12;
inline bool ACKThranGameVersion::has_gameid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ACKThranGameVersion::set_has_gameid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ACKThranGameVersion::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ACKThranGameVersion::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ACKThranGameVersion::gameid() const {
  return gameid_;
}
inline void ACKThranGameVersion::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional int32 gameSort = 13;
inline bool ACKThranGameVersion::has_gamesort() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ACKThranGameVersion::set_has_gamesort() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ACKThranGameVersion::clear_has_gamesort() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ACKThranGameVersion::clear_gamesort() {
  gamesort_ = 0;
  clear_has_gamesort();
}
inline ::google::protobuf::int32 ACKThranGameVersion::gamesort() const {
  return gamesort_;
}
inline void ACKThranGameVersion::set_gamesort(::google::protobuf::int32 value) {
  set_has_gamesort();
  gamesort_ = value;
}

// repeated .OGRoomInfo MatchRoomList = 14;
inline int ACKThranGameVersion::matchroomlist_size() const {
  return matchroomlist_.size();
}
inline void ACKThranGameVersion::clear_matchroomlist() {
  matchroomlist_.Clear();
}
inline const ::OGRoomInfo& ACKThranGameVersion::matchroomlist(int index) const {
  return matchroomlist_.Get(index);
}
inline ::OGRoomInfo* ACKThranGameVersion::mutable_matchroomlist(int index) {
  return matchroomlist_.Mutable(index);
}
inline ::OGRoomInfo* ACKThranGameVersion::add_matchroomlist() {
  return matchroomlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
ACKThranGameVersion::matchroomlist() const {
  return matchroomlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
ACKThranGameVersion::mutable_matchroomlist() {
  return &matchroomlist_;
}

// repeated .ThranJSSInfo JssList = 15;
inline int ACKThranGameVersion::jsslist_size() const {
  return jsslist_.size();
}
inline void ACKThranGameVersion::clear_jsslist() {
  jsslist_.Clear();
}
inline const ::ThranJSSInfo& ACKThranGameVersion::jsslist(int index) const {
  return jsslist_.Get(index);
}
inline ::ThranJSSInfo* ACKThranGameVersion::mutable_jsslist(int index) {
  return jsslist_.Mutable(index);
}
inline ::ThranJSSInfo* ACKThranGameVersion::add_jsslist() {
  return jsslist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ThranJSSInfo >&
ACKThranGameVersion::jsslist() const {
  return jsslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ThranJSSInfo >*
ACKThranGameVersion::mutable_jsslist() {
  return &jsslist_;
}

// optional string IfSearch = 16;
inline bool ACKThranGameVersion::has_ifsearch() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ACKThranGameVersion::set_has_ifsearch() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ACKThranGameVersion::clear_has_ifsearch() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ACKThranGameVersion::clear_ifsearch() {
  if (ifsearch_ != &::google::protobuf::internal::kEmptyString) {
    ifsearch_->clear();
  }
  clear_has_ifsearch();
}
inline const ::std::string& ACKThranGameVersion::ifsearch() const {
  return *ifsearch_;
}
inline void ACKThranGameVersion::set_ifsearch(const ::std::string& value) {
  set_has_ifsearch();
  if (ifsearch_ == &::google::protobuf::internal::kEmptyString) {
    ifsearch_ = new ::std::string;
  }
  ifsearch_->assign(value);
}
inline void ACKThranGameVersion::set_ifsearch(const char* value) {
  set_has_ifsearch();
  if (ifsearch_ == &::google::protobuf::internal::kEmptyString) {
    ifsearch_ = new ::std::string;
  }
  ifsearch_->assign(value);
}
inline void ACKThranGameVersion::set_ifsearch(const char* value, size_t size) {
  set_has_ifsearch();
  if (ifsearch_ == &::google::protobuf::internal::kEmptyString) {
    ifsearch_ = new ::std::string;
  }
  ifsearch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranGameVersion::mutable_ifsearch() {
  set_has_ifsearch();
  if (ifsearch_ == &::google::protobuf::internal::kEmptyString) {
    ifsearch_ = new ::std::string;
  }
  return ifsearch_;
}
inline ::std::string* ACKThranGameVersion::release_ifsearch() {
  clear_has_ifsearch();
  if (ifsearch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ifsearch_;
    ifsearch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .OGBulletinInfo BulletinList = 17;
inline int ACKThranGameVersion::bulletinlist_size() const {
  return bulletinlist_.size();
}
inline void ACKThranGameVersion::clear_bulletinlist() {
  bulletinlist_.Clear();
}
inline const ::OGBulletinInfo& ACKThranGameVersion::bulletinlist(int index) const {
  return bulletinlist_.Get(index);
}
inline ::OGBulletinInfo* ACKThranGameVersion::mutable_bulletinlist(int index) {
  return bulletinlist_.Mutable(index);
}
inline ::OGBulletinInfo* ACKThranGameVersion::add_bulletinlist() {
  return bulletinlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OGBulletinInfo >&
ACKThranGameVersion::bulletinlist() const {
  return bulletinlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OGBulletinInfo >*
ACKThranGameVersion::mutable_bulletinlist() {
  return &bulletinlist_;
}

// -------------------------------------------------------------------

// REQThranNewVerify

// required string SecureID = 1;
inline bool REQThranNewVerify::has_secureid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQThranNewVerify::set_has_secureid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQThranNewVerify::clear_has_secureid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQThranNewVerify::clear_secureid() {
  if (secureid_ != &::google::protobuf::internal::kEmptyString) {
    secureid_->clear();
  }
  clear_has_secureid();
}
inline const ::std::string& REQThranNewVerify::secureid() const {
  return *secureid_;
}
inline void REQThranNewVerify::set_secureid(const ::std::string& value) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(value);
}
inline void REQThranNewVerify::set_secureid(const char* value) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(value);
}
inline void REQThranNewVerify::set_secureid(const char* value, size_t size) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranNewVerify::mutable_secureid() {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  return secureid_;
}
inline ::std::string* REQThranNewVerify::release_secureid() {
  clear_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secureid_;
    secureid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 ComeFromID = 2;
inline bool REQThranNewVerify::has_comefromid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQThranNewVerify::set_has_comefromid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQThranNewVerify::clear_has_comefromid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQThranNewVerify::clear_comefromid() {
  comefromid_ = 0;
  clear_has_comefromid();
}
inline ::google::protobuf::int32 REQThranNewVerify::comefromid() const {
  return comefromid_;
}
inline void REQThranNewVerify::set_comefromid(::google::protobuf::int32 value) {
  set_has_comefromid();
  comefromid_ = value;
}

// required string ChannelID = 3;
inline bool REQThranNewVerify::has_channelid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQThranNewVerify::set_has_channelid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQThranNewVerify::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQThranNewVerify::clear_channelid() {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    channelid_->clear();
  }
  clear_has_channelid();
}
inline const ::std::string& REQThranNewVerify::channelid() const {
  return *channelid_;
}
inline void REQThranNewVerify::set_channelid(const ::std::string& value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQThranNewVerify::set_channelid(const char* value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQThranNewVerify::set_channelid(const char* value, size_t size) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranNewVerify::mutable_channelid() {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  return channelid_;
}
inline ::std::string* REQThranNewVerify::release_channelid() {
  clear_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channelid_;
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 GameId = 4;
inline bool REQThranNewVerify::has_gameid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void REQThranNewVerify::set_has_gameid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void REQThranNewVerify::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void REQThranNewVerify::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 REQThranNewVerify::gameid() const {
  return gameid_;
}
inline void REQThranNewVerify::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// ACKThranNewVerify

// required int32 AckResult = 1;
inline bool ACKThranNewVerify::has_ackresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKThranNewVerify::set_has_ackresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKThranNewVerify::clear_has_ackresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKThranNewVerify::clear_ackresult() {
  ackresult_ = 0;
  clear_has_ackresult();
}
inline ::google::protobuf::int32 ACKThranNewVerify::ackresult() const {
  return ackresult_;
}
inline void ACKThranNewVerify::set_ackresult(::google::protobuf::int32 value) {
  set_has_ackresult();
  ackresult_ = value;
}

// optional string ErrorStr = 2;
inline bool ACKThranNewVerify::has_errorstr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKThranNewVerify::set_has_errorstr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKThranNewVerify::clear_has_errorstr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKThranNewVerify::clear_errorstr() {
  if (errorstr_ != &::google::protobuf::internal::kEmptyString) {
    errorstr_->clear();
  }
  clear_has_errorstr();
}
inline const ::std::string& ACKThranNewVerify::errorstr() const {
  return *errorstr_;
}
inline void ACKThranNewVerify::set_errorstr(const ::std::string& value) {
  set_has_errorstr();
  if (errorstr_ == &::google::protobuf::internal::kEmptyString) {
    errorstr_ = new ::std::string;
  }
  errorstr_->assign(value);
}
inline void ACKThranNewVerify::set_errorstr(const char* value) {
  set_has_errorstr();
  if (errorstr_ == &::google::protobuf::internal::kEmptyString) {
    errorstr_ = new ::std::string;
  }
  errorstr_->assign(value);
}
inline void ACKThranNewVerify::set_errorstr(const char* value, size_t size) {
  set_has_errorstr();
  if (errorstr_ == &::google::protobuf::internal::kEmptyString) {
    errorstr_ = new ::std::string;
  }
  errorstr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranNewVerify::mutable_errorstr() {
  set_has_errorstr();
  if (errorstr_ == &::google::protobuf::internal::kEmptyString) {
    errorstr_ = new ::std::string;
  }
  return errorstr_;
}
inline ::std::string* ACKThranNewVerify::release_errorstr() {
  clear_has_errorstr();
  if (errorstr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errorstr_;
    errorstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes Verify = 3;
inline bool ACKThranNewVerify::has_verify() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKThranNewVerify::set_has_verify() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKThranNewVerify::clear_has_verify() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKThranNewVerify::clear_verify() {
  if (verify_ != &::google::protobuf::internal::kEmptyString) {
    verify_->clear();
  }
  clear_has_verify();
}
inline const ::std::string& ACKThranNewVerify::verify() const {
  return *verify_;
}
inline void ACKThranNewVerify::set_verify(const ::std::string& value) {
  set_has_verify();
  if (verify_ == &::google::protobuf::internal::kEmptyString) {
    verify_ = new ::std::string;
  }
  verify_->assign(value);
}
inline void ACKThranNewVerify::set_verify(const char* value) {
  set_has_verify();
  if (verify_ == &::google::protobuf::internal::kEmptyString) {
    verify_ = new ::std::string;
  }
  verify_->assign(value);
}
inline void ACKThranNewVerify::set_verify(const void* value, size_t size) {
  set_has_verify();
  if (verify_ == &::google::protobuf::internal::kEmptyString) {
    verify_ = new ::std::string;
  }
  verify_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranNewVerify::mutable_verify() {
  set_has_verify();
  if (verify_ == &::google::protobuf::internal::kEmptyString) {
    verify_ = new ::std::string;
  }
  return verify_;
}
inline ::std::string* ACKThranNewVerify::release_verify() {
  clear_has_verify();
  if (verify_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verify_;
    verify_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 VerifyId = 4;
inline bool ACKThranNewVerify::has_verifyid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACKThranNewVerify::set_has_verifyid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACKThranNewVerify::clear_has_verifyid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACKThranNewVerify::clear_verifyid() {
  verifyid_ = 0;
  clear_has_verifyid();
}
inline ::google::protobuf::int32 ACKThranNewVerify::verifyid() const {
  return verifyid_;
}
inline void ACKThranNewVerify::set_verifyid(::google::protobuf::int32 value) {
  set_has_verifyid();
  verifyid_ = value;
}

// -------------------------------------------------------------------

// REQThranFindPwd

// required string Email = 1;
inline bool REQThranFindPwd::has_email() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQThranFindPwd::set_has_email() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQThranFindPwd::clear_has_email() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQThranFindPwd::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& REQThranFindPwd::email() const {
  return *email_;
}
inline void REQThranFindPwd::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void REQThranFindPwd::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void REQThranFindPwd::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranFindPwd::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* REQThranFindPwd::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string NewPwd = 2;
inline bool REQThranFindPwd::has_newpwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQThranFindPwd::set_has_newpwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQThranFindPwd::clear_has_newpwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQThranFindPwd::clear_newpwd() {
  if (newpwd_ != &::google::protobuf::internal::kEmptyString) {
    newpwd_->clear();
  }
  clear_has_newpwd();
}
inline const ::std::string& REQThranFindPwd::newpwd() const {
  return *newpwd_;
}
inline void REQThranFindPwd::set_newpwd(const ::std::string& value) {
  set_has_newpwd();
  if (newpwd_ == &::google::protobuf::internal::kEmptyString) {
    newpwd_ = new ::std::string;
  }
  newpwd_->assign(value);
}
inline void REQThranFindPwd::set_newpwd(const char* value) {
  set_has_newpwd();
  if (newpwd_ == &::google::protobuf::internal::kEmptyString) {
    newpwd_ = new ::std::string;
  }
  newpwd_->assign(value);
}
inline void REQThranFindPwd::set_newpwd(const char* value, size_t size) {
  set_has_newpwd();
  if (newpwd_ == &::google::protobuf::internal::kEmptyString) {
    newpwd_ = new ::std::string;
  }
  newpwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQThranFindPwd::mutable_newpwd() {
  set_has_newpwd();
  if (newpwd_ == &::google::protobuf::internal::kEmptyString) {
    newpwd_ = new ::std::string;
  }
  return newpwd_;
}
inline ::std::string* REQThranFindPwd::release_newpwd() {
  clear_has_newpwd();
  if (newpwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newpwd_;
    newpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ACKThranFindPwd

// required int32 AckResult = 1;
inline bool ACKThranFindPwd::has_ackresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKThranFindPwd::set_has_ackresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKThranFindPwd::clear_has_ackresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKThranFindPwd::clear_ackresult() {
  ackresult_ = 0;
  clear_has_ackresult();
}
inline ::google::protobuf::int32 ACKThranFindPwd::ackresult() const {
  return ackresult_;
}
inline void ACKThranFindPwd::set_ackresult(::google::protobuf::int32 value) {
  set_has_ackresult();
  ackresult_ = value;
}

// -------------------------------------------------------------------

// ACKThranHeart

// required string ServTime = 1;
inline bool ACKThranHeart::has_servtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKThranHeart::set_has_servtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKThranHeart::clear_has_servtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKThranHeart::clear_servtime() {
  if (servtime_ != &::google::protobuf::internal::kEmptyString) {
    servtime_->clear();
  }
  clear_has_servtime();
}
inline const ::std::string& ACKThranHeart::servtime() const {
  return *servtime_;
}
inline void ACKThranHeart::set_servtime(const ::std::string& value) {
  set_has_servtime();
  if (servtime_ == &::google::protobuf::internal::kEmptyString) {
    servtime_ = new ::std::string;
  }
  servtime_->assign(value);
}
inline void ACKThranHeart::set_servtime(const char* value) {
  set_has_servtime();
  if (servtime_ == &::google::protobuf::internal::kEmptyString) {
    servtime_ = new ::std::string;
  }
  servtime_->assign(value);
}
inline void ACKThranHeart::set_servtime(const char* value, size_t size) {
  set_has_servtime();
  if (servtime_ == &::google::protobuf::internal::kEmptyString) {
    servtime_ = new ::std::string;
  }
  servtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKThranHeart::mutable_servtime() {
  set_has_servtime();
  if (servtime_ == &::google::protobuf::internal::kEmptyString) {
    servtime_ = new ::std::string;
  }
  return servtime_;
}
inline ::std::string* ACKThranHeart::release_servtime() {
  clear_has_servtime();
  if (servtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servtime_;
    servtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SinaApiInfo

// required int32 ApiType = 1;
inline bool SinaApiInfo::has_apitype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SinaApiInfo::set_has_apitype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SinaApiInfo::clear_has_apitype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SinaApiInfo::clear_apitype() {
  apitype_ = 0;
  clear_has_apitype();
}
inline ::google::protobuf::int32 SinaApiInfo::apitype() const {
  return apitype_;
}
inline void SinaApiInfo::set_apitype(::google::protobuf::int32 value) {
  set_has_apitype();
  apitype_ = value;
}

// required string RetValue = 2;
inline bool SinaApiInfo::has_retvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SinaApiInfo::set_has_retvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SinaApiInfo::clear_has_retvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SinaApiInfo::clear_retvalue() {
  if (retvalue_ != &::google::protobuf::internal::kEmptyString) {
    retvalue_->clear();
  }
  clear_has_retvalue();
}
inline const ::std::string& SinaApiInfo::retvalue() const {
  return *retvalue_;
}
inline void SinaApiInfo::set_retvalue(const ::std::string& value) {
  set_has_retvalue();
  if (retvalue_ == &::google::protobuf::internal::kEmptyString) {
    retvalue_ = new ::std::string;
  }
  retvalue_->assign(value);
}
inline void SinaApiInfo::set_retvalue(const char* value) {
  set_has_retvalue();
  if (retvalue_ == &::google::protobuf::internal::kEmptyString) {
    retvalue_ = new ::std::string;
  }
  retvalue_->assign(value);
}
inline void SinaApiInfo::set_retvalue(const char* value, size_t size) {
  set_has_retvalue();
  if (retvalue_ == &::google::protobuf::internal::kEmptyString) {
    retvalue_ = new ::std::string;
  }
  retvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SinaApiInfo::mutable_retvalue() {
  set_has_retvalue();
  if (retvalue_ == &::google::protobuf::internal::kEmptyString) {
    retvalue_ = new ::std::string;
  }
  return retvalue_;
}
inline ::std::string* SinaApiInfo::release_retvalue() {
  clear_has_retvalue();
  if (retvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = retvalue_;
    retvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string UserId = 3;
inline bool SinaApiInfo::has_userid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SinaApiInfo::set_has_userid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SinaApiInfo::clear_has_userid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SinaApiInfo::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& SinaApiInfo::userid() const {
  return *userid_;
}
inline void SinaApiInfo::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void SinaApiInfo::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void SinaApiInfo::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SinaApiInfo::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* SinaApiInfo::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SinaApiRet

// required int32 RetResult = 1;
inline bool SinaApiRet::has_retresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SinaApiRet::set_has_retresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SinaApiRet::clear_has_retresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SinaApiRet::clear_retresult() {
  retresult_ = 0;
  clear_has_retresult();
}
inline ::google::protobuf::int32 SinaApiRet::retresult() const {
  return retresult_;
}
inline void SinaApiRet::set_retresult(::google::protobuf::int32 value) {
  set_has_retresult();
  retresult_ = value;
}

// required int32 ApiType = 2;
inline bool SinaApiRet::has_apitype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SinaApiRet::set_has_apitype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SinaApiRet::clear_has_apitype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SinaApiRet::clear_apitype() {
  apitype_ = 0;
  clear_has_apitype();
}
inline ::google::protobuf::int32 SinaApiRet::apitype() const {
  return apitype_;
}
inline void SinaApiRet::set_apitype(::google::protobuf::int32 value) {
  set_has_apitype();
  apitype_ = value;
}

// optional string RetValue = 3;
inline bool SinaApiRet::has_retvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SinaApiRet::set_has_retvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SinaApiRet::clear_has_retvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SinaApiRet::clear_retvalue() {
  if (retvalue_ != &::google::protobuf::internal::kEmptyString) {
    retvalue_->clear();
  }
  clear_has_retvalue();
}
inline const ::std::string& SinaApiRet::retvalue() const {
  return *retvalue_;
}
inline void SinaApiRet::set_retvalue(const ::std::string& value) {
  set_has_retvalue();
  if (retvalue_ == &::google::protobuf::internal::kEmptyString) {
    retvalue_ = new ::std::string;
  }
  retvalue_->assign(value);
}
inline void SinaApiRet::set_retvalue(const char* value) {
  set_has_retvalue();
  if (retvalue_ == &::google::protobuf::internal::kEmptyString) {
    retvalue_ = new ::std::string;
  }
  retvalue_->assign(value);
}
inline void SinaApiRet::set_retvalue(const char* value, size_t size) {
  set_has_retvalue();
  if (retvalue_ == &::google::protobuf::internal::kEmptyString) {
    retvalue_ = new ::std::string;
  }
  retvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SinaApiRet::mutable_retvalue() {
  set_has_retvalue();
  if (retvalue_ == &::google::protobuf::internal::kEmptyString) {
    retvalue_ = new ::std::string;
  }
  return retvalue_;
}
inline ::std::string* SinaApiRet::release_retvalue() {
  clear_has_retvalue();
  if (retvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = retvalue_;
    retvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// OGRoomInfo

// required string RoomId = 1;
inline bool OGRoomInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OGRoomInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OGRoomInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OGRoomInfo::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& OGRoomInfo::roomid() const {
  return *roomid_;
}
inline void OGRoomInfo::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void OGRoomInfo::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void OGRoomInfo::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGRoomInfo::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* OGRoomInfo::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoomRank = 2;
inline bool OGRoomInfo::has_roomrank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OGRoomInfo::set_has_roomrank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OGRoomInfo::clear_has_roomrank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OGRoomInfo::clear_roomrank() {
  if (roomrank_ != &::google::protobuf::internal::kEmptyString) {
    roomrank_->clear();
  }
  clear_has_roomrank();
}
inline const ::std::string& OGRoomInfo::roomrank() const {
  return *roomrank_;
}
inline void OGRoomInfo::set_roomrank(const ::std::string& value) {
  set_has_roomrank();
  if (roomrank_ == &::google::protobuf::internal::kEmptyString) {
    roomrank_ = new ::std::string;
  }
  roomrank_->assign(value);
}
inline void OGRoomInfo::set_roomrank(const char* value) {
  set_has_roomrank();
  if (roomrank_ == &::google::protobuf::internal::kEmptyString) {
    roomrank_ = new ::std::string;
  }
  roomrank_->assign(value);
}
inline void OGRoomInfo::set_roomrank(const char* value, size_t size) {
  set_has_roomrank();
  if (roomrank_ == &::google::protobuf::internal::kEmptyString) {
    roomrank_ = new ::std::string;
  }
  roomrank_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGRoomInfo::mutable_roomrank() {
  set_has_roomrank();
  if (roomrank_ == &::google::protobuf::internal::kEmptyString) {
    roomrank_ = new ::std::string;
  }
  return roomrank_;
}
inline ::std::string* OGRoomInfo::release_roomrank() {
  clear_has_roomrank();
  if (roomrank_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomrank_;
    roomrank_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoomIp = 3;
inline bool OGRoomInfo::has_roomip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OGRoomInfo::set_has_roomip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OGRoomInfo::clear_has_roomip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OGRoomInfo::clear_roomip() {
  if (roomip_ != &::google::protobuf::internal::kEmptyString) {
    roomip_->clear();
  }
  clear_has_roomip();
}
inline const ::std::string& OGRoomInfo::roomip() const {
  return *roomip_;
}
inline void OGRoomInfo::set_roomip(const ::std::string& value) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(value);
}
inline void OGRoomInfo::set_roomip(const char* value) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(value);
}
inline void OGRoomInfo::set_roomip(const char* value, size_t size) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGRoomInfo::mutable_roomip() {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  return roomip_;
}
inline ::std::string* OGRoomInfo::release_roomip() {
  clear_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomip_;
    roomip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoomPort = 4;
inline bool OGRoomInfo::has_roomport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OGRoomInfo::set_has_roomport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OGRoomInfo::clear_has_roomport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OGRoomInfo::clear_roomport() {
  if (roomport_ != &::google::protobuf::internal::kEmptyString) {
    roomport_->clear();
  }
  clear_has_roomport();
}
inline const ::std::string& OGRoomInfo::roomport() const {
  return *roomport_;
}
inline void OGRoomInfo::set_roomport(const ::std::string& value) {
  set_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    roomport_ = new ::std::string;
  }
  roomport_->assign(value);
}
inline void OGRoomInfo::set_roomport(const char* value) {
  set_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    roomport_ = new ::std::string;
  }
  roomport_->assign(value);
}
inline void OGRoomInfo::set_roomport(const char* value, size_t size) {
  set_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    roomport_ = new ::std::string;
  }
  roomport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGRoomInfo::mutable_roomport() {
  set_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    roomport_ = new ::std::string;
  }
  return roomport_;
}
inline ::std::string* OGRoomInfo::release_roomport() {
  clear_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomport_;
    roomport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoomStatus = 5;
inline bool OGRoomInfo::has_roomstatus() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OGRoomInfo::set_has_roomstatus() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OGRoomInfo::clear_has_roomstatus() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OGRoomInfo::clear_roomstatus() {
  if (roomstatus_ != &::google::protobuf::internal::kEmptyString) {
    roomstatus_->clear();
  }
  clear_has_roomstatus();
}
inline const ::std::string& OGRoomInfo::roomstatus() const {
  return *roomstatus_;
}
inline void OGRoomInfo::set_roomstatus(const ::std::string& value) {
  set_has_roomstatus();
  if (roomstatus_ == &::google::protobuf::internal::kEmptyString) {
    roomstatus_ = new ::std::string;
  }
  roomstatus_->assign(value);
}
inline void OGRoomInfo::set_roomstatus(const char* value) {
  set_has_roomstatus();
  if (roomstatus_ == &::google::protobuf::internal::kEmptyString) {
    roomstatus_ = new ::std::string;
  }
  roomstatus_->assign(value);
}
inline void OGRoomInfo::set_roomstatus(const char* value, size_t size) {
  set_has_roomstatus();
  if (roomstatus_ == &::google::protobuf::internal::kEmptyString) {
    roomstatus_ = new ::std::string;
  }
  roomstatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGRoomInfo::mutable_roomstatus() {
  set_has_roomstatus();
  if (roomstatus_ == &::google::protobuf::internal::kEmptyString) {
    roomstatus_ = new ::std::string;
  }
  return roomstatus_;
}
inline ::std::string* OGRoomInfo::release_roomstatus() {
  clear_has_roomstatus();
  if (roomstatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomstatus_;
    roomstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoomMinGold = 6;
inline bool OGRoomInfo::has_roommingold() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OGRoomInfo::set_has_roommingold() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OGRoomInfo::clear_has_roommingold() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OGRoomInfo::clear_roommingold() {
  if (roommingold_ != &::google::protobuf::internal::kEmptyString) {
    roommingold_->clear();
  }
  clear_has_roommingold();
}
inline const ::std::string& OGRoomInfo::roommingold() const {
  return *roommingold_;
}
inline void OGRoomInfo::set_roommingold(const ::std::string& value) {
  set_has_roommingold();
  if (roommingold_ == &::google::protobuf::internal::kEmptyString) {
    roommingold_ = new ::std::string;
  }
  roommingold_->assign(value);
}
inline void OGRoomInfo::set_roommingold(const char* value) {
  set_has_roommingold();
  if (roommingold_ == &::google::protobuf::internal::kEmptyString) {
    roommingold_ = new ::std::string;
  }
  roommingold_->assign(value);
}
inline void OGRoomInfo::set_roommingold(const char* value, size_t size) {
  set_has_roommingold();
  if (roommingold_ == &::google::protobuf::internal::kEmptyString) {
    roommingold_ = new ::std::string;
  }
  roommingold_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGRoomInfo::mutable_roommingold() {
  set_has_roommingold();
  if (roommingold_ == &::google::protobuf::internal::kEmptyString) {
    roommingold_ = new ::std::string;
  }
  return roommingold_;
}
inline ::std::string* OGRoomInfo::release_roommingold() {
  clear_has_roommingold();
  if (roommingold_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roommingold_;
    roommingold_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoomMaxGold = 7;
inline bool OGRoomInfo::has_roommaxgold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OGRoomInfo::set_has_roommaxgold() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OGRoomInfo::clear_has_roommaxgold() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OGRoomInfo::clear_roommaxgold() {
  if (roommaxgold_ != &::google::protobuf::internal::kEmptyString) {
    roommaxgold_->clear();
  }
  clear_has_roommaxgold();
}
inline const ::std::string& OGRoomInfo::roommaxgold() const {
  return *roommaxgold_;
}
inline void OGRoomInfo::set_roommaxgold(const ::std::string& value) {
  set_has_roommaxgold();
  if (roommaxgold_ == &::google::protobuf::internal::kEmptyString) {
    roommaxgold_ = new ::std::string;
  }
  roommaxgold_->assign(value);
}
inline void OGRoomInfo::set_roommaxgold(const char* value) {
  set_has_roommaxgold();
  if (roommaxgold_ == &::google::protobuf::internal::kEmptyString) {
    roommaxgold_ = new ::std::string;
  }
  roommaxgold_->assign(value);
}
inline void OGRoomInfo::set_roommaxgold(const char* value, size_t size) {
  set_has_roommaxgold();
  if (roommaxgold_ == &::google::protobuf::internal::kEmptyString) {
    roommaxgold_ = new ::std::string;
  }
  roommaxgold_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGRoomInfo::mutable_roommaxgold() {
  set_has_roommaxgold();
  if (roommaxgold_ == &::google::protobuf::internal::kEmptyString) {
    roommaxgold_ = new ::std::string;
  }
  return roommaxgold_;
}
inline ::std::string* OGRoomInfo::release_roommaxgold() {
  clear_has_roommaxgold();
  if (roommaxgold_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roommaxgold_;
    roommaxgold_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoomMinPlay = 8;
inline bool OGRoomInfo::has_roomminplay() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OGRoomInfo::set_has_roomminplay() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OGRoomInfo::clear_has_roomminplay() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OGRoomInfo::clear_roomminplay() {
  if (roomminplay_ != &::google::protobuf::internal::kEmptyString) {
    roomminplay_->clear();
  }
  clear_has_roomminplay();
}
inline const ::std::string& OGRoomInfo::roomminplay() const {
  return *roomminplay_;
}
inline void OGRoomInfo::set_roomminplay(const ::std::string& value) {
  set_has_roomminplay();
  if (roomminplay_ == &::google::protobuf::internal::kEmptyString) {
    roomminplay_ = new ::std::string;
  }
  roomminplay_->assign(value);
}
inline void OGRoomInfo::set_roomminplay(const char* value) {
  set_has_roomminplay();
  if (roomminplay_ == &::google::protobuf::internal::kEmptyString) {
    roomminplay_ = new ::std::string;
  }
  roomminplay_->assign(value);
}
inline void OGRoomInfo::set_roomminplay(const char* value, size_t size) {
  set_has_roomminplay();
  if (roomminplay_ == &::google::protobuf::internal::kEmptyString) {
    roomminplay_ = new ::std::string;
  }
  roomminplay_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGRoomInfo::mutable_roomminplay() {
  set_has_roomminplay();
  if (roomminplay_ == &::google::protobuf::internal::kEmptyString) {
    roomminplay_ = new ::std::string;
  }
  return roomminplay_;
}
inline ::std::string* OGRoomInfo::release_roomminplay() {
  clear_has_roomminplay();
  if (roomminplay_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomminplay_;
    roomminplay_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RoomType = 9;
inline bool OGRoomInfo::has_roomtype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OGRoomInfo::set_has_roomtype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OGRoomInfo::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OGRoomInfo::clear_roomtype() {
  if (roomtype_ != &::google::protobuf::internal::kEmptyString) {
    roomtype_->clear();
  }
  clear_has_roomtype();
}
inline const ::std::string& OGRoomInfo::roomtype() const {
  return *roomtype_;
}
inline void OGRoomInfo::set_roomtype(const ::std::string& value) {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::kEmptyString) {
    roomtype_ = new ::std::string;
  }
  roomtype_->assign(value);
}
inline void OGRoomInfo::set_roomtype(const char* value) {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::kEmptyString) {
    roomtype_ = new ::std::string;
  }
  roomtype_->assign(value);
}
inline void OGRoomInfo::set_roomtype(const char* value, size_t size) {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::kEmptyString) {
    roomtype_ = new ::std::string;
  }
  roomtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGRoomInfo::mutable_roomtype() {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::kEmptyString) {
    roomtype_ = new ::std::string;
  }
  return roomtype_;
}
inline ::std::string* OGRoomInfo::release_roomtype() {
  clear_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomtype_;
    roomtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ServerType = 10;
inline bool OGRoomInfo::has_servertype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OGRoomInfo::set_has_servertype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OGRoomInfo::clear_has_servertype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OGRoomInfo::clear_servertype() {
  if (servertype_ != &::google::protobuf::internal::kEmptyString) {
    servertype_->clear();
  }
  clear_has_servertype();
}
inline const ::std::string& OGRoomInfo::servertype() const {
  return *servertype_;
}
inline void OGRoomInfo::set_servertype(const ::std::string& value) {
  set_has_servertype();
  if (servertype_ == &::google::protobuf::internal::kEmptyString) {
    servertype_ = new ::std::string;
  }
  servertype_->assign(value);
}
inline void OGRoomInfo::set_servertype(const char* value) {
  set_has_servertype();
  if (servertype_ == &::google::protobuf::internal::kEmptyString) {
    servertype_ = new ::std::string;
  }
  servertype_->assign(value);
}
inline void OGRoomInfo::set_servertype(const char* value, size_t size) {
  set_has_servertype();
  if (servertype_ == &::google::protobuf::internal::kEmptyString) {
    servertype_ = new ::std::string;
  }
  servertype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGRoomInfo::mutable_servertype() {
  set_has_servertype();
  if (servertype_ == &::google::protobuf::internal::kEmptyString) {
    servertype_ = new ::std::string;
  }
  return servertype_;
}
inline ::std::string* OGRoomInfo::release_servertype() {
  clear_has_servertype();
  if (servertype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servertype_;
    servertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Description = 11;
inline bool OGRoomInfo::has_description() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OGRoomInfo::set_has_description() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OGRoomInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OGRoomInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& OGRoomInfo::description() const {
  return *description_;
}
inline void OGRoomInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void OGRoomInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void OGRoomInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGRoomInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* OGRoomInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RoomName = 12;
inline bool OGRoomInfo::has_roomname() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OGRoomInfo::set_has_roomname() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OGRoomInfo::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OGRoomInfo::clear_roomname() {
  if (roomname_ != &::google::protobuf::internal::kEmptyString) {
    roomname_->clear();
  }
  clear_has_roomname();
}
inline const ::std::string& OGRoomInfo::roomname() const {
  return *roomname_;
}
inline void OGRoomInfo::set_roomname(const ::std::string& value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void OGRoomInfo::set_roomname(const char* value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void OGRoomInfo::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGRoomInfo::mutable_roomname() {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  return roomname_;
}
inline ::std::string* OGRoomInfo::release_roomname() {
  clear_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomname_;
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// OGThranMatchInfo

// required int32 MatchID = 1;
inline bool OGThranMatchInfo::has_matchid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OGThranMatchInfo::set_has_matchid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OGThranMatchInfo::clear_has_matchid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OGThranMatchInfo::clear_matchid() {
  matchid_ = 0;
  clear_has_matchid();
}
inline ::google::protobuf::int32 OGThranMatchInfo::matchid() const {
  return matchid_;
}
inline void OGThranMatchInfo::set_matchid(::google::protobuf::int32 value) {
  set_has_matchid();
  matchid_ = value;
}

// required string MatchName = 2;
inline bool OGThranMatchInfo::has_matchname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OGThranMatchInfo::set_has_matchname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OGThranMatchInfo::clear_has_matchname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OGThranMatchInfo::clear_matchname() {
  if (matchname_ != &::google::protobuf::internal::kEmptyString) {
    matchname_->clear();
  }
  clear_has_matchname();
}
inline const ::std::string& OGThranMatchInfo::matchname() const {
  return *matchname_;
}
inline void OGThranMatchInfo::set_matchname(const ::std::string& value) {
  set_has_matchname();
  if (matchname_ == &::google::protobuf::internal::kEmptyString) {
    matchname_ = new ::std::string;
  }
  matchname_->assign(value);
}
inline void OGThranMatchInfo::set_matchname(const char* value) {
  set_has_matchname();
  if (matchname_ == &::google::protobuf::internal::kEmptyString) {
    matchname_ = new ::std::string;
  }
  matchname_->assign(value);
}
inline void OGThranMatchInfo::set_matchname(const char* value, size_t size) {
  set_has_matchname();
  if (matchname_ == &::google::protobuf::internal::kEmptyString) {
    matchname_ = new ::std::string;
  }
  matchname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGThranMatchInfo::mutable_matchname() {
  set_has_matchname();
  if (matchname_ == &::google::protobuf::internal::kEmptyString) {
    matchname_ = new ::std::string;
  }
  return matchname_;
}
inline ::std::string* OGThranMatchInfo::release_matchname() {
  clear_has_matchname();
  if (matchname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = matchname_;
    matchname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string AwardName = 3;
inline bool OGThranMatchInfo::has_awardname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OGThranMatchInfo::set_has_awardname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OGThranMatchInfo::clear_has_awardname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OGThranMatchInfo::clear_awardname() {
  if (awardname_ != &::google::protobuf::internal::kEmptyString) {
    awardname_->clear();
  }
  clear_has_awardname();
}
inline const ::std::string& OGThranMatchInfo::awardname() const {
  return *awardname_;
}
inline void OGThranMatchInfo::set_awardname(const ::std::string& value) {
  set_has_awardname();
  if (awardname_ == &::google::protobuf::internal::kEmptyString) {
    awardname_ = new ::std::string;
  }
  awardname_->assign(value);
}
inline void OGThranMatchInfo::set_awardname(const char* value) {
  set_has_awardname();
  if (awardname_ == &::google::protobuf::internal::kEmptyString) {
    awardname_ = new ::std::string;
  }
  awardname_->assign(value);
}
inline void OGThranMatchInfo::set_awardname(const char* value, size_t size) {
  set_has_awardname();
  if (awardname_ == &::google::protobuf::internal::kEmptyString) {
    awardname_ = new ::std::string;
  }
  awardname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGThranMatchInfo::mutable_awardname() {
  set_has_awardname();
  if (awardname_ == &::google::protobuf::internal::kEmptyString) {
    awardname_ = new ::std::string;
  }
  return awardname_;
}
inline ::std::string* OGThranMatchInfo::release_awardname() {
  clear_has_awardname();
  if (awardname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = awardname_;
    awardname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 AwardSum = 4;
inline bool OGThranMatchInfo::has_awardsum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OGThranMatchInfo::set_has_awardsum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OGThranMatchInfo::clear_has_awardsum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OGThranMatchInfo::clear_awardsum() {
  awardsum_ = 0;
  clear_has_awardsum();
}
inline ::google::protobuf::int32 OGThranMatchInfo::awardsum() const {
  return awardsum_;
}
inline void OGThranMatchInfo::set_awardsum(::google::protobuf::int32 value) {
  set_has_awardsum();
  awardsum_ = value;
}

// optional string MatchTerm = 5;
inline bool OGThranMatchInfo::has_matchterm() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OGThranMatchInfo::set_has_matchterm() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OGThranMatchInfo::clear_has_matchterm() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OGThranMatchInfo::clear_matchterm() {
  if (matchterm_ != &::google::protobuf::internal::kEmptyString) {
    matchterm_->clear();
  }
  clear_has_matchterm();
}
inline const ::std::string& OGThranMatchInfo::matchterm() const {
  return *matchterm_;
}
inline void OGThranMatchInfo::set_matchterm(const ::std::string& value) {
  set_has_matchterm();
  if (matchterm_ == &::google::protobuf::internal::kEmptyString) {
    matchterm_ = new ::std::string;
  }
  matchterm_->assign(value);
}
inline void OGThranMatchInfo::set_matchterm(const char* value) {
  set_has_matchterm();
  if (matchterm_ == &::google::protobuf::internal::kEmptyString) {
    matchterm_ = new ::std::string;
  }
  matchterm_->assign(value);
}
inline void OGThranMatchInfo::set_matchterm(const char* value, size_t size) {
  set_has_matchterm();
  if (matchterm_ == &::google::protobuf::internal::kEmptyString) {
    matchterm_ = new ::std::string;
  }
  matchterm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGThranMatchInfo::mutable_matchterm() {
  set_has_matchterm();
  if (matchterm_ == &::google::protobuf::internal::kEmptyString) {
    matchterm_ = new ::std::string;
  }
  return matchterm_;
}
inline ::std::string* OGThranMatchInfo::release_matchterm() {
  clear_has_matchterm();
  if (matchterm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = matchterm_;
    matchterm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 HumanLimit = 6;
inline bool OGThranMatchInfo::has_humanlimit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OGThranMatchInfo::set_has_humanlimit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OGThranMatchInfo::clear_has_humanlimit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OGThranMatchInfo::clear_humanlimit() {
  humanlimit_ = 0;
  clear_has_humanlimit();
}
inline ::google::protobuf::int32 OGThranMatchInfo::humanlimit() const {
  return humanlimit_;
}
inline void OGThranMatchInfo::set_humanlimit(::google::protobuf::int32 value) {
  set_has_humanlimit();
  humanlimit_ = value;
}

// optional int32 MatchHumanSum = 7;
inline bool OGThranMatchInfo::has_matchhumansum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OGThranMatchInfo::set_has_matchhumansum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OGThranMatchInfo::clear_has_matchhumansum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OGThranMatchInfo::clear_matchhumansum() {
  matchhumansum_ = 0;
  clear_has_matchhumansum();
}
inline ::google::protobuf::int32 OGThranMatchInfo::matchhumansum() const {
  return matchhumansum_;
}
inline void OGThranMatchInfo::set_matchhumansum(::google::protobuf::int32 value) {
  set_has_matchhumansum();
  matchhumansum_ = value;
}

// optional int32 MatchType = 8;
inline bool OGThranMatchInfo::has_matchtype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OGThranMatchInfo::set_has_matchtype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OGThranMatchInfo::clear_has_matchtype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OGThranMatchInfo::clear_matchtype() {
  matchtype_ = 0;
  clear_has_matchtype();
}
inline ::google::protobuf::int32 OGThranMatchInfo::matchtype() const {
  return matchtype_;
}
inline void OGThranMatchInfo::set_matchtype(::google::protobuf::int32 value) {
  set_has_matchtype();
  matchtype_ = value;
}

// optional int32 MatchInterval = 9;
inline bool OGThranMatchInfo::has_matchinterval() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OGThranMatchInfo::set_has_matchinterval() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OGThranMatchInfo::clear_has_matchinterval() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OGThranMatchInfo::clear_matchinterval() {
  matchinterval_ = 0;
  clear_has_matchinterval();
}
inline ::google::protobuf::int32 OGThranMatchInfo::matchinterval() const {
  return matchinterval_;
}
inline void OGThranMatchInfo::set_matchinterval(::google::protobuf::int32 value) {
  set_has_matchinterval();
  matchinterval_ = value;
}

// optional string MatchPrize = 10;
inline bool OGThranMatchInfo::has_matchprize() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OGThranMatchInfo::set_has_matchprize() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OGThranMatchInfo::clear_has_matchprize() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OGThranMatchInfo::clear_matchprize() {
  if (matchprize_ != &::google::protobuf::internal::kEmptyString) {
    matchprize_->clear();
  }
  clear_has_matchprize();
}
inline const ::std::string& OGThranMatchInfo::matchprize() const {
  return *matchprize_;
}
inline void OGThranMatchInfo::set_matchprize(const ::std::string& value) {
  set_has_matchprize();
  if (matchprize_ == &::google::protobuf::internal::kEmptyString) {
    matchprize_ = new ::std::string;
  }
  matchprize_->assign(value);
}
inline void OGThranMatchInfo::set_matchprize(const char* value) {
  set_has_matchprize();
  if (matchprize_ == &::google::protobuf::internal::kEmptyString) {
    matchprize_ = new ::std::string;
  }
  matchprize_->assign(value);
}
inline void OGThranMatchInfo::set_matchprize(const char* value, size_t size) {
  set_has_matchprize();
  if (matchprize_ == &::google::protobuf::internal::kEmptyString) {
    matchprize_ = new ::std::string;
  }
  matchprize_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGThranMatchInfo::mutable_matchprize() {
  set_has_matchprize();
  if (matchprize_ == &::google::protobuf::internal::kEmptyString) {
    matchprize_ = new ::std::string;
  }
  return matchprize_;
}
inline ::std::string* OGThranMatchInfo::release_matchprize() {
  clear_has_matchprize();
  if (matchprize_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = matchprize_;
    matchprize_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MatchProcess = 11;
inline bool OGThranMatchInfo::has_matchprocess() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OGThranMatchInfo::set_has_matchprocess() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OGThranMatchInfo::clear_has_matchprocess() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OGThranMatchInfo::clear_matchprocess() {
  if (matchprocess_ != &::google::protobuf::internal::kEmptyString) {
    matchprocess_->clear();
  }
  clear_has_matchprocess();
}
inline const ::std::string& OGThranMatchInfo::matchprocess() const {
  return *matchprocess_;
}
inline void OGThranMatchInfo::set_matchprocess(const ::std::string& value) {
  set_has_matchprocess();
  if (matchprocess_ == &::google::protobuf::internal::kEmptyString) {
    matchprocess_ = new ::std::string;
  }
  matchprocess_->assign(value);
}
inline void OGThranMatchInfo::set_matchprocess(const char* value) {
  set_has_matchprocess();
  if (matchprocess_ == &::google::protobuf::internal::kEmptyString) {
    matchprocess_ = new ::std::string;
  }
  matchprocess_->assign(value);
}
inline void OGThranMatchInfo::set_matchprocess(const char* value, size_t size) {
  set_has_matchprocess();
  if (matchprocess_ == &::google::protobuf::internal::kEmptyString) {
    matchprocess_ = new ::std::string;
  }
  matchprocess_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGThranMatchInfo::mutable_matchprocess() {
  set_has_matchprocess();
  if (matchprocess_ == &::google::protobuf::internal::kEmptyString) {
    matchprocess_ = new ::std::string;
  }
  return matchprocess_;
}
inline ::std::string* OGThranMatchInfo::release_matchprocess() {
  clear_has_matchprocess();
  if (matchprocess_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = matchprocess_;
    matchprocess_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MatchDate = 12;
inline bool OGThranMatchInfo::has_matchdate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OGThranMatchInfo::set_has_matchdate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OGThranMatchInfo::clear_has_matchdate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OGThranMatchInfo::clear_matchdate() {
  if (matchdate_ != &::google::protobuf::internal::kEmptyString) {
    matchdate_->clear();
  }
  clear_has_matchdate();
}
inline const ::std::string& OGThranMatchInfo::matchdate() const {
  return *matchdate_;
}
inline void OGThranMatchInfo::set_matchdate(const ::std::string& value) {
  set_has_matchdate();
  if (matchdate_ == &::google::protobuf::internal::kEmptyString) {
    matchdate_ = new ::std::string;
  }
  matchdate_->assign(value);
}
inline void OGThranMatchInfo::set_matchdate(const char* value) {
  set_has_matchdate();
  if (matchdate_ == &::google::protobuf::internal::kEmptyString) {
    matchdate_ = new ::std::string;
  }
  matchdate_->assign(value);
}
inline void OGThranMatchInfo::set_matchdate(const char* value, size_t size) {
  set_has_matchdate();
  if (matchdate_ == &::google::protobuf::internal::kEmptyString) {
    matchdate_ = new ::std::string;
  }
  matchdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGThranMatchInfo::mutable_matchdate() {
  set_has_matchdate();
  if (matchdate_ == &::google::protobuf::internal::kEmptyString) {
    matchdate_ = new ::std::string;
  }
  return matchdate_;
}
inline ::std::string* OGThranMatchInfo::release_matchdate() {
  clear_has_matchdate();
  if (matchdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = matchdate_;
    matchdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MatchFee = 13;
inline bool OGThranMatchInfo::has_matchfee() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void OGThranMatchInfo::set_has_matchfee() {
  _has_bits_[0] |= 0x00001000u;
}
inline void OGThranMatchInfo::clear_has_matchfee() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void OGThranMatchInfo::clear_matchfee() {
  if (matchfee_ != &::google::protobuf::internal::kEmptyString) {
    matchfee_->clear();
  }
  clear_has_matchfee();
}
inline const ::std::string& OGThranMatchInfo::matchfee() const {
  return *matchfee_;
}
inline void OGThranMatchInfo::set_matchfee(const ::std::string& value) {
  set_has_matchfee();
  if (matchfee_ == &::google::protobuf::internal::kEmptyString) {
    matchfee_ = new ::std::string;
  }
  matchfee_->assign(value);
}
inline void OGThranMatchInfo::set_matchfee(const char* value) {
  set_has_matchfee();
  if (matchfee_ == &::google::protobuf::internal::kEmptyString) {
    matchfee_ = new ::std::string;
  }
  matchfee_->assign(value);
}
inline void OGThranMatchInfo::set_matchfee(const char* value, size_t size) {
  set_has_matchfee();
  if (matchfee_ == &::google::protobuf::internal::kEmptyString) {
    matchfee_ = new ::std::string;
  }
  matchfee_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGThranMatchInfo::mutable_matchfee() {
  set_has_matchfee();
  if (matchfee_ == &::google::protobuf::internal::kEmptyString) {
    matchfee_ = new ::std::string;
  }
  return matchfee_;
}
inline ::std::string* OGThranMatchInfo::release_matchfee() {
  clear_has_matchfee();
  if (matchfee_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = matchfee_;
    matchfee_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 MatchArea = 14;
inline bool OGThranMatchInfo::has_matcharea() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void OGThranMatchInfo::set_has_matcharea() {
  _has_bits_[0] |= 0x00002000u;
}
inline void OGThranMatchInfo::clear_has_matcharea() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void OGThranMatchInfo::clear_matcharea() {
  matcharea_ = 0;
  clear_has_matcharea();
}
inline ::google::protobuf::int32 OGThranMatchInfo::matcharea() const {
  return matcharea_;
}
inline void OGThranMatchInfo::set_matcharea(::google::protobuf::int32 value) {
  set_has_matcharea();
  matcharea_ = value;
}

// optional string Description = 15;
inline bool OGThranMatchInfo::has_description() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void OGThranMatchInfo::set_has_description() {
  _has_bits_[0] |= 0x00004000u;
}
inline void OGThranMatchInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void OGThranMatchInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& OGThranMatchInfo::description() const {
  return *description_;
}
inline void OGThranMatchInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void OGThranMatchInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void OGThranMatchInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGThranMatchInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* OGThranMatchInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ThranRoomInfo

// optional int32 GameID = 1;
inline bool ThranRoomInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThranRoomInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThranRoomInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThranRoomInfo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ThranRoomInfo::gameid() const {
  return gameid_;
}
inline void ThranRoomInfo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional int32 GroupID = 2;
inline bool ThranRoomInfo::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThranRoomInfo::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThranRoomInfo::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThranRoomInfo::clear_groupid() {
  groupid_ = 0;
  clear_has_groupid();
}
inline ::google::protobuf::int32 ThranRoomInfo::groupid() const {
  return groupid_;
}
inline void ThranRoomInfo::set_groupid(::google::protobuf::int32 value) {
  set_has_groupid();
  groupid_ = value;
}

// optional bytes RoomID = 3;
inline bool ThranRoomInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThranRoomInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ThranRoomInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ThranRoomInfo::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ThranRoomInfo::roomid() const {
  return *roomid_;
}
inline void ThranRoomInfo::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ThranRoomInfo::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ThranRoomInfo::set_roomid(const void* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ThranRoomInfo::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ThranRoomInfo::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 MaxPlayer = 4;
inline bool ThranRoomInfo::has_maxplayer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ThranRoomInfo::set_has_maxplayer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ThranRoomInfo::clear_has_maxplayer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ThranRoomInfo::clear_maxplayer() {
  maxplayer_ = 0;
  clear_has_maxplayer();
}
inline ::google::protobuf::int32 ThranRoomInfo::maxplayer() const {
  return maxplayer_;
}
inline void ThranRoomInfo::set_maxplayer(::google::protobuf::int32 value) {
  set_has_maxplayer();
  maxplayer_ = value;
}

// optional string RoomIP = 5;
inline bool ThranRoomInfo::has_roomip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ThranRoomInfo::set_has_roomip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ThranRoomInfo::clear_has_roomip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ThranRoomInfo::clear_roomip() {
  if (roomip_ != &::google::protobuf::internal::kEmptyString) {
    roomip_->clear();
  }
  clear_has_roomip();
}
inline const ::std::string& ThranRoomInfo::roomip() const {
  return *roomip_;
}
inline void ThranRoomInfo::set_roomip(const ::std::string& value) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(value);
}
inline void ThranRoomInfo::set_roomip(const char* value) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(value);
}
inline void ThranRoomInfo::set_roomip(const char* value, size_t size) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ThranRoomInfo::mutable_roomip() {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  return roomip_;
}
inline ::std::string* ThranRoomInfo::release_roomip() {
  clear_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomip_;
    roomip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 RoomPort = 6;
inline bool ThranRoomInfo::has_roomport() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ThranRoomInfo::set_has_roomport() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ThranRoomInfo::clear_has_roomport() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ThranRoomInfo::clear_roomport() {
  roomport_ = 0;
  clear_has_roomport();
}
inline ::google::protobuf::int32 ThranRoomInfo::roomport() const {
  return roomport_;
}
inline void ThranRoomInfo::set_roomport(::google::protobuf::int32 value) {
  set_has_roomport();
  roomport_ = value;
}

// optional bytes Context = 7;
inline bool ThranRoomInfo::has_context() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ThranRoomInfo::set_has_context() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ThranRoomInfo::clear_has_context() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ThranRoomInfo::clear_context() {
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    context_->clear();
  }
  clear_has_context();
}
inline const ::std::string& ThranRoomInfo::context() const {
  return *context_;
}
inline void ThranRoomInfo::set_context(const ::std::string& value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(value);
}
inline void ThranRoomInfo::set_context(const char* value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(value);
}
inline void ThranRoomInfo::set_context(const void* value, size_t size) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ThranRoomInfo::mutable_context() {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  return context_;
}
inline ::std::string* ThranRoomInfo::release_context() {
  clear_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = context_;
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 CurPlayer = 8;
inline bool ThranRoomInfo::has_curplayer() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ThranRoomInfo::set_has_curplayer() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ThranRoomInfo::clear_has_curplayer() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ThranRoomInfo::clear_curplayer() {
  curplayer_ = 0;
  clear_has_curplayer();
}
inline ::google::protobuf::int32 ThranRoomInfo::curplayer() const {
  return curplayer_;
}
inline void ThranRoomInfo::set_curplayer(::google::protobuf::int32 value) {
  set_has_curplayer();
  curplayer_ = value;
}

// optional int32 RoomState = 9;
inline bool ThranRoomInfo::has_roomstate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ThranRoomInfo::set_has_roomstate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ThranRoomInfo::clear_has_roomstate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ThranRoomInfo::clear_roomstate() {
  roomstate_ = 0;
  clear_has_roomstate();
}
inline ::google::protobuf::int32 ThranRoomInfo::roomstate() const {
  return roomstate_;
}
inline void ThranRoomInfo::set_roomstate(::google::protobuf::int32 value) {
  set_has_roomstate();
  roomstate_ = value;
}

// optional int32 IsLock = 10 [default = 0];
inline bool ThranRoomInfo::has_islock() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ThranRoomInfo::set_has_islock() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ThranRoomInfo::clear_has_islock() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ThranRoomInfo::clear_islock() {
  islock_ = 0;
  clear_has_islock();
}
inline ::google::protobuf::int32 ThranRoomInfo::islock() const {
  return islock_;
}
inline void ThranRoomInfo::set_islock(::google::protobuf::int32 value) {
  set_has_islock();
  islock_ = value;
}

// repeated .ThranRoomInfo ThranRoomItems = 11;
inline int ThranRoomInfo::thranroomitems_size() const {
  return thranroomitems_.size();
}
inline void ThranRoomInfo::clear_thranroomitems() {
  thranroomitems_.Clear();
}
inline const ::ThranRoomInfo& ThranRoomInfo::thranroomitems(int index) const {
  return thranroomitems_.Get(index);
}
inline ::ThranRoomInfo* ThranRoomInfo::mutable_thranroomitems(int index) {
  return thranroomitems_.Mutable(index);
}
inline ::ThranRoomInfo* ThranRoomInfo::add_thranroomitems() {
  return thranroomitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ThranRoomInfo >&
ThranRoomInfo::thranroomitems() const {
  return thranroomitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::ThranRoomInfo >*
ThranRoomInfo::mutable_thranroomitems() {
  return &thranroomitems_;
}

// -------------------------------------------------------------------

// ThranJSSInfo

// optional string RoomIP = 1;
inline bool ThranJSSInfo::has_roomip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThranJSSInfo::set_has_roomip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThranJSSInfo::clear_has_roomip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThranJSSInfo::clear_roomip() {
  if (roomip_ != &::google::protobuf::internal::kEmptyString) {
    roomip_->clear();
  }
  clear_has_roomip();
}
inline const ::std::string& ThranJSSInfo::roomip() const {
  return *roomip_;
}
inline void ThranJSSInfo::set_roomip(const ::std::string& value) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(value);
}
inline void ThranJSSInfo::set_roomip(const char* value) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(value);
}
inline void ThranJSSInfo::set_roomip(const char* value, size_t size) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ThranJSSInfo::mutable_roomip() {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  return roomip_;
}
inline ::std::string* ThranJSSInfo::release_roomip() {
  clear_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomip_;
    roomip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RoomPort = 2;
inline bool ThranJSSInfo::has_roomport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThranJSSInfo::set_has_roomport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThranJSSInfo::clear_has_roomport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThranJSSInfo::clear_roomport() {
  if (roomport_ != &::google::protobuf::internal::kEmptyString) {
    roomport_->clear();
  }
  clear_has_roomport();
}
inline const ::std::string& ThranJSSInfo::roomport() const {
  return *roomport_;
}
inline void ThranJSSInfo::set_roomport(const ::std::string& value) {
  set_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    roomport_ = new ::std::string;
  }
  roomport_->assign(value);
}
inline void ThranJSSInfo::set_roomport(const char* value) {
  set_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    roomport_ = new ::std::string;
  }
  roomport_->assign(value);
}
inline void ThranJSSInfo::set_roomport(const char* value, size_t size) {
  set_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    roomport_ = new ::std::string;
  }
  roomport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ThranJSSInfo::mutable_roomport() {
  set_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    roomport_ = new ::std::string;
  }
  return roomport_;
}
inline ::std::string* ThranJSSInfo::release_roomport() {
  clear_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomport_;
    roomport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Remark = 3;
inline bool ThranJSSInfo::has_remark() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThranJSSInfo::set_has_remark() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ThranJSSInfo::clear_has_remark() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ThranJSSInfo::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& ThranJSSInfo::remark() const {
  return *remark_;
}
inline void ThranJSSInfo::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void ThranJSSInfo::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void ThranJSSInfo::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ThranJSSInfo::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* ThranJSSInfo::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// OGBulletinInfo

// optional bytes Title = 1;
inline bool OGBulletinInfo::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OGBulletinInfo::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OGBulletinInfo::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OGBulletinInfo::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& OGBulletinInfo::title() const {
  return *title_;
}
inline void OGBulletinInfo::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void OGBulletinInfo::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void OGBulletinInfo::set_title(const void* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGBulletinInfo::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* OGBulletinInfo::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes Content = 2;
inline bool OGBulletinInfo::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OGBulletinInfo::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OGBulletinInfo::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OGBulletinInfo::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& OGBulletinInfo::content() const {
  return *content_;
}
inline void OGBulletinInfo::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void OGBulletinInfo::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void OGBulletinInfo::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OGBulletinInfo::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* OGBulletinInfo::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// REQQuickConn

// optional bytes UserName = 1;
inline bool REQQuickConn::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQQuickConn::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQQuickConn::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQQuickConn::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& REQQuickConn::username() const {
  return *username_;
}
inline void REQQuickConn::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void REQQuickConn::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void REQQuickConn::set_username(const void* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQQuickConn::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* REQQuickConn::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Pwd = 2;
inline bool REQQuickConn::has_pwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQQuickConn::set_has_pwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQQuickConn::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQQuickConn::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& REQQuickConn::pwd() const {
  return *pwd_;
}
inline void REQQuickConn::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void REQQuickConn::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void REQQuickConn::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQQuickConn::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  return pwd_;
}
inline ::std::string* REQQuickConn::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecureID = 3;
inline bool REQQuickConn::has_secureid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQQuickConn::set_has_secureid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQQuickConn::clear_has_secureid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQQuickConn::clear_secureid() {
  if (secureid_ != &::google::protobuf::internal::kEmptyString) {
    secureid_->clear();
  }
  clear_has_secureid();
}
inline const ::std::string& REQQuickConn::secureid() const {
  return *secureid_;
}
inline void REQQuickConn::set_secureid(const ::std::string& value) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(value);
}
inline void REQQuickConn::set_secureid(const char* value) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(value);
}
inline void REQQuickConn::set_secureid(const char* value, size_t size) {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  secureid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQQuickConn::mutable_secureid() {
  set_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    secureid_ = new ::std::string;
  }
  return secureid_;
}
inline ::std::string* REQQuickConn::release_secureid() {
  clear_has_secureid();
  if (secureid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secureid_;
    secureid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 ComeFromID = 4;
inline bool REQQuickConn::has_comefromid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void REQQuickConn::set_has_comefromid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void REQQuickConn::clear_has_comefromid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void REQQuickConn::clear_comefromid() {
  comefromid_ = 0;
  clear_has_comefromid();
}
inline ::google::protobuf::int32 REQQuickConn::comefromid() const {
  return comefromid_;
}
inline void REQQuickConn::set_comefromid(::google::protobuf::int32 value) {
  set_has_comefromid();
  comefromid_ = value;
}

// required string ChannelID = 5;
inline bool REQQuickConn::has_channelid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void REQQuickConn::set_has_channelid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void REQQuickConn::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void REQQuickConn::clear_channelid() {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    channelid_->clear();
  }
  clear_has_channelid();
}
inline const ::std::string& REQQuickConn::channelid() const {
  return *channelid_;
}
inline void REQQuickConn::set_channelid(const ::std::string& value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQQuickConn::set_channelid(const char* value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void REQQuickConn::set_channelid(const char* value, size_t size) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQQuickConn::mutable_channelid() {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  return channelid_;
}
inline ::std::string* REQQuickConn::release_channelid() {
  clear_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channelid_;
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 GameId = 6;
inline bool REQQuickConn::has_gameid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void REQQuickConn::set_has_gameid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void REQQuickConn::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void REQQuickConn::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 REQQuickConn::gameid() const {
  return gameid_;
}
inline void REQQuickConn::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required string token = 7;
inline bool REQQuickConn::has_token() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void REQQuickConn::set_has_token() {
  _has_bits_[0] |= 0x00000040u;
}
inline void REQQuickConn::clear_has_token() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void REQQuickConn::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& REQQuickConn::token() const {
  return *token_;
}
inline void REQQuickConn::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void REQQuickConn::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void REQQuickConn::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQQuickConn::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* REQQuickConn::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 RoomAdapte = 8 [default = 0];
inline bool REQQuickConn::has_roomadapte() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void REQQuickConn::set_has_roomadapte() {
  _has_bits_[0] |= 0x00000080u;
}
inline void REQQuickConn::clear_has_roomadapte() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void REQQuickConn::clear_roomadapte() {
  roomadapte_ = 0;
  clear_has_roomadapte();
}
inline ::google::protobuf::int32 REQQuickConn::roomadapte() const {
  return roomadapte_;
}
inline void REQQuickConn::set_roomadapte(::google::protobuf::int32 value) {
  set_has_roomadapte();
  roomadapte_ = value;
}

// optional int32 LoginType = 9 [default = 0];
inline bool REQQuickConn::has_logintype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void REQQuickConn::set_has_logintype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void REQQuickConn::clear_has_logintype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void REQQuickConn::clear_logintype() {
  logintype_ = 0;
  clear_has_logintype();
}
inline ::google::protobuf::int32 REQQuickConn::logintype() const {
  return logintype_;
}
inline void REQQuickConn::set_logintype(::google::protobuf::int32 value) {
  set_has_logintype();
  logintype_ = value;
}

// required int32 CurVersion = 10;
inline bool REQQuickConn::has_curversion() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void REQQuickConn::set_has_curversion() {
  _has_bits_[0] |= 0x00000200u;
}
inline void REQQuickConn::clear_has_curversion() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void REQQuickConn::clear_curversion() {
  curversion_ = 0;
  clear_has_curversion();
}
inline ::google::protobuf::int32 REQQuickConn::curversion() const {
  return curversion_;
}
inline void REQQuickConn::set_curversion(::google::protobuf::int32 value) {
  set_has_curversion();
  curversion_ = value;
}

// optional int32 smallVersion = 11;
inline bool REQQuickConn::has_smallversion() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void REQQuickConn::set_has_smallversion() {
  _has_bits_[0] |= 0x00000400u;
}
inline void REQQuickConn::clear_has_smallversion() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void REQQuickConn::clear_smallversion() {
  smallversion_ = 0;
  clear_has_smallversion();
}
inline ::google::protobuf::int32 REQQuickConn::smallversion() const {
  return smallversion_;
}
inline void REQQuickConn::set_smallversion(::google::protobuf::int32 value) {
  set_has_smallversion();
  smallversion_ = value;
}

// required string ResolutionID = 12;
inline bool REQQuickConn::has_resolutionid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void REQQuickConn::set_has_resolutionid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void REQQuickConn::clear_has_resolutionid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void REQQuickConn::clear_resolutionid() {
  if (resolutionid_ != &::google::protobuf::internal::kEmptyString) {
    resolutionid_->clear();
  }
  clear_has_resolutionid();
}
inline const ::std::string& REQQuickConn::resolutionid() const {
  return *resolutionid_;
}
inline void REQQuickConn::set_resolutionid(const ::std::string& value) {
  set_has_resolutionid();
  if (resolutionid_ == &::google::protobuf::internal::kEmptyString) {
    resolutionid_ = new ::std::string;
  }
  resolutionid_->assign(value);
}
inline void REQQuickConn::set_resolutionid(const char* value) {
  set_has_resolutionid();
  if (resolutionid_ == &::google::protobuf::internal::kEmptyString) {
    resolutionid_ = new ::std::string;
  }
  resolutionid_->assign(value);
}
inline void REQQuickConn::set_resolutionid(const char* value, size_t size) {
  set_has_resolutionid();
  if (resolutionid_ == &::google::protobuf::internal::kEmptyString) {
    resolutionid_ = new ::std::string;
  }
  resolutionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQQuickConn::mutable_resolutionid() {
  set_has_resolutionid();
  if (resolutionid_ == &::google::protobuf::internal::kEmptyString) {
    resolutionid_ = new ::std::string;
  }
  return resolutionid_;
}
inline ::std::string* REQQuickConn::release_resolutionid() {
  clear_has_resolutionid();
  if (resolutionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resolutionid_;
    resolutionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string LanguageID = 13;
inline bool REQQuickConn::has_languageid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void REQQuickConn::set_has_languageid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void REQQuickConn::clear_has_languageid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void REQQuickConn::clear_languageid() {
  if (languageid_ != &::google::protobuf::internal::kEmptyString) {
    languageid_->clear();
  }
  clear_has_languageid();
}
inline const ::std::string& REQQuickConn::languageid() const {
  return *languageid_;
}
inline void REQQuickConn::set_languageid(const ::std::string& value) {
  set_has_languageid();
  if (languageid_ == &::google::protobuf::internal::kEmptyString) {
    languageid_ = new ::std::string;
  }
  languageid_->assign(value);
}
inline void REQQuickConn::set_languageid(const char* value) {
  set_has_languageid();
  if (languageid_ == &::google::protobuf::internal::kEmptyString) {
    languageid_ = new ::std::string;
  }
  languageid_->assign(value);
}
inline void REQQuickConn::set_languageid(const char* value, size_t size) {
  set_has_languageid();
  if (languageid_ == &::google::protobuf::internal::kEmptyString) {
    languageid_ = new ::std::string;
  }
  languageid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQQuickConn::mutable_languageid() {
  set_has_languageid();
  if (languageid_ == &::google::protobuf::internal::kEmptyString) {
    languageid_ = new ::std::string;
  }
  return languageid_;
}
inline ::std::string* REQQuickConn::release_languageid() {
  clear_has_languageid();
  if (languageid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = languageid_;
    languageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ScreenSize = 14;
inline bool REQQuickConn::has_screensize() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void REQQuickConn::set_has_screensize() {
  _has_bits_[0] |= 0x00002000u;
}
inline void REQQuickConn::clear_has_screensize() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void REQQuickConn::clear_screensize() {
  if (screensize_ != &::google::protobuf::internal::kEmptyString) {
    screensize_->clear();
  }
  clear_has_screensize();
}
inline const ::std::string& REQQuickConn::screensize() const {
  return *screensize_;
}
inline void REQQuickConn::set_screensize(const ::std::string& value) {
  set_has_screensize();
  if (screensize_ == &::google::protobuf::internal::kEmptyString) {
    screensize_ = new ::std::string;
  }
  screensize_->assign(value);
}
inline void REQQuickConn::set_screensize(const char* value) {
  set_has_screensize();
  if (screensize_ == &::google::protobuf::internal::kEmptyString) {
    screensize_ = new ::std::string;
  }
  screensize_->assign(value);
}
inline void REQQuickConn::set_screensize(const char* value, size_t size) {
  set_has_screensize();
  if (screensize_ == &::google::protobuf::internal::kEmptyString) {
    screensize_ = new ::std::string;
  }
  screensize_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQQuickConn::mutable_screensize() {
  set_has_screensize();
  if (screensize_ == &::google::protobuf::internal::kEmptyString) {
    screensize_ = new ::std::string;
  }
  return screensize_;
}
inline ::std::string* REQQuickConn::release_screensize() {
  clear_has_screensize();
  if (screensize_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = screensize_;
    screensize_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ThirdDigitalName = 15;
inline bool REQQuickConn::has_thirddigitalname() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void REQQuickConn::set_has_thirddigitalname() {
  _has_bits_[0] |= 0x00004000u;
}
inline void REQQuickConn::clear_has_thirddigitalname() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void REQQuickConn::clear_thirddigitalname() {
  if (thirddigitalname_ != &::google::protobuf::internal::kEmptyString) {
    thirddigitalname_->clear();
  }
  clear_has_thirddigitalname();
}
inline const ::std::string& REQQuickConn::thirddigitalname() const {
  return *thirddigitalname_;
}
inline void REQQuickConn::set_thirddigitalname(const ::std::string& value) {
  set_has_thirddigitalname();
  if (thirddigitalname_ == &::google::protobuf::internal::kEmptyString) {
    thirddigitalname_ = new ::std::string;
  }
  thirddigitalname_->assign(value);
}
inline void REQQuickConn::set_thirddigitalname(const char* value) {
  set_has_thirddigitalname();
  if (thirddigitalname_ == &::google::protobuf::internal::kEmptyString) {
    thirddigitalname_ = new ::std::string;
  }
  thirddigitalname_->assign(value);
}
inline void REQQuickConn::set_thirddigitalname(const char* value, size_t size) {
  set_has_thirddigitalname();
  if (thirddigitalname_ == &::google::protobuf::internal::kEmptyString) {
    thirddigitalname_ = new ::std::string;
  }
  thirddigitalname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQQuickConn::mutable_thirddigitalname() {
  set_has_thirddigitalname();
  if (thirddigitalname_ == &::google::protobuf::internal::kEmptyString) {
    thirddigitalname_ = new ::std::string;
  }
  return thirddigitalname_;
}
inline ::std::string* REQQuickConn::release_thirddigitalname() {
  clear_has_thirddigitalname();
  if (thirddigitalname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = thirddigitalname_;
    thirddigitalname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Thirdkey = 16;
inline bool REQQuickConn::has_thirdkey() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void REQQuickConn::set_has_thirdkey() {
  _has_bits_[0] |= 0x00008000u;
}
inline void REQQuickConn::clear_has_thirdkey() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void REQQuickConn::clear_thirdkey() {
  if (thirdkey_ != &::google::protobuf::internal::kEmptyString) {
    thirdkey_->clear();
  }
  clear_has_thirdkey();
}
inline const ::std::string& REQQuickConn::thirdkey() const {
  return *thirdkey_;
}
inline void REQQuickConn::set_thirdkey(const ::std::string& value) {
  set_has_thirdkey();
  if (thirdkey_ == &::google::protobuf::internal::kEmptyString) {
    thirdkey_ = new ::std::string;
  }
  thirdkey_->assign(value);
}
inline void REQQuickConn::set_thirdkey(const char* value) {
  set_has_thirdkey();
  if (thirdkey_ == &::google::protobuf::internal::kEmptyString) {
    thirdkey_ = new ::std::string;
  }
  thirdkey_->assign(value);
}
inline void REQQuickConn::set_thirdkey(const char* value, size_t size) {
  set_has_thirdkey();
  if (thirdkey_ == &::google::protobuf::internal::kEmptyString) {
    thirdkey_ = new ::std::string;
  }
  thirdkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQQuickConn::mutable_thirdkey() {
  set_has_thirdkey();
  if (thirdkey_ == &::google::protobuf::internal::kEmptyString) {
    thirdkey_ = new ::std::string;
  }
  return thirdkey_;
}
inline ::std::string* REQQuickConn::release_thirdkey() {
  clear_has_thirdkey();
  if (thirdkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = thirdkey_;
    thirdkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ThirdAppId = 17;
inline bool REQQuickConn::has_thirdappid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void REQQuickConn::set_has_thirdappid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void REQQuickConn::clear_has_thirdappid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void REQQuickConn::clear_thirdappid() {
  if (thirdappid_ != &::google::protobuf::internal::kEmptyString) {
    thirdappid_->clear();
  }
  clear_has_thirdappid();
}
inline const ::std::string& REQQuickConn::thirdappid() const {
  return *thirdappid_;
}
inline void REQQuickConn::set_thirdappid(const ::std::string& value) {
  set_has_thirdappid();
  if (thirdappid_ == &::google::protobuf::internal::kEmptyString) {
    thirdappid_ = new ::std::string;
  }
  thirdappid_->assign(value);
}
inline void REQQuickConn::set_thirdappid(const char* value) {
  set_has_thirdappid();
  if (thirdappid_ == &::google::protobuf::internal::kEmptyString) {
    thirdappid_ = new ::std::string;
  }
  thirdappid_->assign(value);
}
inline void REQQuickConn::set_thirdappid(const char* value, size_t size) {
  set_has_thirdappid();
  if (thirdappid_ == &::google::protobuf::internal::kEmptyString) {
    thirdappid_ = new ::std::string;
  }
  thirdappid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQQuickConn::mutable_thirdappid() {
  set_has_thirdappid();
  if (thirdappid_ == &::google::protobuf::internal::kEmptyString) {
    thirdappid_ = new ::std::string;
  }
  return thirdappid_;
}
inline ::std::string* REQQuickConn::release_thirdappid() {
  clear_has_thirdappid();
  if (thirdappid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = thirdappid_;
    thirdappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Package = 18;
inline bool REQQuickConn::has_package() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void REQQuickConn::set_has_package() {
  _has_bits_[0] |= 0x00020000u;
}
inline void REQQuickConn::clear_has_package() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void REQQuickConn::clear_package() {
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    package_->clear();
  }
  clear_has_package();
}
inline const ::std::string& REQQuickConn::package() const {
  return *package_;
}
inline void REQQuickConn::set_package(const ::std::string& value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void REQQuickConn::set_package(const char* value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void REQQuickConn::set_package(const char* value, size_t size) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQQuickConn::mutable_package() {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  return package_;
}
inline ::std::string* REQQuickConn::release_package() {
  clear_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_;
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ACKQuickConn

// required int32 AckResult = 1;
inline bool ACKQuickConn::has_ackresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKQuickConn::set_has_ackresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKQuickConn::clear_has_ackresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKQuickConn::clear_ackresult() {
  ackresult_ = 0;
  clear_has_ackresult();
}
inline ::google::protobuf::int32 ACKQuickConn::ackresult() const {
  return ackresult_;
}
inline void ACKQuickConn::set_ackresult(::google::protobuf::int32 value) {
  set_has_ackresult();
  ackresult_ = value;
}

// optional string UserName = 2;
inline bool ACKQuickConn::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKQuickConn::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKQuickConn::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKQuickConn::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ACKQuickConn::username() const {
  return *username_;
}
inline void ACKQuickConn::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ACKQuickConn::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ACKQuickConn::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKQuickConn::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ACKQuickConn::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoleName = 3;
inline bool ACKQuickConn::has_rolename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKQuickConn::set_has_rolename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKQuickConn::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKQuickConn::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& ACKQuickConn::rolename() const {
  return *rolename_;
}
inline void ACKQuickConn::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void ACKQuickConn::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void ACKQuickConn::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKQuickConn::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* ACKQuickConn::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 YuanBaoCnt = 4;
inline bool ACKQuickConn::has_yuanbaocnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACKQuickConn::set_has_yuanbaocnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACKQuickConn::clear_has_yuanbaocnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACKQuickConn::clear_yuanbaocnt() {
  yuanbaocnt_ = 0;
  clear_has_yuanbaocnt();
}
inline ::google::protobuf::int32 ACKQuickConn::yuanbaocnt() const {
  return yuanbaocnt_;
}
inline void ACKQuickConn::set_yuanbaocnt(::google::protobuf::int32 value) {
  set_has_yuanbaocnt();
  yuanbaocnt_ = value;
}

// required int64 CoinCnt = 5;
inline bool ACKQuickConn::has_coincnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ACKQuickConn::set_has_coincnt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ACKQuickConn::clear_has_coincnt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ACKQuickConn::clear_coincnt() {
  coincnt_ = GOOGLE_LONGLONG(0);
  clear_has_coincnt();
}
inline ::google::protobuf::int64 ACKQuickConn::coincnt() const {
  return coincnt_;
}
inline void ACKQuickConn::set_coincnt(::google::protobuf::int64 value) {
  set_has_coincnt();
  coincnt_ = value;
}

// repeated .OGRoomInfo RoomList = 6;
inline int ACKQuickConn::roomlist_size() const {
  return roomlist_.size();
}
inline void ACKQuickConn::clear_roomlist() {
  roomlist_.Clear();
}
inline const ::OGRoomInfo& ACKQuickConn::roomlist(int index) const {
  return roomlist_.Get(index);
}
inline ::OGRoomInfo* ACKQuickConn::mutable_roomlist(int index) {
  return roomlist_.Mutable(index);
}
inline ::OGRoomInfo* ACKQuickConn::add_roomlist() {
  return roomlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
ACKQuickConn::roomlist() const {
  return roomlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
ACKQuickConn::mutable_roomlist() {
  return &roomlist_;
}

// repeated .OGThranMatchInfo MatchRoomList = 7;
inline int ACKQuickConn::matchroomlist_size() const {
  return matchroomlist_.size();
}
inline void ACKQuickConn::clear_matchroomlist() {
  matchroomlist_.Clear();
}
inline const ::OGThranMatchInfo& ACKQuickConn::matchroomlist(int index) const {
  return matchroomlist_.Get(index);
}
inline ::OGThranMatchInfo* ACKQuickConn::mutable_matchroomlist(int index) {
  return matchroomlist_.Mutable(index);
}
inline ::OGThranMatchInfo* ACKQuickConn::add_matchroomlist() {
  return matchroomlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OGThranMatchInfo >&
ACKQuickConn::matchroomlist() const {
  return matchroomlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OGThranMatchInfo >*
ACKQuickConn::mutable_matchroomlist() {
  return &matchroomlist_;
}

// optional bytes Cert = 8;
inline bool ACKQuickConn::has_cert() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ACKQuickConn::set_has_cert() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ACKQuickConn::clear_has_cert() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ACKQuickConn::clear_cert() {
  if (cert_ != &::google::protobuf::internal::kEmptyString) {
    cert_->clear();
  }
  clear_has_cert();
}
inline const ::std::string& ACKQuickConn::cert() const {
  return *cert_;
}
inline void ACKQuickConn::set_cert(const ::std::string& value) {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    cert_ = new ::std::string;
  }
  cert_->assign(value);
}
inline void ACKQuickConn::set_cert(const char* value) {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    cert_ = new ::std::string;
  }
  cert_->assign(value);
}
inline void ACKQuickConn::set_cert(const void* value, size_t size) {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    cert_ = new ::std::string;
  }
  cert_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKQuickConn::mutable_cert() {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    cert_ = new ::std::string;
  }
  return cert_;
}
inline ::std::string* ACKQuickConn::release_cert() {
  clear_has_cert();
  if (cert_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cert_;
    cert_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes CertNoCert = 9;
inline bool ACKQuickConn::has_certnocert() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ACKQuickConn::set_has_certnocert() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ACKQuickConn::clear_has_certnocert() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ACKQuickConn::clear_certnocert() {
  if (certnocert_ != &::google::protobuf::internal::kEmptyString) {
    certnocert_->clear();
  }
  clear_has_certnocert();
}
inline const ::std::string& ACKQuickConn::certnocert() const {
  return *certnocert_;
}
inline void ACKQuickConn::set_certnocert(const ::std::string& value) {
  set_has_certnocert();
  if (certnocert_ == &::google::protobuf::internal::kEmptyString) {
    certnocert_ = new ::std::string;
  }
  certnocert_->assign(value);
}
inline void ACKQuickConn::set_certnocert(const char* value) {
  set_has_certnocert();
  if (certnocert_ == &::google::protobuf::internal::kEmptyString) {
    certnocert_ = new ::std::string;
  }
  certnocert_->assign(value);
}
inline void ACKQuickConn::set_certnocert(const void* value, size_t size) {
  set_has_certnocert();
  if (certnocert_ == &::google::protobuf::internal::kEmptyString) {
    certnocert_ = new ::std::string;
  }
  certnocert_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKQuickConn::mutable_certnocert() {
  set_has_certnocert();
  if (certnocert_ == &::google::protobuf::internal::kEmptyString) {
    certnocert_ = new ::std::string;
  }
  return certnocert_;
}
inline ::std::string* ACKQuickConn::release_certnocert() {
  clear_has_certnocert();
  if (certnocert_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = certnocert_;
    certnocert_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 CurVersion = 10;
inline bool ACKQuickConn::has_curversion() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ACKQuickConn::set_has_curversion() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ACKQuickConn::clear_has_curversion() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ACKQuickConn::clear_curversion() {
  curversion_ = 0;
  clear_has_curversion();
}
inline ::google::protobuf::int32 ACKQuickConn::curversion() const {
  return curversion_;
}
inline void ACKQuickConn::set_curversion(::google::protobuf::int32 value) {
  set_has_curversion();
  curversion_ = value;
}

// required string PlayEnable = 11;
inline bool ACKQuickConn::has_playenable() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ACKQuickConn::set_has_playenable() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ACKQuickConn::clear_has_playenable() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ACKQuickConn::clear_playenable() {
  if (playenable_ != &::google::protobuf::internal::kEmptyString) {
    playenable_->clear();
  }
  clear_has_playenable();
}
inline const ::std::string& ACKQuickConn::playenable() const {
  return *playenable_;
}
inline void ACKQuickConn::set_playenable(const ::std::string& value) {
  set_has_playenable();
  if (playenable_ == &::google::protobuf::internal::kEmptyString) {
    playenable_ = new ::std::string;
  }
  playenable_->assign(value);
}
inline void ACKQuickConn::set_playenable(const char* value) {
  set_has_playenable();
  if (playenable_ == &::google::protobuf::internal::kEmptyString) {
    playenable_ = new ::std::string;
  }
  playenable_->assign(value);
}
inline void ACKQuickConn::set_playenable(const char* value, size_t size) {
  set_has_playenable();
  if (playenable_ == &::google::protobuf::internal::kEmptyString) {
    playenable_ = new ::std::string;
  }
  playenable_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKQuickConn::mutable_playenable() {
  set_has_playenable();
  if (playenable_ == &::google::protobuf::internal::kEmptyString) {
    playenable_ = new ::std::string;
  }
  return playenable_;
}
inline ::std::string* ACKQuickConn::release_playenable() {
  clear_has_playenable();
  if (playenable_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playenable_;
    playenable_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string DownloadUrl = 12;
inline bool ACKQuickConn::has_downloadurl() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ACKQuickConn::set_has_downloadurl() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ACKQuickConn::clear_has_downloadurl() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ACKQuickConn::clear_downloadurl() {
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    downloadurl_->clear();
  }
  clear_has_downloadurl();
}
inline const ::std::string& ACKQuickConn::downloadurl() const {
  return *downloadurl_;
}
inline void ACKQuickConn::set_downloadurl(const ::std::string& value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void ACKQuickConn::set_downloadurl(const char* value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void ACKQuickConn::set_downloadurl(const char* value, size_t size) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKQuickConn::mutable_downloadurl() {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  return downloadurl_;
}
inline ::std::string* ACKQuickConn::release_downloadurl() {
  clear_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = downloadurl_;
    downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string IfPreserve = 13;
inline bool ACKQuickConn::has_ifpreserve() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ACKQuickConn::set_has_ifpreserve() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ACKQuickConn::clear_has_ifpreserve() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ACKQuickConn::clear_ifpreserve() {
  if (ifpreserve_ != &::google::protobuf::internal::kEmptyString) {
    ifpreserve_->clear();
  }
  clear_has_ifpreserve();
}
inline const ::std::string& ACKQuickConn::ifpreserve() const {
  return *ifpreserve_;
}
inline void ACKQuickConn::set_ifpreserve(const ::std::string& value) {
  set_has_ifpreserve();
  if (ifpreserve_ == &::google::protobuf::internal::kEmptyString) {
    ifpreserve_ = new ::std::string;
  }
  ifpreserve_->assign(value);
}
inline void ACKQuickConn::set_ifpreserve(const char* value) {
  set_has_ifpreserve();
  if (ifpreserve_ == &::google::protobuf::internal::kEmptyString) {
    ifpreserve_ = new ::std::string;
  }
  ifpreserve_->assign(value);
}
inline void ACKQuickConn::set_ifpreserve(const char* value, size_t size) {
  set_has_ifpreserve();
  if (ifpreserve_ == &::google::protobuf::internal::kEmptyString) {
    ifpreserve_ = new ::std::string;
  }
  ifpreserve_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKQuickConn::mutable_ifpreserve() {
  set_has_ifpreserve();
  if (ifpreserve_ == &::google::protobuf::internal::kEmptyString) {
    ifpreserve_ = new ::std::string;
  }
  return ifpreserve_;
}
inline ::std::string* ACKQuickConn::release_ifpreserve() {
  clear_has_ifpreserve();
  if (ifpreserve_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ifpreserve_;
    ifpreserve_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PreserveMsg = 14;
inline bool ACKQuickConn::has_preservemsg() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ACKQuickConn::set_has_preservemsg() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ACKQuickConn::clear_has_preservemsg() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ACKQuickConn::clear_preservemsg() {
  if (preservemsg_ != &::google::protobuf::internal::kEmptyString) {
    preservemsg_->clear();
  }
  clear_has_preservemsg();
}
inline const ::std::string& ACKQuickConn::preservemsg() const {
  return *preservemsg_;
}
inline void ACKQuickConn::set_preservemsg(const ::std::string& value) {
  set_has_preservemsg();
  if (preservemsg_ == &::google::protobuf::internal::kEmptyString) {
    preservemsg_ = new ::std::string;
  }
  preservemsg_->assign(value);
}
inline void ACKQuickConn::set_preservemsg(const char* value) {
  set_has_preservemsg();
  if (preservemsg_ == &::google::protobuf::internal::kEmptyString) {
    preservemsg_ = new ::std::string;
  }
  preservemsg_->assign(value);
}
inline void ACKQuickConn::set_preservemsg(const char* value, size_t size) {
  set_has_preservemsg();
  if (preservemsg_ == &::google::protobuf::internal::kEmptyString) {
    preservemsg_ = new ::std::string;
  }
  preservemsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKQuickConn::mutable_preservemsg() {
  set_has_preservemsg();
  if (preservemsg_ == &::google::protobuf::internal::kEmptyString) {
    preservemsg_ = new ::std::string;
  }
  return preservemsg_;
}
inline ::std::string* ACKQuickConn::release_preservemsg() {
  clear_has_preservemsg();
  if (preservemsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = preservemsg_;
    preservemsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 DownloadReasion = 15;
inline bool ACKQuickConn::has_downloadreasion() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ACKQuickConn::set_has_downloadreasion() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ACKQuickConn::clear_has_downloadreasion() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ACKQuickConn::clear_downloadreasion() {
  downloadreasion_ = 0;
  clear_has_downloadreasion();
}
inline ::google::protobuf::int32 ACKQuickConn::downloadreasion() const {
  return downloadreasion_;
}
inline void ACKQuickConn::set_downloadreasion(::google::protobuf::int32 value) {
  set_has_downloadreasion();
  downloadreasion_ = value;
}

// optional int32 GameId = 16;
inline bool ACKQuickConn::has_gameid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ACKQuickConn::set_has_gameid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ACKQuickConn::clear_has_gameid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ACKQuickConn::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ACKQuickConn::gameid() const {
  return gameid_;
}
inline void ACKQuickConn::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// repeated .ThranJSSInfo JssList = 17;
inline int ACKQuickConn::jsslist_size() const {
  return jsslist_.size();
}
inline void ACKQuickConn::clear_jsslist() {
  jsslist_.Clear();
}
inline const ::ThranJSSInfo& ACKQuickConn::jsslist(int index) const {
  return jsslist_.Get(index);
}
inline ::ThranJSSInfo* ACKQuickConn::mutable_jsslist(int index) {
  return jsslist_.Mutable(index);
}
inline ::ThranJSSInfo* ACKQuickConn::add_jsslist() {
  return jsslist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ThranJSSInfo >&
ACKQuickConn::jsslist() const {
  return jsslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ThranJSSInfo >*
ACKQuickConn::mutable_jsslist() {
  return &jsslist_;
}

// optional string IfSearch = 18;
inline bool ACKQuickConn::has_ifsearch() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ACKQuickConn::set_has_ifsearch() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ACKQuickConn::clear_has_ifsearch() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ACKQuickConn::clear_ifsearch() {
  if (ifsearch_ != &::google::protobuf::internal::kEmptyString) {
    ifsearch_->clear();
  }
  clear_has_ifsearch();
}
inline const ::std::string& ACKQuickConn::ifsearch() const {
  return *ifsearch_;
}
inline void ACKQuickConn::set_ifsearch(const ::std::string& value) {
  set_has_ifsearch();
  if (ifsearch_ == &::google::protobuf::internal::kEmptyString) {
    ifsearch_ = new ::std::string;
  }
  ifsearch_->assign(value);
}
inline void ACKQuickConn::set_ifsearch(const char* value) {
  set_has_ifsearch();
  if (ifsearch_ == &::google::protobuf::internal::kEmptyString) {
    ifsearch_ = new ::std::string;
  }
  ifsearch_->assign(value);
}
inline void ACKQuickConn::set_ifsearch(const char* value, size_t size) {
  set_has_ifsearch();
  if (ifsearch_ == &::google::protobuf::internal::kEmptyString) {
    ifsearch_ = new ::std::string;
  }
  ifsearch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKQuickConn::mutable_ifsearch() {
  set_has_ifsearch();
  if (ifsearch_ == &::google::protobuf::internal::kEmptyString) {
    ifsearch_ = new ::std::string;
  }
  return ifsearch_;
}
inline ::std::string* ACKQuickConn::release_ifsearch() {
  clear_has_ifsearch();
  if (ifsearch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ifsearch_;
    ifsearch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .OGBulletinInfo BulletinList = 19;
inline int ACKQuickConn::bulletinlist_size() const {
  return bulletinlist_.size();
}
inline void ACKQuickConn::clear_bulletinlist() {
  bulletinlist_.Clear();
}
inline const ::OGBulletinInfo& ACKQuickConn::bulletinlist(int index) const {
  return bulletinlist_.Get(index);
}
inline ::OGBulletinInfo* ACKQuickConn::mutable_bulletinlist(int index) {
  return bulletinlist_.Mutable(index);
}
inline ::OGBulletinInfo* ACKQuickConn::add_bulletinlist() {
  return bulletinlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OGBulletinInfo >&
ACKQuickConn::bulletinlist() const {
  return bulletinlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OGBulletinInfo >*
ACKQuickConn::mutable_bulletinlist() {
  return &bulletinlist_;
}

// optional string VersionInfo = 20;
inline bool ACKQuickConn::has_versioninfo() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ACKQuickConn::set_has_versioninfo() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ACKQuickConn::clear_has_versioninfo() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ACKQuickConn::clear_versioninfo() {
  if (versioninfo_ != &::google::protobuf::internal::kEmptyString) {
    versioninfo_->clear();
  }
  clear_has_versioninfo();
}
inline const ::std::string& ACKQuickConn::versioninfo() const {
  return *versioninfo_;
}
inline void ACKQuickConn::set_versioninfo(const ::std::string& value) {
  set_has_versioninfo();
  if (versioninfo_ == &::google::protobuf::internal::kEmptyString) {
    versioninfo_ = new ::std::string;
  }
  versioninfo_->assign(value);
}
inline void ACKQuickConn::set_versioninfo(const char* value) {
  set_has_versioninfo();
  if (versioninfo_ == &::google::protobuf::internal::kEmptyString) {
    versioninfo_ = new ::std::string;
  }
  versioninfo_->assign(value);
}
inline void ACKQuickConn::set_versioninfo(const char* value, size_t size) {
  set_has_versioninfo();
  if (versioninfo_ == &::google::protobuf::internal::kEmptyString) {
    versioninfo_ = new ::std::string;
  }
  versioninfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKQuickConn::mutable_versioninfo() {
  set_has_versioninfo();
  if (versioninfo_ == &::google::protobuf::internal::kEmptyString) {
    versioninfo_ = new ::std::string;
  }
  return versioninfo_;
}
inline ::std::string* ACKQuickConn::release_versioninfo() {
  clear_has_versioninfo();
  if (versioninfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = versioninfo_;
    versioninfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .OGRoomInfo MatchSvrList = 21;
inline int ACKQuickConn::matchsvrlist_size() const {
  return matchsvrlist_.size();
}
inline void ACKQuickConn::clear_matchsvrlist() {
  matchsvrlist_.Clear();
}
inline const ::OGRoomInfo& ACKQuickConn::matchsvrlist(int index) const {
  return matchsvrlist_.Get(index);
}
inline ::OGRoomInfo* ACKQuickConn::mutable_matchsvrlist(int index) {
  return matchsvrlist_.Mutable(index);
}
inline ::OGRoomInfo* ACKQuickConn::add_matchsvrlist() {
  return matchsvrlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
ACKQuickConn::matchsvrlist() const {
  return matchsvrlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
ACKQuickConn::mutable_matchsvrlist() {
  return &matchsvrlist_;
}

// optional int32 Sex = 22;
inline bool ACKQuickConn::has_sex() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ACKQuickConn::set_has_sex() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ACKQuickConn::clear_has_sex() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ACKQuickConn::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 ACKQuickConn::sex() const {
  return sex_;
}
inline void ACKQuickConn::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// repeated .OGRoomInfo RoomSvrList = 23;
inline int ACKQuickConn::roomsvrlist_size() const {
  return roomsvrlist_.size();
}
inline void ACKQuickConn::clear_roomsvrlist() {
  roomsvrlist_.Clear();
}
inline const ::OGRoomInfo& ACKQuickConn::roomsvrlist(int index) const {
  return roomsvrlist_.Get(index);
}
inline ::OGRoomInfo* ACKQuickConn::mutable_roomsvrlist(int index) {
  return roomsvrlist_.Mutable(index);
}
inline ::OGRoomInfo* ACKQuickConn::add_roomsvrlist() {
  return roomsvrlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >&
ACKQuickConn::roomsvrlist() const {
  return roomsvrlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OGRoomInfo >*
ACKQuickConn::mutable_roomsvrlist() {
  return &roomsvrlist_;
}

// optional int32 DdzActive = 24 [default = 0];
inline bool ACKQuickConn::has_ddzactive() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ACKQuickConn::set_has_ddzactive() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ACKQuickConn::clear_has_ddzactive() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ACKQuickConn::clear_ddzactive() {
  ddzactive_ = 0;
  clear_has_ddzactive();
}
inline ::google::protobuf::int32 ACKQuickConn::ddzactive() const {
  return ddzactive_;
}
inline void ACKQuickConn::set_ddzactive(::google::protobuf::int32 value) {
  set_has_ddzactive();
  ddzactive_ = value;
}

// optional string MsgUrl = 25;
inline bool ACKQuickConn::has_msgurl() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ACKQuickConn::set_has_msgurl() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ACKQuickConn::clear_has_msgurl() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ACKQuickConn::clear_msgurl() {
  if (msgurl_ != &::google::protobuf::internal::kEmptyString) {
    msgurl_->clear();
  }
  clear_has_msgurl();
}
inline const ::std::string& ACKQuickConn::msgurl() const {
  return *msgurl_;
}
inline void ACKQuickConn::set_msgurl(const ::std::string& value) {
  set_has_msgurl();
  if (msgurl_ == &::google::protobuf::internal::kEmptyString) {
    msgurl_ = new ::std::string;
  }
  msgurl_->assign(value);
}
inline void ACKQuickConn::set_msgurl(const char* value) {
  set_has_msgurl();
  if (msgurl_ == &::google::protobuf::internal::kEmptyString) {
    msgurl_ = new ::std::string;
  }
  msgurl_->assign(value);
}
inline void ACKQuickConn::set_msgurl(const char* value, size_t size) {
  set_has_msgurl();
  if (msgurl_ == &::google::protobuf::internal::kEmptyString) {
    msgurl_ = new ::std::string;
  }
  msgurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKQuickConn::mutable_msgurl() {
  set_has_msgurl();
  if (msgurl_ == &::google::protobuf::internal::kEmptyString) {
    msgurl_ = new ::std::string;
  }
  return msgurl_;
}
inline ::std::string* ACKQuickConn::release_msgurl() {
  clear_has_msgurl();
  if (msgurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgurl_;
    msgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 ErrorCode = 26 [default = 0];
inline bool ACKQuickConn::has_errorcode() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ACKQuickConn::set_has_errorcode() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ACKQuickConn::clear_has_errorcode() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ACKQuickConn::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 ACKQuickConn::errorcode() const {
  return errorcode_;
}
inline void ACKQuickConn::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ThranConn_2eproto__INCLUDED

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mobileGame.proto

#ifndef PROTOBUF_mobileGame_2eproto__INCLUDED
#define PROTOBUF_mobileGame_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mobileGame_2eproto();
void protobuf_AssignDesc_mobileGame_2eproto();
void protobuf_ShutdownFile_mobileGame_2eproto();

class ReqGameRegister;
class AckGameRegister;
class ReqGameLogin;
class AckGameLogin;
class OgRoomInfo;
class JssInfo;
class OgBulletinInfo;

// ===================================================================

class ReqGameRegister : public ::google::protobuf::Message {
 public:
  ReqGameRegister();
  virtual ~ReqGameRegister();
  
  ReqGameRegister(const ReqGameRegister& from);
  
  inline ReqGameRegister& operator=(const ReqGameRegister& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqGameRegister& default_instance();
  
  void Swap(ReqGameRegister* other);
  
  // implements Message ----------------------------------------------
  
  ReqGameRegister* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqGameRegister& from);
  void MergeFrom(const ReqGameRegister& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string userName = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // required int32 terminal = 3;
  inline bool has_terminal() const;
  inline void clear_terminal();
  static const int kTerminalFieldNumber = 3;
  inline ::google::protobuf::int32 terminal() const;
  inline void set_terminal(::google::protobuf::int32 value);
  
  // required string deviceNumber = 4;
  inline bool has_devicenumber() const;
  inline void clear_devicenumber();
  static const int kDeviceNumberFieldNumber = 4;
  inline const ::std::string& devicenumber() const;
  inline void set_devicenumber(const ::std::string& value);
  inline void set_devicenumber(const char* value);
  inline void set_devicenumber(const char* value, size_t size);
  inline ::std::string* mutable_devicenumber();
  inline ::std::string* release_devicenumber();
  
  // required int32 gameId = 5;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 5;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required string comeFrom = 6;
  inline bool has_comefrom() const;
  inline void clear_comefrom();
  static const int kComeFromFieldNumber = 6;
  inline const ::std::string& comefrom() const;
  inline void set_comefrom(const ::std::string& value);
  inline void set_comefrom(const char* value);
  inline void set_comefrom(const char* value, size_t size);
  inline ::std::string* mutable_comefrom();
  inline ::std::string* release_comefrom();
  
  // required string token = 7;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 7;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // optional string userNameApple = 8;
  inline bool has_usernameapple() const;
  inline void clear_usernameapple();
  static const int kUserNameAppleFieldNumber = 8;
  inline const ::std::string& usernameapple() const;
  inline void set_usernameapple(const ::std::string& value);
  inline void set_usernameapple(const char* value);
  inline void set_usernameapple(const char* value, size_t size);
  inline ::std::string* mutable_usernameapple();
  inline ::std::string* release_usernameapple();
  
  // @@protoc_insertion_point(class_scope:ReqGameRegister)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_terminal();
  inline void clear_has_terminal();
  inline void set_has_devicenumber();
  inline void clear_has_devicenumber();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_comefrom();
  inline void clear_has_comefrom();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_usernameapple();
  inline void clear_has_usernameapple();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  ::std::string* password_;
  ::std::string* devicenumber_;
  ::google::protobuf::int32 terminal_;
  ::google::protobuf::int32 gameid_;
  ::std::string* comefrom_;
  ::std::string* token_;
  ::std::string* usernameapple_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_mobileGame_2eproto();
  friend void protobuf_AssignDesc_mobileGame_2eproto();
  friend void protobuf_ShutdownFile_mobileGame_2eproto();
  
  void InitAsDefaultInstance();
  static ReqGameRegister* default_instance_;
};
// -------------------------------------------------------------------

class AckGameRegister : public ::google::protobuf::Message {
 public:
  AckGameRegister();
  virtual ~AckGameRegister();
  
  AckGameRegister(const AckGameRegister& from);
  
  inline AckGameRegister& operator=(const AckGameRegister& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckGameRegister& default_instance();
  
  void Swap(AckGameRegister* other);
  
  // implements Message ----------------------------------------------
  
  AckGameRegister* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckGameRegister& from);
  void MergeFrom(const AckGameRegister& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // optional string errorMsg = 2;
  inline bool has_errormsg() const;
  inline void clear_errormsg();
  static const int kErrorMsgFieldNumber = 2;
  inline const ::std::string& errormsg() const;
  inline void set_errormsg(const ::std::string& value);
  inline void set_errormsg(const char* value);
  inline void set_errormsg(const char* value, size_t size);
  inline ::std::string* mutable_errormsg();
  inline ::std::string* release_errormsg();
  
  // @@protoc_insertion_point(class_scope:AckGameRegister)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_errormsg();
  inline void clear_has_errormsg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* errormsg_;
  ::google::protobuf::int32 result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_mobileGame_2eproto();
  friend void protobuf_AssignDesc_mobileGame_2eproto();
  friend void protobuf_ShutdownFile_mobileGame_2eproto();
  
  void InitAsDefaultInstance();
  static AckGameRegister* default_instance_;
};
// -------------------------------------------------------------------

class ReqGameLogin : public ::google::protobuf::Message {
 public:
  ReqGameLogin();
  virtual ~ReqGameLogin();
  
  ReqGameLogin(const ReqGameLogin& from);
  
  inline ReqGameLogin& operator=(const ReqGameLogin& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqGameLogin& default_instance();
  
  void Swap(ReqGameLogin* other);
  
  // implements Message ----------------------------------------------
  
  ReqGameLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqGameLogin& from);
  void MergeFrom(const ReqGameLogin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string userName = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // required int32 terminal = 3;
  inline bool has_terminal() const;
  inline void clear_terminal();
  static const int kTerminalFieldNumber = 3;
  inline ::google::protobuf::int32 terminal() const;
  inline void set_terminal(::google::protobuf::int32 value);
  
  // required string deviceNumber = 4;
  inline bool has_devicenumber() const;
  inline void clear_devicenumber();
  static const int kDeviceNumberFieldNumber = 4;
  inline const ::std::string& devicenumber() const;
  inline void set_devicenumber(const ::std::string& value);
  inline void set_devicenumber(const char* value);
  inline void set_devicenumber(const char* value, size_t size);
  inline ::std::string* mutable_devicenumber();
  inline ::std::string* release_devicenumber();
  
  // required int32 gameId = 5;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 5;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required string comeFrom = 6;
  inline bool has_comefrom() const;
  inline void clear_comefrom();
  static const int kComeFromFieldNumber = 6;
  inline const ::std::string& comefrom() const;
  inline void set_comefrom(const ::std::string& value);
  inline void set_comefrom(const char* value);
  inline void set_comefrom(const char* value, size_t size);
  inline ::std::string* mutable_comefrom();
  inline ::std::string* release_comefrom();
  
  // required string token = 7;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 7;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // @@protoc_insertion_point(class_scope:ReqGameLogin)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_terminal();
  inline void clear_has_terminal();
  inline void set_has_devicenumber();
  inline void clear_has_devicenumber();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_comefrom();
  inline void clear_has_comefrom();
  inline void set_has_token();
  inline void clear_has_token();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  ::std::string* password_;
  ::std::string* devicenumber_;
  ::google::protobuf::int32 terminal_;
  ::google::protobuf::int32 gameid_;
  ::std::string* comefrom_;
  ::std::string* token_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_mobileGame_2eproto();
  friend void protobuf_AssignDesc_mobileGame_2eproto();
  friend void protobuf_ShutdownFile_mobileGame_2eproto();
  
  void InitAsDefaultInstance();
  static ReqGameLogin* default_instance_;
};
// -------------------------------------------------------------------

class AckGameLogin : public ::google::protobuf::Message {
 public:
  AckGameLogin();
  virtual ~AckGameLogin();
  
  AckGameLogin(const AckGameLogin& from);
  
  inline AckGameLogin& operator=(const AckGameLogin& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckGameLogin& default_instance();
  
  void Swap(AckGameLogin* other);
  
  // implements Message ----------------------------------------------
  
  AckGameLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckGameLogin& from);
  void MergeFrom(const AckGameLogin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // optional string userName = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional string roleName = 3;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRoleNameFieldNumber = 3;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  
  // optional int32 coin = 4;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 4;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);
  
  // optional int32 gameCoin = 5;
  inline bool has_gamecoin() const;
  inline void clear_gamecoin();
  static const int kGameCoinFieldNumber = 5;
  inline ::google::protobuf::int32 gamecoin() const;
  inline void set_gamecoin(::google::protobuf::int32 value);
  
  // optional bytes certHaveRole = 6;
  inline bool has_certhaverole() const;
  inline void clear_certhaverole();
  static const int kCertHaveRoleFieldNumber = 6;
  inline const ::std::string& certhaverole() const;
  inline void set_certhaverole(const ::std::string& value);
  inline void set_certhaverole(const char* value);
  inline void set_certhaverole(const void* value, size_t size);
  inline ::std::string* mutable_certhaverole();
  inline ::std::string* release_certhaverole();
  
  // optional bytes certNoRole = 7;
  inline bool has_certnorole() const;
  inline void clear_certnorole();
  static const int kCertNoRoleFieldNumber = 7;
  inline const ::std::string& certnorole() const;
  inline void set_certnorole(const ::std::string& value);
  inline void set_certnorole(const char* value);
  inline void set_certnorole(const void* value, size_t size);
  inline ::std::string* mutable_certnorole();
  inline ::std::string* release_certnorole();
  
  // optional int32 curVersion = 8;
  inline bool has_curversion() const;
  inline void clear_curversion();
  static const int kCurVersionFieldNumber = 8;
  inline ::google::protobuf::int32 curversion() const;
  inline void set_curversion(::google::protobuf::int32 value);
  
  // optional string playEnable = 9;
  inline bool has_playenable() const;
  inline void clear_playenable();
  static const int kPlayEnableFieldNumber = 9;
  inline const ::std::string& playenable() const;
  inline void set_playenable(const ::std::string& value);
  inline void set_playenable(const char* value);
  inline void set_playenable(const char* value, size_t size);
  inline ::std::string* mutable_playenable();
  inline ::std::string* release_playenable();
  
  // optional string downloadUrl = 10;
  inline bool has_downloadurl() const;
  inline void clear_downloadurl();
  static const int kDownloadUrlFieldNumber = 10;
  inline const ::std::string& downloadurl() const;
  inline void set_downloadurl(const ::std::string& value);
  inline void set_downloadurl(const char* value);
  inline void set_downloadurl(const char* value, size_t size);
  inline ::std::string* mutable_downloadurl();
  inline ::std::string* release_downloadurl();
  
  // optional string ifStopService = 11;
  inline bool has_ifstopservice() const;
  inline void clear_ifstopservice();
  static const int kIfStopServiceFieldNumber = 11;
  inline const ::std::string& ifstopservice() const;
  inline void set_ifstopservice(const ::std::string& value);
  inline void set_ifstopservice(const char* value);
  inline void set_ifstopservice(const char* value, size_t size);
  inline ::std::string* mutable_ifstopservice();
  inline ::std::string* release_ifstopservice();
  
  // optional string stopServiceMsg = 12;
  inline bool has_stopservicemsg() const;
  inline void clear_stopservicemsg();
  static const int kStopServiceMsgFieldNumber = 12;
  inline const ::std::string& stopservicemsg() const;
  inline void set_stopservicemsg(const ::std::string& value);
  inline void set_stopservicemsg(const char* value);
  inline void set_stopservicemsg(const char* value, size_t size);
  inline ::std::string* mutable_stopservicemsg();
  inline ::std::string* release_stopservicemsg();
  
  // optional int32 downloadReason = 13;
  inline bool has_downloadreason() const;
  inline void clear_downloadreason();
  static const int kDownloadReasonFieldNumber = 13;
  inline ::google::protobuf::int32 downloadreason() const;
  inline void set_downloadreason(::google::protobuf::int32 value);
  
  // optional int32 gameId = 14;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 14;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // repeated .OgRoomInfo matchSvrList = 15;
  inline int matchsvrlist_size() const;
  inline void clear_matchsvrlist();
  static const int kMatchSvrListFieldNumber = 15;
  inline const ::OgRoomInfo& matchsvrlist(int index) const;
  inline ::OgRoomInfo* mutable_matchsvrlist(int index);
  inline ::OgRoomInfo* add_matchsvrlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OgRoomInfo >&
      matchsvrlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OgRoomInfo >*
      mutable_matchsvrlist();
  
  // repeated .JssInfo payJssList = 16;
  inline int payjsslist_size() const;
  inline void clear_payjsslist();
  static const int kPayJssListFieldNumber = 16;
  inline const ::JssInfo& payjsslist(int index) const;
  inline ::JssInfo* mutable_payjsslist(int index);
  inline ::JssInfo* add_payjsslist();
  inline const ::google::protobuf::RepeatedPtrField< ::JssInfo >&
      payjsslist() const;
  inline ::google::protobuf::RepeatedPtrField< ::JssInfo >*
      mutable_payjsslist();
  
  // repeated .JssInfo gameJssList = 17;
  inline int gamejsslist_size() const;
  inline void clear_gamejsslist();
  static const int kGameJssListFieldNumber = 17;
  inline const ::JssInfo& gamejsslist(int index) const;
  inline ::JssInfo* mutable_gamejsslist(int index);
  inline ::JssInfo* add_gamejsslist();
  inline const ::google::protobuf::RepeatedPtrField< ::JssInfo >&
      gamejsslist() const;
  inline ::google::protobuf::RepeatedPtrField< ::JssInfo >*
      mutable_gamejsslist();
  
  // optional int32 sex = 18;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 18;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);
  
  // optional string ifDisplaySearch = 19;
  inline bool has_ifdisplaysearch() const;
  inline void clear_ifdisplaysearch();
  static const int kIfDisplaySearchFieldNumber = 19;
  inline const ::std::string& ifdisplaysearch() const;
  inline void set_ifdisplaysearch(const ::std::string& value);
  inline void set_ifdisplaysearch(const char* value);
  inline void set_ifdisplaysearch(const char* value, size_t size);
  inline ::std::string* mutable_ifdisplaysearch();
  inline ::std::string* release_ifdisplaysearch();
  
  // repeated .OgBulletinInfo bulletinList = 20;
  inline int bulletinlist_size() const;
  inline void clear_bulletinlist();
  static const int kBulletinListFieldNumber = 20;
  inline const ::OgBulletinInfo& bulletinlist(int index) const;
  inline ::OgBulletinInfo* mutable_bulletinlist(int index);
  inline ::OgBulletinInfo* add_bulletinlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OgBulletinInfo >&
      bulletinlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OgBulletinInfo >*
      mutable_bulletinlist();
  
  // optional string versionInfo = 21;
  inline bool has_versioninfo() const;
  inline void clear_versioninfo();
  static const int kVersionInfoFieldNumber = 21;
  inline const ::std::string& versioninfo() const;
  inline void set_versioninfo(const ::std::string& value);
  inline void set_versioninfo(const char* value);
  inline void set_versioninfo(const char* value, size_t size);
  inline ::std::string* mutable_versioninfo();
  inline ::std::string* release_versioninfo();
  
  // optional string userMsgUrl = 22;
  inline bool has_usermsgurl() const;
  inline void clear_usermsgurl();
  static const int kUserMsgUrlFieldNumber = 22;
  inline const ::std::string& usermsgurl() const;
  inline void set_usermsgurl(const ::std::string& value);
  inline void set_usermsgurl(const char* value);
  inline void set_usermsgurl(const char* value, size_t size);
  inline ::std::string* mutable_usermsgurl();
  inline ::std::string* release_usermsgurl();
  
  // @@protoc_insertion_point(class_scope:AckGameLogin)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_gamecoin();
  inline void clear_has_gamecoin();
  inline void set_has_certhaverole();
  inline void clear_has_certhaverole();
  inline void set_has_certnorole();
  inline void clear_has_certnorole();
  inline void set_has_curversion();
  inline void clear_has_curversion();
  inline void set_has_playenable();
  inline void clear_has_playenable();
  inline void set_has_downloadurl();
  inline void clear_has_downloadurl();
  inline void set_has_ifstopservice();
  inline void clear_has_ifstopservice();
  inline void set_has_stopservicemsg();
  inline void clear_has_stopservicemsg();
  inline void set_has_downloadreason();
  inline void clear_has_downloadreason();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_ifdisplaysearch();
  inline void clear_has_ifdisplaysearch();
  inline void set_has_versioninfo();
  inline void clear_has_versioninfo();
  inline void set_has_usermsgurl();
  inline void clear_has_usermsgurl();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 coin_;
  ::std::string* rolename_;
  ::std::string* certhaverole_;
  ::google::protobuf::int32 gamecoin_;
  ::google::protobuf::int32 curversion_;
  ::std::string* certnorole_;
  ::std::string* playenable_;
  ::std::string* downloadurl_;
  ::std::string* ifstopservice_;
  ::std::string* stopservicemsg_;
  ::google::protobuf::int32 downloadreason_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::RepeatedPtrField< ::OgRoomInfo > matchsvrlist_;
  ::google::protobuf::RepeatedPtrField< ::JssInfo > payjsslist_;
  ::google::protobuf::RepeatedPtrField< ::JssInfo > gamejsslist_;
  ::std::string* ifdisplaysearch_;
  ::google::protobuf::RepeatedPtrField< ::OgBulletinInfo > bulletinlist_;
  ::std::string* versioninfo_;
  ::std::string* usermsgurl_;
  ::google::protobuf::int32 sex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];
  
  friend void  protobuf_AddDesc_mobileGame_2eproto();
  friend void protobuf_AssignDesc_mobileGame_2eproto();
  friend void protobuf_ShutdownFile_mobileGame_2eproto();
  
  void InitAsDefaultInstance();
  static AckGameLogin* default_instance_;
};
// -------------------------------------------------------------------

class OgRoomInfo : public ::google::protobuf::Message {
 public:
  OgRoomInfo();
  virtual ~OgRoomInfo();
  
  OgRoomInfo(const OgRoomInfo& from);
  
  inline OgRoomInfo& operator=(const OgRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OgRoomInfo& default_instance();
  
  void Swap(OgRoomInfo* other);
  
  // implements Message ----------------------------------------------
  
  OgRoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OgRoomInfo& from);
  void MergeFrom(const OgRoomInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string RoomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  
  // required string RoomRank = 2;
  inline bool has_roomrank() const;
  inline void clear_roomrank();
  static const int kRoomRankFieldNumber = 2;
  inline const ::std::string& roomrank() const;
  inline void set_roomrank(const ::std::string& value);
  inline void set_roomrank(const char* value);
  inline void set_roomrank(const char* value, size_t size);
  inline ::std::string* mutable_roomrank();
  inline ::std::string* release_roomrank();
  
  // required string RoomIp = 3;
  inline bool has_roomip() const;
  inline void clear_roomip();
  static const int kRoomIpFieldNumber = 3;
  inline const ::std::string& roomip() const;
  inline void set_roomip(const ::std::string& value);
  inline void set_roomip(const char* value);
  inline void set_roomip(const char* value, size_t size);
  inline ::std::string* mutable_roomip();
  inline ::std::string* release_roomip();
  
  // required string RoomPort = 4;
  inline bool has_roomport() const;
  inline void clear_roomport();
  static const int kRoomPortFieldNumber = 4;
  inline const ::std::string& roomport() const;
  inline void set_roomport(const ::std::string& value);
  inline void set_roomport(const char* value);
  inline void set_roomport(const char* value, size_t size);
  inline ::std::string* mutable_roomport();
  inline ::std::string* release_roomport();
  
  // required string RoomStatus = 5;
  inline bool has_roomstatus() const;
  inline void clear_roomstatus();
  static const int kRoomStatusFieldNumber = 5;
  inline const ::std::string& roomstatus() const;
  inline void set_roomstatus(const ::std::string& value);
  inline void set_roomstatus(const char* value);
  inline void set_roomstatus(const char* value, size_t size);
  inline ::std::string* mutable_roomstatus();
  inline ::std::string* release_roomstatus();
  
  // required string RoomMinGold = 6;
  inline bool has_roommingold() const;
  inline void clear_roommingold();
  static const int kRoomMinGoldFieldNumber = 6;
  inline const ::std::string& roommingold() const;
  inline void set_roommingold(const ::std::string& value);
  inline void set_roommingold(const char* value);
  inline void set_roommingold(const char* value, size_t size);
  inline ::std::string* mutable_roommingold();
  inline ::std::string* release_roommingold();
  
  // required string RoomMaxGold = 7;
  inline bool has_roommaxgold() const;
  inline void clear_roommaxgold();
  static const int kRoomMaxGoldFieldNumber = 7;
  inline const ::std::string& roommaxgold() const;
  inline void set_roommaxgold(const ::std::string& value);
  inline void set_roommaxgold(const char* value);
  inline void set_roommaxgold(const char* value, size_t size);
  inline ::std::string* mutable_roommaxgold();
  inline ::std::string* release_roommaxgold();
  
  // required string RoomMinPlay = 8;
  inline bool has_roomminplay() const;
  inline void clear_roomminplay();
  static const int kRoomMinPlayFieldNumber = 8;
  inline const ::std::string& roomminplay() const;
  inline void set_roomminplay(const ::std::string& value);
  inline void set_roomminplay(const char* value);
  inline void set_roomminplay(const char* value, size_t size);
  inline ::std::string* mutable_roomminplay();
  inline ::std::string* release_roomminplay();
  
  // optional string RoomType = 9;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 9;
  inline const ::std::string& roomtype() const;
  inline void set_roomtype(const ::std::string& value);
  inline void set_roomtype(const char* value);
  inline void set_roomtype(const char* value, size_t size);
  inline ::std::string* mutable_roomtype();
  inline ::std::string* release_roomtype();
  
  // optional string ServerType = 10;
  inline bool has_servertype() const;
  inline void clear_servertype();
  static const int kServerTypeFieldNumber = 10;
  inline const ::std::string& servertype() const;
  inline void set_servertype(const ::std::string& value);
  inline void set_servertype(const char* value);
  inline void set_servertype(const char* value, size_t size);
  inline ::std::string* mutable_servertype();
  inline ::std::string* release_servertype();
  
  // optional string Description = 11;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 11;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // optional string RoomName = 12;
  inline bool has_roomname() const;
  inline void clear_roomname();
  static const int kRoomNameFieldNumber = 12;
  inline const ::std::string& roomname() const;
  inline void set_roomname(const ::std::string& value);
  inline void set_roomname(const char* value);
  inline void set_roomname(const char* value, size_t size);
  inline ::std::string* mutable_roomname();
  inline ::std::string* release_roomname();
  
  // @@protoc_insertion_point(class_scope:OgRoomInfo)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_roomrank();
  inline void clear_has_roomrank();
  inline void set_has_roomip();
  inline void clear_has_roomip();
  inline void set_has_roomport();
  inline void clear_has_roomport();
  inline void set_has_roomstatus();
  inline void clear_has_roomstatus();
  inline void set_has_roommingold();
  inline void clear_has_roommingold();
  inline void set_has_roommaxgold();
  inline void clear_has_roommaxgold();
  inline void set_has_roomminplay();
  inline void clear_has_roomminplay();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_servertype();
  inline void clear_has_servertype();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_roomname();
  inline void clear_has_roomname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roomid_;
  ::std::string* roomrank_;
  ::std::string* roomip_;
  ::std::string* roomport_;
  ::std::string* roomstatus_;
  ::std::string* roommingold_;
  ::std::string* roommaxgold_;
  ::std::string* roomminplay_;
  ::std::string* roomtype_;
  ::std::string* servertype_;
  ::std::string* description_;
  ::std::string* roomname_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_mobileGame_2eproto();
  friend void protobuf_AssignDesc_mobileGame_2eproto();
  friend void protobuf_ShutdownFile_mobileGame_2eproto();
  
  void InitAsDefaultInstance();
  static OgRoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class JssInfo : public ::google::protobuf::Message {
 public:
  JssInfo();
  virtual ~JssInfo();
  
  JssInfo(const JssInfo& from);
  
  inline JssInfo& operator=(const JssInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const JssInfo& default_instance();
  
  void Swap(JssInfo* other);
  
  // implements Message ----------------------------------------------
  
  JssInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JssInfo& from);
  void MergeFrom(const JssInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string roomIP = 1;
  inline bool has_roomip() const;
  inline void clear_roomip();
  static const int kRoomIPFieldNumber = 1;
  inline const ::std::string& roomip() const;
  inline void set_roomip(const ::std::string& value);
  inline void set_roomip(const char* value);
  inline void set_roomip(const char* value, size_t size);
  inline ::std::string* mutable_roomip();
  inline ::std::string* release_roomip();
  
  // optional string roomPort = 2;
  inline bool has_roomport() const;
  inline void clear_roomport();
  static const int kRoomPortFieldNumber = 2;
  inline const ::std::string& roomport() const;
  inline void set_roomport(const ::std::string& value);
  inline void set_roomport(const char* value);
  inline void set_roomport(const char* value, size_t size);
  inline ::std::string* mutable_roomport();
  inline ::std::string* release_roomport();
  
  // optional string remark = 3;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 3;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  
  // @@protoc_insertion_point(class_scope:JssInfo)
 private:
  inline void set_has_roomip();
  inline void clear_has_roomip();
  inline void set_has_roomport();
  inline void clear_has_roomport();
  inline void set_has_remark();
  inline void clear_has_remark();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roomip_;
  ::std::string* roomport_;
  ::std::string* remark_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_mobileGame_2eproto();
  friend void protobuf_AssignDesc_mobileGame_2eproto();
  friend void protobuf_ShutdownFile_mobileGame_2eproto();
  
  void InitAsDefaultInstance();
  static JssInfo* default_instance_;
};
// -------------------------------------------------------------------

class OgBulletinInfo : public ::google::protobuf::Message {
 public:
  OgBulletinInfo();
  virtual ~OgBulletinInfo();
  
  OgBulletinInfo(const OgBulletinInfo& from);
  
  inline OgBulletinInfo& operator=(const OgBulletinInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OgBulletinInfo& default_instance();
  
  void Swap(OgBulletinInfo* other);
  
  // implements Message ----------------------------------------------
  
  OgBulletinInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OgBulletinInfo& from);
  void MergeFrom(const OgBulletinInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  
  // optional string content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  
  // @@protoc_insertion_point(class_scope:OgBulletinInfo)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_content();
  inline void clear_has_content();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* title_;
  ::std::string* content_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_mobileGame_2eproto();
  friend void protobuf_AssignDesc_mobileGame_2eproto();
  friend void protobuf_ShutdownFile_mobileGame_2eproto();
  
  void InitAsDefaultInstance();
  static OgBulletinInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// ReqGameRegister

// required string userName = 1;
inline bool ReqGameRegister::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGameRegister::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGameRegister::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGameRegister::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ReqGameRegister::username() const {
  return *username_;
}
inline void ReqGameRegister::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqGameRegister::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqGameRegister::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqGameRegister::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ReqGameRegister::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string password = 2;
inline bool ReqGameRegister::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqGameRegister::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqGameRegister::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqGameRegister::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& ReqGameRegister::password() const {
  return *password_;
}
inline void ReqGameRegister::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ReqGameRegister::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ReqGameRegister::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqGameRegister::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* ReqGameRegister::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 terminal = 3;
inline bool ReqGameRegister::has_terminal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqGameRegister::set_has_terminal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqGameRegister::clear_has_terminal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqGameRegister::clear_terminal() {
  terminal_ = 0;
  clear_has_terminal();
}
inline ::google::protobuf::int32 ReqGameRegister::terminal() const {
  return terminal_;
}
inline void ReqGameRegister::set_terminal(::google::protobuf::int32 value) {
  set_has_terminal();
  terminal_ = value;
}

// required string deviceNumber = 4;
inline bool ReqGameRegister::has_devicenumber() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqGameRegister::set_has_devicenumber() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqGameRegister::clear_has_devicenumber() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqGameRegister::clear_devicenumber() {
  if (devicenumber_ != &::google::protobuf::internal::kEmptyString) {
    devicenumber_->clear();
  }
  clear_has_devicenumber();
}
inline const ::std::string& ReqGameRegister::devicenumber() const {
  return *devicenumber_;
}
inline void ReqGameRegister::set_devicenumber(const ::std::string& value) {
  set_has_devicenumber();
  if (devicenumber_ == &::google::protobuf::internal::kEmptyString) {
    devicenumber_ = new ::std::string;
  }
  devicenumber_->assign(value);
}
inline void ReqGameRegister::set_devicenumber(const char* value) {
  set_has_devicenumber();
  if (devicenumber_ == &::google::protobuf::internal::kEmptyString) {
    devicenumber_ = new ::std::string;
  }
  devicenumber_->assign(value);
}
inline void ReqGameRegister::set_devicenumber(const char* value, size_t size) {
  set_has_devicenumber();
  if (devicenumber_ == &::google::protobuf::internal::kEmptyString) {
    devicenumber_ = new ::std::string;
  }
  devicenumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqGameRegister::mutable_devicenumber() {
  set_has_devicenumber();
  if (devicenumber_ == &::google::protobuf::internal::kEmptyString) {
    devicenumber_ = new ::std::string;
  }
  return devicenumber_;
}
inline ::std::string* ReqGameRegister::release_devicenumber() {
  clear_has_devicenumber();
  if (devicenumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicenumber_;
    devicenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 gameId = 5;
inline bool ReqGameRegister::has_gameid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqGameRegister::set_has_gameid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqGameRegister::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqGameRegister::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ReqGameRegister::gameid() const {
  return gameid_;
}
inline void ReqGameRegister::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required string comeFrom = 6;
inline bool ReqGameRegister::has_comefrom() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqGameRegister::set_has_comefrom() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqGameRegister::clear_has_comefrom() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqGameRegister::clear_comefrom() {
  if (comefrom_ != &::google::protobuf::internal::kEmptyString) {
    comefrom_->clear();
  }
  clear_has_comefrom();
}
inline const ::std::string& ReqGameRegister::comefrom() const {
  return *comefrom_;
}
inline void ReqGameRegister::set_comefrom(const ::std::string& value) {
  set_has_comefrom();
  if (comefrom_ == &::google::protobuf::internal::kEmptyString) {
    comefrom_ = new ::std::string;
  }
  comefrom_->assign(value);
}
inline void ReqGameRegister::set_comefrom(const char* value) {
  set_has_comefrom();
  if (comefrom_ == &::google::protobuf::internal::kEmptyString) {
    comefrom_ = new ::std::string;
  }
  comefrom_->assign(value);
}
inline void ReqGameRegister::set_comefrom(const char* value, size_t size) {
  set_has_comefrom();
  if (comefrom_ == &::google::protobuf::internal::kEmptyString) {
    comefrom_ = new ::std::string;
  }
  comefrom_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqGameRegister::mutable_comefrom() {
  set_has_comefrom();
  if (comefrom_ == &::google::protobuf::internal::kEmptyString) {
    comefrom_ = new ::std::string;
  }
  return comefrom_;
}
inline ::std::string* ReqGameRegister::release_comefrom() {
  clear_has_comefrom();
  if (comefrom_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comefrom_;
    comefrom_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string token = 7;
inline bool ReqGameRegister::has_token() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqGameRegister::set_has_token() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqGameRegister::clear_has_token() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqGameRegister::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ReqGameRegister::token() const {
  return *token_;
}
inline void ReqGameRegister::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ReqGameRegister::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ReqGameRegister::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqGameRegister::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ReqGameRegister::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string userNameApple = 8;
inline bool ReqGameRegister::has_usernameapple() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReqGameRegister::set_has_usernameapple() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReqGameRegister::clear_has_usernameapple() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReqGameRegister::clear_usernameapple() {
  if (usernameapple_ != &::google::protobuf::internal::kEmptyString) {
    usernameapple_->clear();
  }
  clear_has_usernameapple();
}
inline const ::std::string& ReqGameRegister::usernameapple() const {
  return *usernameapple_;
}
inline void ReqGameRegister::set_usernameapple(const ::std::string& value) {
  set_has_usernameapple();
  if (usernameapple_ == &::google::protobuf::internal::kEmptyString) {
    usernameapple_ = new ::std::string;
  }
  usernameapple_->assign(value);
}
inline void ReqGameRegister::set_usernameapple(const char* value) {
  set_has_usernameapple();
  if (usernameapple_ == &::google::protobuf::internal::kEmptyString) {
    usernameapple_ = new ::std::string;
  }
  usernameapple_->assign(value);
}
inline void ReqGameRegister::set_usernameapple(const char* value, size_t size) {
  set_has_usernameapple();
  if (usernameapple_ == &::google::protobuf::internal::kEmptyString) {
    usernameapple_ = new ::std::string;
  }
  usernameapple_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqGameRegister::mutable_usernameapple() {
  set_has_usernameapple();
  if (usernameapple_ == &::google::protobuf::internal::kEmptyString) {
    usernameapple_ = new ::std::string;
  }
  return usernameapple_;
}
inline ::std::string* ReqGameRegister::release_usernameapple() {
  clear_has_usernameapple();
  if (usernameapple_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usernameapple_;
    usernameapple_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AckGameRegister

// required int32 result = 1;
inline bool AckGameRegister::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckGameRegister::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckGameRegister::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckGameRegister::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckGameRegister::result() const {
  return result_;
}
inline void AckGameRegister::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string errorMsg = 2;
inline bool AckGameRegister::has_errormsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckGameRegister::set_has_errormsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckGameRegister::clear_has_errormsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckGameRegister::clear_errormsg() {
  if (errormsg_ != &::google::protobuf::internal::kEmptyString) {
    errormsg_->clear();
  }
  clear_has_errormsg();
}
inline const ::std::string& AckGameRegister::errormsg() const {
  return *errormsg_;
}
inline void AckGameRegister::set_errormsg(const ::std::string& value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void AckGameRegister::set_errormsg(const char* value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void AckGameRegister::set_errormsg(const char* value, size_t size) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckGameRegister::mutable_errormsg() {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  return errormsg_;
}
inline ::std::string* AckGameRegister::release_errormsg() {
  clear_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormsg_;
    errormsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReqGameLogin

// required string userName = 1;
inline bool ReqGameLogin::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGameLogin::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGameLogin::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGameLogin::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ReqGameLogin::username() const {
  return *username_;
}
inline void ReqGameLogin::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqGameLogin::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqGameLogin::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqGameLogin::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ReqGameLogin::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string password = 2;
inline bool ReqGameLogin::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqGameLogin::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqGameLogin::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqGameLogin::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& ReqGameLogin::password() const {
  return *password_;
}
inline void ReqGameLogin::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ReqGameLogin::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ReqGameLogin::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqGameLogin::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* ReqGameLogin::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 terminal = 3;
inline bool ReqGameLogin::has_terminal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqGameLogin::set_has_terminal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqGameLogin::clear_has_terminal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqGameLogin::clear_terminal() {
  terminal_ = 0;
  clear_has_terminal();
}
inline ::google::protobuf::int32 ReqGameLogin::terminal() const {
  return terminal_;
}
inline void ReqGameLogin::set_terminal(::google::protobuf::int32 value) {
  set_has_terminal();
  terminal_ = value;
}

// required string deviceNumber = 4;
inline bool ReqGameLogin::has_devicenumber() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqGameLogin::set_has_devicenumber() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqGameLogin::clear_has_devicenumber() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqGameLogin::clear_devicenumber() {
  if (devicenumber_ != &::google::protobuf::internal::kEmptyString) {
    devicenumber_->clear();
  }
  clear_has_devicenumber();
}
inline const ::std::string& ReqGameLogin::devicenumber() const {
  return *devicenumber_;
}
inline void ReqGameLogin::set_devicenumber(const ::std::string& value) {
  set_has_devicenumber();
  if (devicenumber_ == &::google::protobuf::internal::kEmptyString) {
    devicenumber_ = new ::std::string;
  }
  devicenumber_->assign(value);
}
inline void ReqGameLogin::set_devicenumber(const char* value) {
  set_has_devicenumber();
  if (devicenumber_ == &::google::protobuf::internal::kEmptyString) {
    devicenumber_ = new ::std::string;
  }
  devicenumber_->assign(value);
}
inline void ReqGameLogin::set_devicenumber(const char* value, size_t size) {
  set_has_devicenumber();
  if (devicenumber_ == &::google::protobuf::internal::kEmptyString) {
    devicenumber_ = new ::std::string;
  }
  devicenumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqGameLogin::mutable_devicenumber() {
  set_has_devicenumber();
  if (devicenumber_ == &::google::protobuf::internal::kEmptyString) {
    devicenumber_ = new ::std::string;
  }
  return devicenumber_;
}
inline ::std::string* ReqGameLogin::release_devicenumber() {
  clear_has_devicenumber();
  if (devicenumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicenumber_;
    devicenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 gameId = 5;
inline bool ReqGameLogin::has_gameid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqGameLogin::set_has_gameid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqGameLogin::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqGameLogin::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ReqGameLogin::gameid() const {
  return gameid_;
}
inline void ReqGameLogin::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required string comeFrom = 6;
inline bool ReqGameLogin::has_comefrom() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqGameLogin::set_has_comefrom() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqGameLogin::clear_has_comefrom() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqGameLogin::clear_comefrom() {
  if (comefrom_ != &::google::protobuf::internal::kEmptyString) {
    comefrom_->clear();
  }
  clear_has_comefrom();
}
inline const ::std::string& ReqGameLogin::comefrom() const {
  return *comefrom_;
}
inline void ReqGameLogin::set_comefrom(const ::std::string& value) {
  set_has_comefrom();
  if (comefrom_ == &::google::protobuf::internal::kEmptyString) {
    comefrom_ = new ::std::string;
  }
  comefrom_->assign(value);
}
inline void ReqGameLogin::set_comefrom(const char* value) {
  set_has_comefrom();
  if (comefrom_ == &::google::protobuf::internal::kEmptyString) {
    comefrom_ = new ::std::string;
  }
  comefrom_->assign(value);
}
inline void ReqGameLogin::set_comefrom(const char* value, size_t size) {
  set_has_comefrom();
  if (comefrom_ == &::google::protobuf::internal::kEmptyString) {
    comefrom_ = new ::std::string;
  }
  comefrom_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqGameLogin::mutable_comefrom() {
  set_has_comefrom();
  if (comefrom_ == &::google::protobuf::internal::kEmptyString) {
    comefrom_ = new ::std::string;
  }
  return comefrom_;
}
inline ::std::string* ReqGameLogin::release_comefrom() {
  clear_has_comefrom();
  if (comefrom_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comefrom_;
    comefrom_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string token = 7;
inline bool ReqGameLogin::has_token() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqGameLogin::set_has_token() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqGameLogin::clear_has_token() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqGameLogin::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ReqGameLogin::token() const {
  return *token_;
}
inline void ReqGameLogin::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ReqGameLogin::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ReqGameLogin::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqGameLogin::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ReqGameLogin::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AckGameLogin

// required int32 result = 1;
inline bool AckGameLogin::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckGameLogin::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckGameLogin::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckGameLogin::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckGameLogin::result() const {
  return result_;
}
inline void AckGameLogin::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string userName = 2;
inline bool AckGameLogin::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckGameLogin::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckGameLogin::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckGameLogin::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& AckGameLogin::username() const {
  return *username_;
}
inline void AckGameLogin::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void AckGameLogin::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void AckGameLogin::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckGameLogin::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* AckGameLogin::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string roleName = 3;
inline bool AckGameLogin::has_rolename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckGameLogin::set_has_rolename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckGameLogin::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckGameLogin::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& AckGameLogin::rolename() const {
  return *rolename_;
}
inline void AckGameLogin::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void AckGameLogin::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void AckGameLogin::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckGameLogin::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* AckGameLogin::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 coin = 4;
inline bool AckGameLogin::has_coin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckGameLogin::set_has_coin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckGameLogin::clear_has_coin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckGameLogin::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 AckGameLogin::coin() const {
  return coin_;
}
inline void AckGameLogin::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// optional int32 gameCoin = 5;
inline bool AckGameLogin::has_gamecoin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckGameLogin::set_has_gamecoin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckGameLogin::clear_has_gamecoin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckGameLogin::clear_gamecoin() {
  gamecoin_ = 0;
  clear_has_gamecoin();
}
inline ::google::protobuf::int32 AckGameLogin::gamecoin() const {
  return gamecoin_;
}
inline void AckGameLogin::set_gamecoin(::google::protobuf::int32 value) {
  set_has_gamecoin();
  gamecoin_ = value;
}

// optional bytes certHaveRole = 6;
inline bool AckGameLogin::has_certhaverole() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckGameLogin::set_has_certhaverole() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckGameLogin::clear_has_certhaverole() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckGameLogin::clear_certhaverole() {
  if (certhaverole_ != &::google::protobuf::internal::kEmptyString) {
    certhaverole_->clear();
  }
  clear_has_certhaverole();
}
inline const ::std::string& AckGameLogin::certhaverole() const {
  return *certhaverole_;
}
inline void AckGameLogin::set_certhaverole(const ::std::string& value) {
  set_has_certhaverole();
  if (certhaverole_ == &::google::protobuf::internal::kEmptyString) {
    certhaverole_ = new ::std::string;
  }
  certhaverole_->assign(value);
}
inline void AckGameLogin::set_certhaverole(const char* value) {
  set_has_certhaverole();
  if (certhaverole_ == &::google::protobuf::internal::kEmptyString) {
    certhaverole_ = new ::std::string;
  }
  certhaverole_->assign(value);
}
inline void AckGameLogin::set_certhaverole(const void* value, size_t size) {
  set_has_certhaverole();
  if (certhaverole_ == &::google::protobuf::internal::kEmptyString) {
    certhaverole_ = new ::std::string;
  }
  certhaverole_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckGameLogin::mutable_certhaverole() {
  set_has_certhaverole();
  if (certhaverole_ == &::google::protobuf::internal::kEmptyString) {
    certhaverole_ = new ::std::string;
  }
  return certhaverole_;
}
inline ::std::string* AckGameLogin::release_certhaverole() {
  clear_has_certhaverole();
  if (certhaverole_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = certhaverole_;
    certhaverole_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes certNoRole = 7;
inline bool AckGameLogin::has_certnorole() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckGameLogin::set_has_certnorole() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckGameLogin::clear_has_certnorole() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckGameLogin::clear_certnorole() {
  if (certnorole_ != &::google::protobuf::internal::kEmptyString) {
    certnorole_->clear();
  }
  clear_has_certnorole();
}
inline const ::std::string& AckGameLogin::certnorole() const {
  return *certnorole_;
}
inline void AckGameLogin::set_certnorole(const ::std::string& value) {
  set_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    certnorole_ = new ::std::string;
  }
  certnorole_->assign(value);
}
inline void AckGameLogin::set_certnorole(const char* value) {
  set_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    certnorole_ = new ::std::string;
  }
  certnorole_->assign(value);
}
inline void AckGameLogin::set_certnorole(const void* value, size_t size) {
  set_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    certnorole_ = new ::std::string;
  }
  certnorole_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckGameLogin::mutable_certnorole() {
  set_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    certnorole_ = new ::std::string;
  }
  return certnorole_;
}
inline ::std::string* AckGameLogin::release_certnorole() {
  clear_has_certnorole();
  if (certnorole_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = certnorole_;
    certnorole_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 curVersion = 8;
inline bool AckGameLogin::has_curversion() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AckGameLogin::set_has_curversion() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AckGameLogin::clear_has_curversion() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AckGameLogin::clear_curversion() {
  curversion_ = 0;
  clear_has_curversion();
}
inline ::google::protobuf::int32 AckGameLogin::curversion() const {
  return curversion_;
}
inline void AckGameLogin::set_curversion(::google::protobuf::int32 value) {
  set_has_curversion();
  curversion_ = value;
}

// optional string playEnable = 9;
inline bool AckGameLogin::has_playenable() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AckGameLogin::set_has_playenable() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AckGameLogin::clear_has_playenable() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AckGameLogin::clear_playenable() {
  if (playenable_ != &::google::protobuf::internal::kEmptyString) {
    playenable_->clear();
  }
  clear_has_playenable();
}
inline const ::std::string& AckGameLogin::playenable() const {
  return *playenable_;
}
inline void AckGameLogin::set_playenable(const ::std::string& value) {
  set_has_playenable();
  if (playenable_ == &::google::protobuf::internal::kEmptyString) {
    playenable_ = new ::std::string;
  }
  playenable_->assign(value);
}
inline void AckGameLogin::set_playenable(const char* value) {
  set_has_playenable();
  if (playenable_ == &::google::protobuf::internal::kEmptyString) {
    playenable_ = new ::std::string;
  }
  playenable_->assign(value);
}
inline void AckGameLogin::set_playenable(const char* value, size_t size) {
  set_has_playenable();
  if (playenable_ == &::google::protobuf::internal::kEmptyString) {
    playenable_ = new ::std::string;
  }
  playenable_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckGameLogin::mutable_playenable() {
  set_has_playenable();
  if (playenable_ == &::google::protobuf::internal::kEmptyString) {
    playenable_ = new ::std::string;
  }
  return playenable_;
}
inline ::std::string* AckGameLogin::release_playenable() {
  clear_has_playenable();
  if (playenable_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playenable_;
    playenable_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string downloadUrl = 10;
inline bool AckGameLogin::has_downloadurl() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AckGameLogin::set_has_downloadurl() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AckGameLogin::clear_has_downloadurl() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AckGameLogin::clear_downloadurl() {
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    downloadurl_->clear();
  }
  clear_has_downloadurl();
}
inline const ::std::string& AckGameLogin::downloadurl() const {
  return *downloadurl_;
}
inline void AckGameLogin::set_downloadurl(const ::std::string& value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void AckGameLogin::set_downloadurl(const char* value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void AckGameLogin::set_downloadurl(const char* value, size_t size) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckGameLogin::mutable_downloadurl() {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  return downloadurl_;
}
inline ::std::string* AckGameLogin::release_downloadurl() {
  clear_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = downloadurl_;
    downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ifStopService = 11;
inline bool AckGameLogin::has_ifstopservice() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AckGameLogin::set_has_ifstopservice() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AckGameLogin::clear_has_ifstopservice() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AckGameLogin::clear_ifstopservice() {
  if (ifstopservice_ != &::google::protobuf::internal::kEmptyString) {
    ifstopservice_->clear();
  }
  clear_has_ifstopservice();
}
inline const ::std::string& AckGameLogin::ifstopservice() const {
  return *ifstopservice_;
}
inline void AckGameLogin::set_ifstopservice(const ::std::string& value) {
  set_has_ifstopservice();
  if (ifstopservice_ == &::google::protobuf::internal::kEmptyString) {
    ifstopservice_ = new ::std::string;
  }
  ifstopservice_->assign(value);
}
inline void AckGameLogin::set_ifstopservice(const char* value) {
  set_has_ifstopservice();
  if (ifstopservice_ == &::google::protobuf::internal::kEmptyString) {
    ifstopservice_ = new ::std::string;
  }
  ifstopservice_->assign(value);
}
inline void AckGameLogin::set_ifstopservice(const char* value, size_t size) {
  set_has_ifstopservice();
  if (ifstopservice_ == &::google::protobuf::internal::kEmptyString) {
    ifstopservice_ = new ::std::string;
  }
  ifstopservice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckGameLogin::mutable_ifstopservice() {
  set_has_ifstopservice();
  if (ifstopservice_ == &::google::protobuf::internal::kEmptyString) {
    ifstopservice_ = new ::std::string;
  }
  return ifstopservice_;
}
inline ::std::string* AckGameLogin::release_ifstopservice() {
  clear_has_ifstopservice();
  if (ifstopservice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ifstopservice_;
    ifstopservice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string stopServiceMsg = 12;
inline bool AckGameLogin::has_stopservicemsg() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AckGameLogin::set_has_stopservicemsg() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AckGameLogin::clear_has_stopservicemsg() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AckGameLogin::clear_stopservicemsg() {
  if (stopservicemsg_ != &::google::protobuf::internal::kEmptyString) {
    stopservicemsg_->clear();
  }
  clear_has_stopservicemsg();
}
inline const ::std::string& AckGameLogin::stopservicemsg() const {
  return *stopservicemsg_;
}
inline void AckGameLogin::set_stopservicemsg(const ::std::string& value) {
  set_has_stopservicemsg();
  if (stopservicemsg_ == &::google::protobuf::internal::kEmptyString) {
    stopservicemsg_ = new ::std::string;
  }
  stopservicemsg_->assign(value);
}
inline void AckGameLogin::set_stopservicemsg(const char* value) {
  set_has_stopservicemsg();
  if (stopservicemsg_ == &::google::protobuf::internal::kEmptyString) {
    stopservicemsg_ = new ::std::string;
  }
  stopservicemsg_->assign(value);
}
inline void AckGameLogin::set_stopservicemsg(const char* value, size_t size) {
  set_has_stopservicemsg();
  if (stopservicemsg_ == &::google::protobuf::internal::kEmptyString) {
    stopservicemsg_ = new ::std::string;
  }
  stopservicemsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckGameLogin::mutable_stopservicemsg() {
  set_has_stopservicemsg();
  if (stopservicemsg_ == &::google::protobuf::internal::kEmptyString) {
    stopservicemsg_ = new ::std::string;
  }
  return stopservicemsg_;
}
inline ::std::string* AckGameLogin::release_stopservicemsg() {
  clear_has_stopservicemsg();
  if (stopservicemsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stopservicemsg_;
    stopservicemsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 downloadReason = 13;
inline bool AckGameLogin::has_downloadreason() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AckGameLogin::set_has_downloadreason() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AckGameLogin::clear_has_downloadreason() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AckGameLogin::clear_downloadreason() {
  downloadreason_ = 0;
  clear_has_downloadreason();
}
inline ::google::protobuf::int32 AckGameLogin::downloadreason() const {
  return downloadreason_;
}
inline void AckGameLogin::set_downloadreason(::google::protobuf::int32 value) {
  set_has_downloadreason();
  downloadreason_ = value;
}

// optional int32 gameId = 14;
inline bool AckGameLogin::has_gameid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AckGameLogin::set_has_gameid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AckGameLogin::clear_has_gameid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AckGameLogin::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 AckGameLogin::gameid() const {
  return gameid_;
}
inline void AckGameLogin::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// repeated .OgRoomInfo matchSvrList = 15;
inline int AckGameLogin::matchsvrlist_size() const {
  return matchsvrlist_.size();
}
inline void AckGameLogin::clear_matchsvrlist() {
  matchsvrlist_.Clear();
}
inline const ::OgRoomInfo& AckGameLogin::matchsvrlist(int index) const {
  return matchsvrlist_.Get(index);
}
inline ::OgRoomInfo* AckGameLogin::mutable_matchsvrlist(int index) {
  return matchsvrlist_.Mutable(index);
}
inline ::OgRoomInfo* AckGameLogin::add_matchsvrlist() {
  return matchsvrlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OgRoomInfo >&
AckGameLogin::matchsvrlist() const {
  return matchsvrlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OgRoomInfo >*
AckGameLogin::mutable_matchsvrlist() {
  return &matchsvrlist_;
}

// repeated .JssInfo payJssList = 16;
inline int AckGameLogin::payjsslist_size() const {
  return payjsslist_.size();
}
inline void AckGameLogin::clear_payjsslist() {
  payjsslist_.Clear();
}
inline const ::JssInfo& AckGameLogin::payjsslist(int index) const {
  return payjsslist_.Get(index);
}
inline ::JssInfo* AckGameLogin::mutable_payjsslist(int index) {
  return payjsslist_.Mutable(index);
}
inline ::JssInfo* AckGameLogin::add_payjsslist() {
  return payjsslist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::JssInfo >&
AckGameLogin::payjsslist() const {
  return payjsslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::JssInfo >*
AckGameLogin::mutable_payjsslist() {
  return &payjsslist_;
}

// repeated .JssInfo gameJssList = 17;
inline int AckGameLogin::gamejsslist_size() const {
  return gamejsslist_.size();
}
inline void AckGameLogin::clear_gamejsslist() {
  gamejsslist_.Clear();
}
inline const ::JssInfo& AckGameLogin::gamejsslist(int index) const {
  return gamejsslist_.Get(index);
}
inline ::JssInfo* AckGameLogin::mutable_gamejsslist(int index) {
  return gamejsslist_.Mutable(index);
}
inline ::JssInfo* AckGameLogin::add_gamejsslist() {
  return gamejsslist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::JssInfo >&
AckGameLogin::gamejsslist() const {
  return gamejsslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::JssInfo >*
AckGameLogin::mutable_gamejsslist() {
  return &gamejsslist_;
}

// optional int32 sex = 18;
inline bool AckGameLogin::has_sex() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void AckGameLogin::set_has_sex() {
  _has_bits_[0] |= 0x00020000u;
}
inline void AckGameLogin::clear_has_sex() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void AckGameLogin::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 AckGameLogin::sex() const {
  return sex_;
}
inline void AckGameLogin::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional string ifDisplaySearch = 19;
inline bool AckGameLogin::has_ifdisplaysearch() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void AckGameLogin::set_has_ifdisplaysearch() {
  _has_bits_[0] |= 0x00040000u;
}
inline void AckGameLogin::clear_has_ifdisplaysearch() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void AckGameLogin::clear_ifdisplaysearch() {
  if (ifdisplaysearch_ != &::google::protobuf::internal::kEmptyString) {
    ifdisplaysearch_->clear();
  }
  clear_has_ifdisplaysearch();
}
inline const ::std::string& AckGameLogin::ifdisplaysearch() const {
  return *ifdisplaysearch_;
}
inline void AckGameLogin::set_ifdisplaysearch(const ::std::string& value) {
  set_has_ifdisplaysearch();
  if (ifdisplaysearch_ == &::google::protobuf::internal::kEmptyString) {
    ifdisplaysearch_ = new ::std::string;
  }
  ifdisplaysearch_->assign(value);
}
inline void AckGameLogin::set_ifdisplaysearch(const char* value) {
  set_has_ifdisplaysearch();
  if (ifdisplaysearch_ == &::google::protobuf::internal::kEmptyString) {
    ifdisplaysearch_ = new ::std::string;
  }
  ifdisplaysearch_->assign(value);
}
inline void AckGameLogin::set_ifdisplaysearch(const char* value, size_t size) {
  set_has_ifdisplaysearch();
  if (ifdisplaysearch_ == &::google::protobuf::internal::kEmptyString) {
    ifdisplaysearch_ = new ::std::string;
  }
  ifdisplaysearch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckGameLogin::mutable_ifdisplaysearch() {
  set_has_ifdisplaysearch();
  if (ifdisplaysearch_ == &::google::protobuf::internal::kEmptyString) {
    ifdisplaysearch_ = new ::std::string;
  }
  return ifdisplaysearch_;
}
inline ::std::string* AckGameLogin::release_ifdisplaysearch() {
  clear_has_ifdisplaysearch();
  if (ifdisplaysearch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ifdisplaysearch_;
    ifdisplaysearch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .OgBulletinInfo bulletinList = 20;
inline int AckGameLogin::bulletinlist_size() const {
  return bulletinlist_.size();
}
inline void AckGameLogin::clear_bulletinlist() {
  bulletinlist_.Clear();
}
inline const ::OgBulletinInfo& AckGameLogin::bulletinlist(int index) const {
  return bulletinlist_.Get(index);
}
inline ::OgBulletinInfo* AckGameLogin::mutable_bulletinlist(int index) {
  return bulletinlist_.Mutable(index);
}
inline ::OgBulletinInfo* AckGameLogin::add_bulletinlist() {
  return bulletinlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OgBulletinInfo >&
AckGameLogin::bulletinlist() const {
  return bulletinlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OgBulletinInfo >*
AckGameLogin::mutable_bulletinlist() {
  return &bulletinlist_;
}

// optional string versionInfo = 21;
inline bool AckGameLogin::has_versioninfo() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void AckGameLogin::set_has_versioninfo() {
  _has_bits_[0] |= 0x00100000u;
}
inline void AckGameLogin::clear_has_versioninfo() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void AckGameLogin::clear_versioninfo() {
  if (versioninfo_ != &::google::protobuf::internal::kEmptyString) {
    versioninfo_->clear();
  }
  clear_has_versioninfo();
}
inline const ::std::string& AckGameLogin::versioninfo() const {
  return *versioninfo_;
}
inline void AckGameLogin::set_versioninfo(const ::std::string& value) {
  set_has_versioninfo();
  if (versioninfo_ == &::google::protobuf::internal::kEmptyString) {
    versioninfo_ = new ::std::string;
  }
  versioninfo_->assign(value);
}
inline void AckGameLogin::set_versioninfo(const char* value) {
  set_has_versioninfo();
  if (versioninfo_ == &::google::protobuf::internal::kEmptyString) {
    versioninfo_ = new ::std::string;
  }
  versioninfo_->assign(value);
}
inline void AckGameLogin::set_versioninfo(const char* value, size_t size) {
  set_has_versioninfo();
  if (versioninfo_ == &::google::protobuf::internal::kEmptyString) {
    versioninfo_ = new ::std::string;
  }
  versioninfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckGameLogin::mutable_versioninfo() {
  set_has_versioninfo();
  if (versioninfo_ == &::google::protobuf::internal::kEmptyString) {
    versioninfo_ = new ::std::string;
  }
  return versioninfo_;
}
inline ::std::string* AckGameLogin::release_versioninfo() {
  clear_has_versioninfo();
  if (versioninfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = versioninfo_;
    versioninfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string userMsgUrl = 22;
inline bool AckGameLogin::has_usermsgurl() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void AckGameLogin::set_has_usermsgurl() {
  _has_bits_[0] |= 0x00200000u;
}
inline void AckGameLogin::clear_has_usermsgurl() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void AckGameLogin::clear_usermsgurl() {
  if (usermsgurl_ != &::google::protobuf::internal::kEmptyString) {
    usermsgurl_->clear();
  }
  clear_has_usermsgurl();
}
inline const ::std::string& AckGameLogin::usermsgurl() const {
  return *usermsgurl_;
}
inline void AckGameLogin::set_usermsgurl(const ::std::string& value) {
  set_has_usermsgurl();
  if (usermsgurl_ == &::google::protobuf::internal::kEmptyString) {
    usermsgurl_ = new ::std::string;
  }
  usermsgurl_->assign(value);
}
inline void AckGameLogin::set_usermsgurl(const char* value) {
  set_has_usermsgurl();
  if (usermsgurl_ == &::google::protobuf::internal::kEmptyString) {
    usermsgurl_ = new ::std::string;
  }
  usermsgurl_->assign(value);
}
inline void AckGameLogin::set_usermsgurl(const char* value, size_t size) {
  set_has_usermsgurl();
  if (usermsgurl_ == &::google::protobuf::internal::kEmptyString) {
    usermsgurl_ = new ::std::string;
  }
  usermsgurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckGameLogin::mutable_usermsgurl() {
  set_has_usermsgurl();
  if (usermsgurl_ == &::google::protobuf::internal::kEmptyString) {
    usermsgurl_ = new ::std::string;
  }
  return usermsgurl_;
}
inline ::std::string* AckGameLogin::release_usermsgurl() {
  clear_has_usermsgurl();
  if (usermsgurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usermsgurl_;
    usermsgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// OgRoomInfo

// required string RoomId = 1;
inline bool OgRoomInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OgRoomInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OgRoomInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OgRoomInfo::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& OgRoomInfo::roomid() const {
  return *roomid_;
}
inline void OgRoomInfo::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void OgRoomInfo::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void OgRoomInfo::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OgRoomInfo::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* OgRoomInfo::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoomRank = 2;
inline bool OgRoomInfo::has_roomrank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OgRoomInfo::set_has_roomrank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OgRoomInfo::clear_has_roomrank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OgRoomInfo::clear_roomrank() {
  if (roomrank_ != &::google::protobuf::internal::kEmptyString) {
    roomrank_->clear();
  }
  clear_has_roomrank();
}
inline const ::std::string& OgRoomInfo::roomrank() const {
  return *roomrank_;
}
inline void OgRoomInfo::set_roomrank(const ::std::string& value) {
  set_has_roomrank();
  if (roomrank_ == &::google::protobuf::internal::kEmptyString) {
    roomrank_ = new ::std::string;
  }
  roomrank_->assign(value);
}
inline void OgRoomInfo::set_roomrank(const char* value) {
  set_has_roomrank();
  if (roomrank_ == &::google::protobuf::internal::kEmptyString) {
    roomrank_ = new ::std::string;
  }
  roomrank_->assign(value);
}
inline void OgRoomInfo::set_roomrank(const char* value, size_t size) {
  set_has_roomrank();
  if (roomrank_ == &::google::protobuf::internal::kEmptyString) {
    roomrank_ = new ::std::string;
  }
  roomrank_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OgRoomInfo::mutable_roomrank() {
  set_has_roomrank();
  if (roomrank_ == &::google::protobuf::internal::kEmptyString) {
    roomrank_ = new ::std::string;
  }
  return roomrank_;
}
inline ::std::string* OgRoomInfo::release_roomrank() {
  clear_has_roomrank();
  if (roomrank_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomrank_;
    roomrank_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoomIp = 3;
inline bool OgRoomInfo::has_roomip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OgRoomInfo::set_has_roomip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OgRoomInfo::clear_has_roomip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OgRoomInfo::clear_roomip() {
  if (roomip_ != &::google::protobuf::internal::kEmptyString) {
    roomip_->clear();
  }
  clear_has_roomip();
}
inline const ::std::string& OgRoomInfo::roomip() const {
  return *roomip_;
}
inline void OgRoomInfo::set_roomip(const ::std::string& value) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(value);
}
inline void OgRoomInfo::set_roomip(const char* value) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(value);
}
inline void OgRoomInfo::set_roomip(const char* value, size_t size) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OgRoomInfo::mutable_roomip() {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  return roomip_;
}
inline ::std::string* OgRoomInfo::release_roomip() {
  clear_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomip_;
    roomip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoomPort = 4;
inline bool OgRoomInfo::has_roomport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OgRoomInfo::set_has_roomport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OgRoomInfo::clear_has_roomport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OgRoomInfo::clear_roomport() {
  if (roomport_ != &::google::protobuf::internal::kEmptyString) {
    roomport_->clear();
  }
  clear_has_roomport();
}
inline const ::std::string& OgRoomInfo::roomport() const {
  return *roomport_;
}
inline void OgRoomInfo::set_roomport(const ::std::string& value) {
  set_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    roomport_ = new ::std::string;
  }
  roomport_->assign(value);
}
inline void OgRoomInfo::set_roomport(const char* value) {
  set_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    roomport_ = new ::std::string;
  }
  roomport_->assign(value);
}
inline void OgRoomInfo::set_roomport(const char* value, size_t size) {
  set_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    roomport_ = new ::std::string;
  }
  roomport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OgRoomInfo::mutable_roomport() {
  set_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    roomport_ = new ::std::string;
  }
  return roomport_;
}
inline ::std::string* OgRoomInfo::release_roomport() {
  clear_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomport_;
    roomport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoomStatus = 5;
inline bool OgRoomInfo::has_roomstatus() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OgRoomInfo::set_has_roomstatus() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OgRoomInfo::clear_has_roomstatus() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OgRoomInfo::clear_roomstatus() {
  if (roomstatus_ != &::google::protobuf::internal::kEmptyString) {
    roomstatus_->clear();
  }
  clear_has_roomstatus();
}
inline const ::std::string& OgRoomInfo::roomstatus() const {
  return *roomstatus_;
}
inline void OgRoomInfo::set_roomstatus(const ::std::string& value) {
  set_has_roomstatus();
  if (roomstatus_ == &::google::protobuf::internal::kEmptyString) {
    roomstatus_ = new ::std::string;
  }
  roomstatus_->assign(value);
}
inline void OgRoomInfo::set_roomstatus(const char* value) {
  set_has_roomstatus();
  if (roomstatus_ == &::google::protobuf::internal::kEmptyString) {
    roomstatus_ = new ::std::string;
  }
  roomstatus_->assign(value);
}
inline void OgRoomInfo::set_roomstatus(const char* value, size_t size) {
  set_has_roomstatus();
  if (roomstatus_ == &::google::protobuf::internal::kEmptyString) {
    roomstatus_ = new ::std::string;
  }
  roomstatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OgRoomInfo::mutable_roomstatus() {
  set_has_roomstatus();
  if (roomstatus_ == &::google::protobuf::internal::kEmptyString) {
    roomstatus_ = new ::std::string;
  }
  return roomstatus_;
}
inline ::std::string* OgRoomInfo::release_roomstatus() {
  clear_has_roomstatus();
  if (roomstatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomstatus_;
    roomstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoomMinGold = 6;
inline bool OgRoomInfo::has_roommingold() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OgRoomInfo::set_has_roommingold() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OgRoomInfo::clear_has_roommingold() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OgRoomInfo::clear_roommingold() {
  if (roommingold_ != &::google::protobuf::internal::kEmptyString) {
    roommingold_->clear();
  }
  clear_has_roommingold();
}
inline const ::std::string& OgRoomInfo::roommingold() const {
  return *roommingold_;
}
inline void OgRoomInfo::set_roommingold(const ::std::string& value) {
  set_has_roommingold();
  if (roommingold_ == &::google::protobuf::internal::kEmptyString) {
    roommingold_ = new ::std::string;
  }
  roommingold_->assign(value);
}
inline void OgRoomInfo::set_roommingold(const char* value) {
  set_has_roommingold();
  if (roommingold_ == &::google::protobuf::internal::kEmptyString) {
    roommingold_ = new ::std::string;
  }
  roommingold_->assign(value);
}
inline void OgRoomInfo::set_roommingold(const char* value, size_t size) {
  set_has_roommingold();
  if (roommingold_ == &::google::protobuf::internal::kEmptyString) {
    roommingold_ = new ::std::string;
  }
  roommingold_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OgRoomInfo::mutable_roommingold() {
  set_has_roommingold();
  if (roommingold_ == &::google::protobuf::internal::kEmptyString) {
    roommingold_ = new ::std::string;
  }
  return roommingold_;
}
inline ::std::string* OgRoomInfo::release_roommingold() {
  clear_has_roommingold();
  if (roommingold_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roommingold_;
    roommingold_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoomMaxGold = 7;
inline bool OgRoomInfo::has_roommaxgold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OgRoomInfo::set_has_roommaxgold() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OgRoomInfo::clear_has_roommaxgold() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OgRoomInfo::clear_roommaxgold() {
  if (roommaxgold_ != &::google::protobuf::internal::kEmptyString) {
    roommaxgold_->clear();
  }
  clear_has_roommaxgold();
}
inline const ::std::string& OgRoomInfo::roommaxgold() const {
  return *roommaxgold_;
}
inline void OgRoomInfo::set_roommaxgold(const ::std::string& value) {
  set_has_roommaxgold();
  if (roommaxgold_ == &::google::protobuf::internal::kEmptyString) {
    roommaxgold_ = new ::std::string;
  }
  roommaxgold_->assign(value);
}
inline void OgRoomInfo::set_roommaxgold(const char* value) {
  set_has_roommaxgold();
  if (roommaxgold_ == &::google::protobuf::internal::kEmptyString) {
    roommaxgold_ = new ::std::string;
  }
  roommaxgold_->assign(value);
}
inline void OgRoomInfo::set_roommaxgold(const char* value, size_t size) {
  set_has_roommaxgold();
  if (roommaxgold_ == &::google::protobuf::internal::kEmptyString) {
    roommaxgold_ = new ::std::string;
  }
  roommaxgold_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OgRoomInfo::mutable_roommaxgold() {
  set_has_roommaxgold();
  if (roommaxgold_ == &::google::protobuf::internal::kEmptyString) {
    roommaxgold_ = new ::std::string;
  }
  return roommaxgold_;
}
inline ::std::string* OgRoomInfo::release_roommaxgold() {
  clear_has_roommaxgold();
  if (roommaxgold_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roommaxgold_;
    roommaxgold_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoomMinPlay = 8;
inline bool OgRoomInfo::has_roomminplay() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OgRoomInfo::set_has_roomminplay() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OgRoomInfo::clear_has_roomminplay() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OgRoomInfo::clear_roomminplay() {
  if (roomminplay_ != &::google::protobuf::internal::kEmptyString) {
    roomminplay_->clear();
  }
  clear_has_roomminplay();
}
inline const ::std::string& OgRoomInfo::roomminplay() const {
  return *roomminplay_;
}
inline void OgRoomInfo::set_roomminplay(const ::std::string& value) {
  set_has_roomminplay();
  if (roomminplay_ == &::google::protobuf::internal::kEmptyString) {
    roomminplay_ = new ::std::string;
  }
  roomminplay_->assign(value);
}
inline void OgRoomInfo::set_roomminplay(const char* value) {
  set_has_roomminplay();
  if (roomminplay_ == &::google::protobuf::internal::kEmptyString) {
    roomminplay_ = new ::std::string;
  }
  roomminplay_->assign(value);
}
inline void OgRoomInfo::set_roomminplay(const char* value, size_t size) {
  set_has_roomminplay();
  if (roomminplay_ == &::google::protobuf::internal::kEmptyString) {
    roomminplay_ = new ::std::string;
  }
  roomminplay_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OgRoomInfo::mutable_roomminplay() {
  set_has_roomminplay();
  if (roomminplay_ == &::google::protobuf::internal::kEmptyString) {
    roomminplay_ = new ::std::string;
  }
  return roomminplay_;
}
inline ::std::string* OgRoomInfo::release_roomminplay() {
  clear_has_roomminplay();
  if (roomminplay_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomminplay_;
    roomminplay_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RoomType = 9;
inline bool OgRoomInfo::has_roomtype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OgRoomInfo::set_has_roomtype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OgRoomInfo::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OgRoomInfo::clear_roomtype() {
  if (roomtype_ != &::google::protobuf::internal::kEmptyString) {
    roomtype_->clear();
  }
  clear_has_roomtype();
}
inline const ::std::string& OgRoomInfo::roomtype() const {
  return *roomtype_;
}
inline void OgRoomInfo::set_roomtype(const ::std::string& value) {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::kEmptyString) {
    roomtype_ = new ::std::string;
  }
  roomtype_->assign(value);
}
inline void OgRoomInfo::set_roomtype(const char* value) {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::kEmptyString) {
    roomtype_ = new ::std::string;
  }
  roomtype_->assign(value);
}
inline void OgRoomInfo::set_roomtype(const char* value, size_t size) {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::kEmptyString) {
    roomtype_ = new ::std::string;
  }
  roomtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OgRoomInfo::mutable_roomtype() {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::kEmptyString) {
    roomtype_ = new ::std::string;
  }
  return roomtype_;
}
inline ::std::string* OgRoomInfo::release_roomtype() {
  clear_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomtype_;
    roomtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ServerType = 10;
inline bool OgRoomInfo::has_servertype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OgRoomInfo::set_has_servertype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OgRoomInfo::clear_has_servertype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OgRoomInfo::clear_servertype() {
  if (servertype_ != &::google::protobuf::internal::kEmptyString) {
    servertype_->clear();
  }
  clear_has_servertype();
}
inline const ::std::string& OgRoomInfo::servertype() const {
  return *servertype_;
}
inline void OgRoomInfo::set_servertype(const ::std::string& value) {
  set_has_servertype();
  if (servertype_ == &::google::protobuf::internal::kEmptyString) {
    servertype_ = new ::std::string;
  }
  servertype_->assign(value);
}
inline void OgRoomInfo::set_servertype(const char* value) {
  set_has_servertype();
  if (servertype_ == &::google::protobuf::internal::kEmptyString) {
    servertype_ = new ::std::string;
  }
  servertype_->assign(value);
}
inline void OgRoomInfo::set_servertype(const char* value, size_t size) {
  set_has_servertype();
  if (servertype_ == &::google::protobuf::internal::kEmptyString) {
    servertype_ = new ::std::string;
  }
  servertype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OgRoomInfo::mutable_servertype() {
  set_has_servertype();
  if (servertype_ == &::google::protobuf::internal::kEmptyString) {
    servertype_ = new ::std::string;
  }
  return servertype_;
}
inline ::std::string* OgRoomInfo::release_servertype() {
  clear_has_servertype();
  if (servertype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servertype_;
    servertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Description = 11;
inline bool OgRoomInfo::has_description() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OgRoomInfo::set_has_description() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OgRoomInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OgRoomInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& OgRoomInfo::description() const {
  return *description_;
}
inline void OgRoomInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void OgRoomInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void OgRoomInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OgRoomInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* OgRoomInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RoomName = 12;
inline bool OgRoomInfo::has_roomname() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OgRoomInfo::set_has_roomname() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OgRoomInfo::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OgRoomInfo::clear_roomname() {
  if (roomname_ != &::google::protobuf::internal::kEmptyString) {
    roomname_->clear();
  }
  clear_has_roomname();
}
inline const ::std::string& OgRoomInfo::roomname() const {
  return *roomname_;
}
inline void OgRoomInfo::set_roomname(const ::std::string& value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void OgRoomInfo::set_roomname(const char* value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void OgRoomInfo::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OgRoomInfo::mutable_roomname() {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  return roomname_;
}
inline ::std::string* OgRoomInfo::release_roomname() {
  clear_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomname_;
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// JssInfo

// optional string roomIP = 1;
inline bool JssInfo::has_roomip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JssInfo::set_has_roomip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JssInfo::clear_has_roomip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JssInfo::clear_roomip() {
  if (roomip_ != &::google::protobuf::internal::kEmptyString) {
    roomip_->clear();
  }
  clear_has_roomip();
}
inline const ::std::string& JssInfo::roomip() const {
  return *roomip_;
}
inline void JssInfo::set_roomip(const ::std::string& value) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(value);
}
inline void JssInfo::set_roomip(const char* value) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(value);
}
inline void JssInfo::set_roomip(const char* value, size_t size) {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  roomip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JssInfo::mutable_roomip() {
  set_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    roomip_ = new ::std::string;
  }
  return roomip_;
}
inline ::std::string* JssInfo::release_roomip() {
  clear_has_roomip();
  if (roomip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomip_;
    roomip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string roomPort = 2;
inline bool JssInfo::has_roomport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JssInfo::set_has_roomport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JssInfo::clear_has_roomport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JssInfo::clear_roomport() {
  if (roomport_ != &::google::protobuf::internal::kEmptyString) {
    roomport_->clear();
  }
  clear_has_roomport();
}
inline const ::std::string& JssInfo::roomport() const {
  return *roomport_;
}
inline void JssInfo::set_roomport(const ::std::string& value) {
  set_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    roomport_ = new ::std::string;
  }
  roomport_->assign(value);
}
inline void JssInfo::set_roomport(const char* value) {
  set_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    roomport_ = new ::std::string;
  }
  roomport_->assign(value);
}
inline void JssInfo::set_roomport(const char* value, size_t size) {
  set_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    roomport_ = new ::std::string;
  }
  roomport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JssInfo::mutable_roomport() {
  set_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    roomport_ = new ::std::string;
  }
  return roomport_;
}
inline ::std::string* JssInfo::release_roomport() {
  clear_has_roomport();
  if (roomport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomport_;
    roomport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string remark = 3;
inline bool JssInfo::has_remark() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JssInfo::set_has_remark() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JssInfo::clear_has_remark() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JssInfo::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& JssInfo::remark() const {
  return *remark_;
}
inline void JssInfo::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void JssInfo::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void JssInfo::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JssInfo::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* JssInfo::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// OgBulletinInfo

// optional string title = 1;
inline bool OgBulletinInfo::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OgBulletinInfo::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OgBulletinInfo::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OgBulletinInfo::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& OgBulletinInfo::title() const {
  return *title_;
}
inline void OgBulletinInfo::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void OgBulletinInfo::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void OgBulletinInfo::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OgBulletinInfo::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* OgBulletinInfo::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string content = 2;
inline bool OgBulletinInfo::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OgBulletinInfo::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OgBulletinInfo::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OgBulletinInfo::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& OgBulletinInfo::content() const {
  return *content_;
}
inline void OgBulletinInfo::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void OgBulletinInfo::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void OgBulletinInfo::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OgBulletinInfo::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* OgBulletinInfo::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mobileGame_2eproto__INCLUDED
